!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ABORT	typeemu.h	/^enum FAULT_STATUS { UNKNOWN, DETECTED, REDUNDANT, ABORT };$/;"	e	enum:FAULT_STATUS
ALL_ASSIGNED	typeemu.h	/^enum FLAGS { ALL_ASSIGNED, MARKED, FAULT_INJECTED, FAULTY, SCHEDULED, OUTPUT, NumFlags };$/;"	e	enum:FLAGS
ATPG_STATUS	typeemu.h	/^enum ATPG_STATUS { TRUE, CONFLICT, FALSE };$/;"	g
AddGate	circuit.h	/^        void AddGate(GATE* gptr) { Netlist.push_back(gptr); }$/;"	f	class:CIRCUIT
AddInput_list	gate.h	/^        void AddInput_list(GATE* gptr){Input_list.push_back(gptr);}$/;"	f	class:GATE
AddOutput_list	gate.h	/^        void AddOutput_list(GATE* gptr){Output_list.push_back(gptr);}$/;"	f	class:GATE
AndTable	typeemu.h	/^const VALUE AndTable[5][5] =  { { S0,  S0,  S0,  S0,  S0 },$/;"	v
Atpg	atpg.cc	/^void CIRCUIT::Atpg()$/;"	f	class:CIRCUIT
B	typeemu.h	/^enum VALUE {S0, S1, X, D, B, ILLIGAL};$/;"	e	enum:VALUE
BackTrackLimit	circuit.h	/^        unsigned BackTrackLimit; \/\/backtrack limit for Podem$/;"	m	class:CIRCUIT
BackwardImply	atpg.cc	/^ATPG_STATUS CIRCUIT::BackwardImply(GATEPTR gptr, VALUE value)$/;"	f	class:CIRCUIT
BackwardImply_t	tfatpg.cc	/^ATPG_STATUS CIRCUIT::BackwardImply_t(GATEPTR gptr, VALUE value)$/;"	f	class:CIRCUIT
Branch	fault.h	/^        bool Branch; \/\/fault is on branch$/;"	m	class:FAULT
Branch	tfault.h	/^        bool Branch; \/\/fault is on branch$/;"	m	class:TFAULT
CIRCUIT	circuit.h	/^        CIRCUIT(): MaxLevel(0), BackTrackLimit(10000) {$/;"	f	class:CIRCUIT
CIRCUIT	circuit.h	/^        CIRCUIT(unsigned NO_GATE, unsigned NO_PI = 128, unsigned NO_PO = 512,$/;"	f	class:CIRCUIT
CIRCUIT	circuit.h	/^class CIRCUIT$/;"	c
CIRCUIT_H	circuit.h	2;"	d
CONFLICT	typeemu.h	/^enum ATPG_STATUS { TRUE, CONFLICT, FALSE };$/;"	e	enum:ATPG_STATUS
CV	typeemu.h	/^const VALUE CV[] = {X, X, X, X, X, S0, S0, S1, S1, X, X, X};$/;"	v
CXX	Makefile	/^CXX      = g++$/;"	m
CXXFLAGS	Makefile	/^CXXFLAGS = -O2 -Wall -DDEBUG$/;"	m
Cache	hash.h	/^    Cache(int s = 8191) : bucket(s) { _size = s; }$/;"	f	class:Cache
Cache	hash.h	/^class Cache$/;"	c
Cell	GetLongOpt.h	/^            Cell() { option = description = value = 0; next = 0; }$/;"	f	struct:GetLongOpt::Cell
Cell	GetLongOpt.h	/^        struct Cell$/;"	s	class:GetLongOpt
ChangeFanin	gate.h	/^        void ChangeFanin(int i, GATE* g) {Input_list[i] = g;}$/;"	f	class:GATE
ChangeFanout	gate.h	/^        void ChangeFanout(int i, GATE* g) {Output_list[i] = g;}$/;"	f	class:GATE
CheckFaultyGate	fsim.cc	/^bool CIRCUIT::CheckFaultyGate(FAULT* fptr)$/;"	f	class:CIRCUIT
CheckTFaultyGate	stfsim.cc	/^bool CIRCUIT::CheckTFaultyGate(TFAULT* fptr)$/;"	f	class:CIRCUIT
CheckTFaultyGate_t	stfsim.cc	/^bool CIRCUIT::CheckTFaultyGate_t(TFAULT* fptr)$/;"	f	class:CIRCUIT
CheckTest	atpg.cc	/^bool CIRCUIT::CheckTest()$/;"	f	class:CIRCUIT
Check_Levelization	circuit.cc	/^void CIRCUIT::Check_Levelization()$/;"	f	class:CIRCUIT
Count	gate.h	/^        unsigned Count[2]; \/\/used by Levelize(), FindStaticPivot(),PathSearch$/;"	m	class:GATE
D	typeemu.h	/^enum VALUE {S0, S1, X, D, B, ILLIGAL};$/;"	e	enum:VALUE
DEL_FILE	Makefile	/^DEL_FILE = rm -f$/;"	m
DETECTED	typeemu.h	/^enum FAULT_STATUS { UNKNOWN, DETECTED, REDUNDANT, ABORT };$/;"	e	enum:FAULT_STATUS
DecCount	gate.h	/^        void DecCount(unsigned i = 0) {Count[i]--;}$/;"	f	class:GATE
EqvFaultNum	fault.h	/^        unsigned EqvFaultNum; \/\/equivalent fault number (includes itself)$/;"	m	class:FAULT
EqvFaultNum	tfault.h	/^        unsigned EqvFaultNum; \/\/equivalent fault number (includes itself)$/;"	m	class:TFAULT
EqvTable	typeemu.h	/^const VALUE EqvTable[5][5] =  { { S1,  S0,  X,  B,  D },$/;"	v
Evaluate	sim.cc	/^VALUE CIRCUIT::Evaluate(GATEPTR gptr)$/;"	f	class:CIRCUIT
Evaluate_t	stfsim.cc	/^VALUE CIRCUIT::Evaluate_t(GATEPTR gptr)$/;"	f	class:CIRCUIT
Exec	hash.h	/^class Exec$/;"	c
FALSE	typeemu.h	/^enum ATPG_STATUS { TRUE, CONFLICT, FALSE };$/;"	e	enum:ATPG_STATUS
FAULT	fault.h	/^        FAULT(GATE* gptr, GATE* ogptr, VALUE value): Value(value), Input(gptr),$/;"	f	class:FAULT
FAULT	fault.h	/^class FAULT$/;"	c
FAULTY	typeemu.h	/^enum FLAGS { ALL_ASSIGNED, MARKED, FAULT_INJECTED, FAULTY, SCHEDULED, OUTPUT, NumFlags };$/;"	e	enum:FLAGS
FAULT_H	fault.h	2;"	d
FAULT_INJECTED	typeemu.h	/^enum FLAGS { ALL_ASSIGNED, MARKED, FAULT_INJECTED, FAULTY, SCHEDULED, OUTPUT, NumFlags };$/;"	e	enum:FLAGS
FAULT_STATUS	typeemu.h	/^enum FAULT_STATUS { UNKNOWN, DETECTED, REDUNDANT, ABORT };$/;"	g
FLAGS	typeemu.h	/^enum FLAGS { ALL_ASSIGNED, MARKED, FAULT_INJECTED, FAULTY, SCHEDULED, OUTPUT, NumFlags };$/;"	g
Fanin	gate.h	/^        GATE* Fanin(int i) { return Input_list[i];}$/;"	f	class:GATE
Fanout	gate.h	/^        GATE* Fanout(int i) { return Output_list[i];}$/;"	f	class:GATE
FanoutList	circuit.cc	/^void CIRCUIT::FanoutList()$/;"	f	class:CIRCUIT
FaultEvaluate	atpg.cc	/^bool CIRCUIT::FaultEvaluate(FAULT* fptr)$/;"	f	class:CIRCUIT
FaultFlag	gate.h	/^        bitset<PatternNum> FaultFlag;$/;"	m	class:GATE
FaultSim	fsim.cc	/^void CIRCUIT::FaultSim()$/;"	f	class:CIRCUIT
FaultSimEvaluate	fsim.cc	/^void CIRCUIT::FaultSimEvaluate(GATEPTR gptr)$/;"	f	class:CIRCUIT
FaultSimVectors	fsim.cc	/^void CIRCUIT::FaultSimVectors()$/;"	f	class:CIRCUIT
FindEasiestControl	atpg.cc	/^GATEPTR CIRCUIT::FindEasiestControl(GATEPTR gptr)$/;"	f	class:CIRCUIT
FindEasiestControl_t	tfatpg.cc	/^GATEPTR CIRCUIT::FindEasiestControl_t(GATEPTR gptr)$/;"	f	class:CIRCUIT
FindHardestControl	atpg.cc	/^GATEPTR CIRCUIT::FindHardestControl(GATEPTR gptr)$/;"	f	class:CIRCUIT
FindHardestControl_t	tfatpg.cc	/^GATEPTR CIRCUIT::FindHardestControl_t(GATEPTR gptr)$/;"	f	class:CIRCUIT
FindPIAssignment	atpg.cc	/^GATEPTR CIRCUIT::FindPIAssignment(GATEPTR gptr, VALUE value)$/;"	f	class:CIRCUIT
FindPIAssignment_t	tfatpg.cc	/^GATEPTR CIRCUIT::FindPIAssignment_t(GATEPTR gptr, VALUE value)$/;"	f	class:CIRCUIT
FindPropagateGate	atpg.cc	/^GATEPTR CIRCUIT::FindPropagateGate()$/;"	f	class:CIRCUIT
Flag	gate.h	/^        bitset<NumFlags> Flag;$/;"	m	class:GATE
Flist	circuit.h	/^        list<FAULT*> Flist; \/\/collapsing fault list$/;"	m	class:CIRCUIT
Function	gate.h	/^        GATEFUNC Function;$/;"	m	class:GATE
GATE	gate.h	/^        GATE(): Function(G_BAD), Level(0), Value(X), Value_t(X), Inversion(false) {$/;"	f	class:GATE
GATE	gate.h	/^class GATE$/;"	c
GATEFUNC	typeemu.h	/^enum GATEFUNC {G_PI, G_PO, G_PPI, G_PPO, G_NOT, G_AND, G_NAND, G_OR, G_NOR, G_DFF, G_BUF, G_BAD };$/;"	g
GATEPTR	circuit.h	/^typedef GATE* GATEPTR;$/;"	t
GATE_H	gate.h	2;"	d
G_AND	typeemu.h	/^enum GATEFUNC {G_PI, G_PO, G_PPI, G_PPO, G_NOT, G_AND, G_NAND, G_OR, G_NOR, G_DFF, G_BUF, G_BAD };$/;"	e	enum:GATEFUNC
G_BAD	typeemu.h	/^enum GATEFUNC {G_PI, G_PO, G_PPI, G_PPO, G_NOT, G_AND, G_NAND, G_OR, G_NOR, G_DFF, G_BUF, G_BAD };$/;"	e	enum:GATEFUNC
G_BUF	typeemu.h	/^enum GATEFUNC {G_PI, G_PO, G_PPI, G_PPO, G_NOT, G_AND, G_NAND, G_OR, G_NOR, G_DFF, G_BUF, G_BAD };$/;"	e	enum:GATEFUNC
G_DFF	typeemu.h	/^enum GATEFUNC {G_PI, G_PO, G_PPI, G_PPO, G_NOT, G_AND, G_NAND, G_OR, G_NOR, G_DFF, G_BUF, G_BAD };$/;"	e	enum:GATEFUNC
G_NAND	typeemu.h	/^enum GATEFUNC {G_PI, G_PO, G_PPI, G_PPO, G_NOT, G_AND, G_NAND, G_OR, G_NOR, G_DFF, G_BUF, G_BAD };$/;"	e	enum:GATEFUNC
G_NOR	typeemu.h	/^enum GATEFUNC {G_PI, G_PO, G_PPI, G_PPO, G_NOT, G_AND, G_NAND, G_OR, G_NOR, G_DFF, G_BUF, G_BAD };$/;"	e	enum:GATEFUNC
G_NOT	typeemu.h	/^enum GATEFUNC {G_PI, G_PO, G_PPI, G_PPO, G_NOT, G_AND, G_NAND, G_OR, G_NOR, G_DFF, G_BUF, G_BAD };$/;"	e	enum:GATEFUNC
G_OR	typeemu.h	/^enum GATEFUNC {G_PI, G_PO, G_PPI, G_PPO, G_NOT, G_AND, G_NAND, G_OR, G_NOR, G_DFF, G_BUF, G_BAD };$/;"	e	enum:GATEFUNC
G_PI	typeemu.h	/^enum GATEFUNC {G_PI, G_PO, G_PPI, G_PPO, G_NOT, G_AND, G_NAND, G_OR, G_NOR, G_DFF, G_BUF, G_BAD };$/;"	e	enum:GATEFUNC
G_PO	typeemu.h	/^enum GATEFUNC {G_PI, G_PO, G_PPI, G_PPO, G_NOT, G_AND, G_NAND, G_OR, G_NOR, G_DFF, G_BUF, G_BAD };$/;"	e	enum:GATEFUNC
G_PPI	typeemu.h	/^enum GATEFUNC {G_PI, G_PO, G_PPI, G_PPO, G_NOT, G_AND, G_NAND, G_OR, G_NOR, G_DFF, G_BUF, G_BAD };$/;"	e	enum:GATEFUNC
G_PPO	typeemu.h	/^enum GATEFUNC {G_PI, G_PO, G_PPI, G_PPO, G_NOT, G_AND, G_NAND, G_OR, G_NOR, G_DFF, G_BUF, G_BAD };$/;"	e	enum:GATEFUNC
Gate	circuit.h	/^        GATE* Gate(unsigned index) { return Netlist[index]; }$/;"	f	class:CIRCUIT
GateStack	circuit.h	/^        ListofGate GateStack;$/;"	m	class:CIRCUIT
GenerateAllFaultList	atpg.cc	/^void CIRCUIT::GenerateAllFaultList()$/;"	f	class:CIRCUIT
GenerateAllTFaultList	stfsim.cc	/^void CIRCUIT::GenerateAllTFaultList()$/;"	f	class:CIRCUIT
GetCount	gate.h	/^        unsigned GetCount(unsigned i = 0) { return Count[i];}$/;"	f	class:GATE
GetEqvFaultNum	fault.h	/^        unsigned GetEqvFaultNum() { return EqvFaultNum; }$/;"	f	class:FAULT
GetEqvFaultNum	tfault.h	/^        unsigned GetEqvFaultNum() { return EqvFaultNum; }$/;"	f	class:TFAULT
GetFaultFlag	gate.h	/^        bool GetFaultFlag(unsigned idx) { return FaultFlag[idx]; }$/;"	f	class:GATE
GetFlag	gate.h	/^        bool GetFlag(FLAGS f) { return Flag[f]; }$/;"	f	class:GATE
GetFunction	gate.h	/^        GATEFUNC GetFunction(){ return Function;}$/;"	f	class:GATE
GetID	gate.h	/^        unsigned GetID(){ return ID;}$/;"	f	class:GATE
GetInputGate	fault.h	/^        GATE* GetInputGate() { return Input; }$/;"	f	class:FAULT
GetInputGate	tfault.h	/^        GATE* GetInputGate() { return Input; }$/;"	f	class:TFAULT
GetInput_list	gate.h	/^        vector<GATE*> &GetInput_list() { return Input_list; }$/;"	f	class:GATE
GetLevel	gate.h	/^        unsigned GetLevel() { return Level;}$/;"	f	class:GATE
GetLongOpt	GetLongOpt.cc	/^GetLongOpt::GetLongOpt(const char optmark)$/;"	f	class:GetLongOpt
GetLongOpt	GetLongOpt.h	/^class GetLongOpt$/;"	c
GetMaxLevel	circuit.h	/^        int GetMaxLevel(){ return MaxLevel;}$/;"	f	class:CIRCUIT
GetName	circuit.h	/^        string GetName(){ return Name;}$/;"	f	class:CIRCUIT
GetName	gate.h	/^        string GetName(){ return Name;}$/;"	f	class:GATE
GetOutputGate	fault.h	/^        GATE* GetOutputGate() { return Output; }$/;"	f	class:FAULT
GetOutputGate	tfault.h	/^        GATE* GetOutputGate() { return Output; }$/;"	f	class:TFAULT
GetStatus	fault.h	/^        FAULT_STATUS GetStatus() { return Status; }$/;"	f	class:FAULT
GetStatus	tfault.h	/^        FAULT_STATUS GetStatus() { return Status; }$/;"	f	class:TFAULT
GetTransition	gate.h	/^	char GetTransition(){$/;"	f	class:GATE
GetTransition_t	gate.h	/^	char GetTransition_t(){$/;"	f	class:GATE
GetValue	fault.h	/^        VALUE GetValue() { return Value; }$/;"	f	class:FAULT
GetValue	gate.h	/^        VALUE GetValue() { return Value;}$/;"	f	class:GATE
GetValue	tfault.h	/^        VALUE GetValue() { return Value; }$/;"	f	class:TFAULT
GetValue1	gate.h	/^        bitset<PatternNum> GetValue1() { return WireValue[0]; }$/;"	f	class:GATE
GetValue1	gate.h	/^        bool GetValue1(unsigned idx) { return WireValue[0][idx]; }$/;"	f	class:GATE
GetValue2	gate.h	/^        bitset<PatternNum> GetValue2() { return WireValue[1]; }$/;"	f	class:GATE
GetValue2	gate.h	/^        bool GetValue2(unsigned idx) { return WireValue[1][idx]; }$/;"	f	class:GATE
GetValue_t	gate.h	/^        VALUE GetValue_t() { return Value_t;}$/;"	f	class:GATE
GetWireValue	gate.h	/^        bitset<PatternNum> GetWireValue(unsigned i) { return WireValue[i]; }$/;"	f	class:GATE
GetWireValue	gate.h	/^        bool GetWireValue(unsigned i, unsigned idx) { return WireValue[i][idx]; }$/;"	f	class:GATE
HASH_H	hash.h	17;"	d
HEADERS	Makefile	/^HEADERS = gate.h fault.h circuit.h GetLongOpt.h typeemu.h readcircuit.tab.h ReadPattern.h hash.h tfault.h$/;"	m
Hash	hash.h	/^    Hash(int s = 509)$/;"	f	class:Hash
Hash	hash.h	/^class Hash$/;"	c
ID	gate.h	/^        unsigned ID;$/;"	m	class:GATE
ILLIGAL	typeemu.h	/^enum VALUE {S0, S1, X, D, B, ILLIGAL};$/;"	e	enum:VALUE
INCPATH	Makefile	/^INCPATH  =$/;"	m
IncCount	gate.h	/^        void IncCount(unsigned i = 0) {Count[i]++;}$/;"	f	class:GATE
IncEqvFaultNum	fault.h	/^        void IncEqvFaultNum() { ++EqvFaultNum; }$/;"	f	class:FAULT
IncEqvFaultNum	tfault.h	/^        void IncEqvFaultNum() { ++EqvFaultNum; }$/;"	f	class:TFAULT
InitPattern	circuit.h	/^        void InitPattern(const char *pattern) {$/;"	f	class:CIRCUIT
Initialization	tfatpg.cc	/^ATPG_STATUS CIRCUIT::Initialization(GATEPTR gptr, VALUE target, unsigned &total_backtrack_num)$/;"	f	class:CIRCUIT
Initialize	sim.cc	/^void PATTERN::Initialize(char* InFileName, int no_pi, string TAG)$/;"	f	class:PATTERN
InitializeQueue	sim.cc	/^void CIRCUIT::InitializeQueue()$/;"	f	class:CIRCUIT
InjectFaultValue	fsim.cc	/^void CIRCUIT::InjectFaultValue(GATEPTR gptr, unsigned idx,VALUE value)$/;"	f	class:CIRCUIT
Input	fault.h	/^        GATE* Input;$/;"	m	class:FAULT
Input	tfault.h	/^        GATE* Input;$/;"	m	class:TFAULT
Input_list	gate.h	/^        vector<GATE*> Input_list;$/;"	m	class:GATE
InverseValue	gate.h	/^        void InverseValue() {Value = NotTable[Value];}$/;"	f	class:GATE
InverseValue_t	gate.h	/^        void InverseValue_t() {Value_t = NotTable[Value_t];}$/;"	f	class:GATE
Inversion	gate.h	/^        bool Inversion;$/;"	m	class:GATE
Is_Branch	fault.h	/^        bool Is_Branch() { return Branch; }$/;"	f	class:FAULT
Is_Branch	tfault.h	/^        bool Is_Branch() { return Branch; }$/;"	f	class:TFAULT
Is_Inversion	gate.h	/^        bool Is_Inversion() { return Inversion;}$/;"	f	class:GATE
Is_Unique	gate.h	/^        bool Is_Unique(unsigned j)$/;"	f	class:GATE
LIBS	Makefile	/^LIBS     = -lreadline -lcurses$/;"	m
LINK	Makefile	/^LINK     = g++$/;"	m
Level	gate.h	/^        unsigned Level;$/;"	m	class:GATE
Levelize	circuit.cc	/^void CIRCUIT::Levelize()$/;"	f	class:CIRCUIT
ListofGate	circuit.h	/^        typedef list<GATE*> ListofGate;$/;"	t	class:CIRCUIT
ListofGateIte	circuit.h	/^        typedef list<GATE*>::iterator ListofGateIte;$/;"	t	class:CIRCUIT
LogicSim	sim.cc	/^void CIRCUIT::LogicSim()$/;"	f	class:CIRCUIT
LogicSimVectors	sim.cc	/^void CIRCUIT::LogicSimVectors()$/;"	f	class:CIRCUIT
LogicSim_t	stfsim.cc	/^void CIRCUIT::LogicSim_t()$/;"	f	class:CIRCUIT
MARKED	typeemu.h	/^enum FLAGS { ALL_ASSIGNED, MARKED, FAULT_INJECTED, FAULTY, SCHEDULED, OUTPUT, NumFlags };$/;"	e	enum:FLAGS
MandatoryValue	GetLongOpt.h	/^            NoValue, OptionalValue, MandatoryValue$/;"	e	enum:GetLongOpt::OptType
MarkOutputGate	fsim.cc	/^void CIRCUIT::MarkOutputGate()$/;"	f	class:CIRCUIT
MarkPropagateTree	atpg.cc	/^void CIRCUIT::MarkPropagateTree(GATEPTR gptr)$/;"	f	class:CIRCUIT
MaxLevel	circuit.h	/^        unsigned MaxLevel;$/;"	m	class:CIRCUIT
NCV	typeemu.h	/^const VALUE NCV[] = {X, X, X, X, X, S1, S1, S0, S0, X, X, X};$/;"	v
Name	circuit.h	/^        string Name;$/;"	m	class:CIRCUIT
Name	gate.h	/^        string Name;$/;"	m	class:GATE
Netlist	circuit.h	/^        vector<GATE*> Netlist;$/;"	m	class:CIRCUIT
NoValue	GetLongOpt.h	/^            NoValue, OptionalValue, MandatoryValue$/;"	e	enum:GetLongOpt::OptType
No_Fanin	gate.h	/^        unsigned No_Fanin() { return Input_list.size();}$/;"	f	class:GATE
No_Fanout	gate.h	/^        unsigned No_Fanout() { return Output_list.size();}$/;"	f	class:GATE
No_Gate	circuit.h	/^        unsigned No_Gate() { return Netlist.size(); }$/;"	f	class:CIRCUIT
No_PI	circuit.h	/^        unsigned No_PI() { return PIlist.size(); }$/;"	f	class:CIRCUIT
No_PO	circuit.h	/^        unsigned No_PO() { return POlist.size(); }$/;"	f	class:CIRCUIT
No_PPI	circuit.h	/^        unsigned No_PPI() { return PPIlist.size(); }$/;"	f	class:CIRCUIT
No_PPO	circuit.h	/^        unsigned No_PPO() { return PPOlist.size(); }$/;"	f	class:CIRCUIT
NotTable	typeemu.h	/^const VALUE NotTable[] = {S1, S0, X, B, D, ILLIGAL};$/;"	v
NumFlags	typeemu.h	/^enum FLAGS { ALL_ASSIGNED, MARKED, FAULT_INJECTED, FAULTY, SCHEDULED, OUTPUT, NumFlags };$/;"	e	enum:FLAGS
OBJECTS	Makefile	/^OBJECTS = readcircuit.tab.o lex.yy.o circuit.o main.o GetLongOpt.o atpg.o fsim.o sim.o psim.o stfsim.o tfatpg.o$/;"	m
OUTPUT	typeemu.h	/^enum FLAGS { ALL_ASSIGNED, MARKED, FAULT_INJECTED, FAULTY, SCHEDULED, OUTPUT, NumFlags };$/;"	e	enum:FLAGS
OptType	GetLongOpt.h	/^        enum OptType {$/;"	g	class:GetLongOpt
OptionalValue	GetLongOpt.h	/^            NoValue, OptionalValue, MandatoryValue$/;"	e	enum:GetLongOpt::OptType
OrTable	typeemu.h	/^const VALUE OrTable[5][5]  =  { { S0,  S1,  X,  D,  B },$/;"	v
Output	fault.h	/^        GATE* Output; \/\/record output gate for branch fault$/;"	m	class:FAULT
Output	tfault.h	/^        GATE* Output; \/\/record output gate for branch fault$/;"	m	class:TFAULT
Output_list	gate.h	/^        vector<GATE*> Output_list;$/;"	m	class:GATE
PATTERN	ReadPattern.h	/^        PATTERN(): no_pi_infile(0){}$/;"	f	class:PATTERN
PATTERN	ReadPattern.h	/^class PATTERN$/;"	c
PIGate	circuit.h	/^        GATE* PIGate(unsigned index) { return PIlist[index]; }$/;"	f	class:CIRCUIT
PIlist	circuit.h	/^        vector<GATE*> PIlist; \/\/store the gate indexes of PI$/;"	m	class:CIRCUIT
POGate	circuit.h	/^        GATE* POGate(unsigned index) { return POlist[index]; }$/;"	f	class:CIRCUIT
POlist	circuit.h	/^        vector<GATE*> POlist;$/;"	m	class:CIRCUIT
PPIGate	circuit.h	/^        GATE* PPIGate(unsigned index) { return PPIlist[index]; }$/;"	f	class:CIRCUIT
PPIlist	circuit.h	/^        vector<GATE*> PPIlist;$/;"	m	class:CIRCUIT
PPOGate	circuit.h	/^        GATE* PPOGate(unsigned index) { return PPOlist[index]; }$/;"	f	class:CIRCUIT
PPOlist	circuit.h	/^        vector<GATE*> PPOlist;$/;"	m	class:CIRCUIT
ParallelEvaluate	psim.cc	/^void CIRCUIT::ParallelEvaluate(GATEPTR gptr)$/;"	f	class:CIRCUIT
ParallelInv	gate.h	/^        void ParallelInv() {$/;"	f	class:GATE
ParallelLogicSim	psim.cc	/^void CIRCUIT::ParallelLogicSim()$/;"	f	class:CIRCUIT
ParallelLogicSimVectors	psim.cc	/^void CIRCUIT::ParallelLogicSimVectors()$/;"	f	class:CIRCUIT
Pattern	circuit.h	/^        PATTERN Pattern;$/;"	m	class:CIRCUIT
PatternNum	typeemu.h	/^const unsigned PatternNum = 16;$/;"	v
Podem	atpg.cc	/^ATPG_STATUS CIRCUIT::Podem(FAULT* fptr, unsigned &total_backtrack_num)$/;"	f	class:CIRCUIT
Pred	hash.h	/^class Pred$/;"	c
PrintIO	sim.cc	/^void CIRCUIT::PrintIO()$/;"	f	class:CIRCUIT
PrintIO_t	stfsim.cc	/^void CIRCUIT::PrintIO_t()$/;"	f	class:CIRCUIT
PrintParallelIOs	psim.cc	/^void CIRCUIT::PrintParallelIOs(unsigned idx)$/;"	f	class:CIRCUIT
PrintTransition	stfsim.cc	/^void CIRCUIT::PrintTransition()$/;"	f	class:CIRCUIT
PrintTransition_t	stfsim.cc	/^void CIRCUIT::PrintTransition_t()$/;"	f	class:CIRCUIT
PropagateTree	circuit.h	/^        ListofGate PropagateTree;$/;"	m	class:CIRCUIT
Queue	circuit.h	/^        ListofGate* Queue;$/;"	m	class:CIRCUIT
QueueIte	circuit.h	/^        ListofGateIte QueueIte;$/;"	m	class:CIRCUIT
READPATTERN_H	ReadPattern.h	2;"	d
REDUNDANT	typeemu.h	/^enum FAULT_STATUS { UNKNOWN, DETECTED, REDUNDANT, ABORT };$/;"	e	enum:FAULT_STATUS
ReadNextPattern	psim.cc	/^void PATTERN::ReadNextPattern(unsigned idx)$/;"	f	class:PATTERN
ReadNextPattern	sim.cc	/^void PATTERN::ReadNextPattern()$/;"	f	class:PATTERN
ReadNextPattern_t	stfsim.cc	/^void PATTERN::ReadNextPattern_t()$/;"	f	class:PATTERN
ResetAllCount	gate.h	/^        void ResetAllCount() {Count[0] = 0;Count[1] = 0;}$/;"	f	class:GATE
ResetCount	gate.h	/^        void ResetCount(unsigned i = 0) {Count[i] = 0;}$/;"	f	class:GATE
ResetFaultFlag	gate.h	/^        void ResetFaultFlag() { FaultFlag.reset(); }$/;"	f	class:GATE
ResetFlag	gate.h	/^        void ResetFlag() { Flag.reset(); }$/;"	f	class:GATE
ResetFlag	gate.h	/^        void ResetFlag(FLAGS f) { Flag.reset(f); }$/;"	f	class:GATE
ResetValue1	gate.h	/^        void ResetValue1() { WireValue[0].reset(); }$/;"	f	class:GATE
ResetValue1	gate.h	/^        void ResetValue1(unsigned idx) { WireValue[0].reset(idx); }$/;"	f	class:GATE
ResetValue2	gate.h	/^        void ResetValue2() { WireValue[1].reset(); }$/;"	f	class:GATE
ResetValue2	gate.h	/^        void ResetValue2(unsigned idx) { WireValue[1].reset(idx); }$/;"	f	class:GATE
ResetWireValue	gate.h	/^        void ResetWireValue(unsigned i) { WireValue[i].reset(); }$/;"	f	class:GATE
ResetWireValue	gate.h	/^        void ResetWireValue(unsigned i, unsigned idx) { WireValue[i].reset(idx); }$/;"	f	class:GATE
S0	typeemu.h	/^enum VALUE {S0, S1, X, D, B, ILLIGAL};$/;"	e	enum:VALUE
S1	typeemu.h	/^enum VALUE {S0, S1, X, D, B, ILLIGAL};$/;"	e	enum:VALUE
SCHEDULED	typeemu.h	/^enum FLAGS { ALL_ASSIGNED, MARKED, FAULT_INJECTED, FAULTY, SCHEDULED, OUTPUT, NumFlags };$/;"	e	enum:FLAGS
SOURCES	Makefile	/^SOURCES = readcircuit.tab.cc lex.yy.cc circuit.cc main.cc GetLongOpt.cc atpg.cc fsim.cc sim.cc psim.cc stfsim.cc tfatpg.cc$/;"	m
Schedule	circuit.h	/^        void Schedule(GATE* gptr)$/;"	f	class:CIRCUIT
ScheduleAllPIs	psim.cc	/^void CIRCUIT::ScheduleAllPIs()$/;"	f	class:CIRCUIT
ScheduleFanout	sim.cc	/^void CIRCUIT::ScheduleFanout(GATE* gptr)$/;"	f	class:CIRCUIT
SchedulePI	sim.cc	/^void CIRCUIT::SchedulePI()$/;"	f	class:CIRCUIT
SchedulePPI	sim.cc	/^void CIRCUIT::SchedulePPI()$/;"	f	class:CIRCUIT
SetBackTrackLimit	circuit.h	/^        void SetBackTrackLimit(unsigned bt) { BackTrackLimit = bt; }$/;"	f	class:CIRCUIT
SetBranch	fault.h	/^        void SetBranch(bool b) { Branch = b; }$/;"	f	class:FAULT
SetBranch	tfault.h	/^        void SetBranch(bool b) { Branch = b; }$/;"	f	class:TFAULT
SetEqvFaultNum	fault.h	/^        void SetEqvFaultNum(unsigned n) { EqvFaultNum = n; }$/;"	f	class:FAULT
SetEqvFaultNum	tfault.h	/^        void SetEqvFaultNum(unsigned n) { EqvFaultNum = n; }$/;"	f	class:TFAULT
SetFaultFlag	gate.h	/^        void SetFaultFlag(unsigned idx) { FaultFlag.set(idx); }$/;"	f	class:GATE
SetFaultFreeValue	gate.h	/^        void SetFaultFreeValue() {$/;"	f	class:GATE
SetFlag	gate.h	/^        void SetFlag(FLAGS f) { Flag.set(f); }$/;"	f	class:GATE
SetFunction	gate.h	/^        void SetFunction(GATEFUNC f){ Function = f;}$/;"	f	class:GATE
SetID	gate.h	/^        void SetID(unsigned id){ ID = id;}$/;"	f	class:GATE
SetInversion	gate.h	/^        void SetInversion(){Inversion = true;}$/;"	f	class:GATE
SetLevel	gate.h	/^        void SetLevel(unsigned l){ Level = l;}$/;"	f	class:GATE
SetMaxLevel	circuit.cc	/^void CIRCUIT::SetMaxLevel()$/;"	f	class:CIRCUIT
SetName	circuit.h	/^        void SetName(string n){ Name = n;}$/;"	f	class:CIRCUIT
SetName	gate.h	/^        void SetName(string n){ Name = n;}$/;"	f	class:GATE
SetPPIZero	sim.cc	/^void CIRCUIT::SetPPIZero()$/;"	f	class:CIRCUIT
SetStatus	fault.h	/^        void SetStatus(FAULT_STATUS status) { Status = status; }$/;"	f	class:FAULT
SetStatus	tfault.h	/^        void SetStatus(FAULT_STATUS status) { Status = status; }$/;"	f	class:TFAULT
SetUniqueImpliedValue	atpg.cc	/^ATPG_STATUS CIRCUIT::SetUniqueImpliedValue(FAULT* fptr)$/;"	f	class:CIRCUIT
SetValue	gate.h	/^        void SetValue(VALUE v) {Value = v;}$/;"	f	class:GATE
SetValue1	gate.h	/^        void SetValue1() { WireValue[0].set(); }$/;"	f	class:GATE
SetValue1	gate.h	/^        void SetValue1(bitset<PatternNum> &value) { WireValue[0] = value; }$/;"	f	class:GATE
SetValue1	gate.h	/^        void SetValue1(unsigned idx) { WireValue[0].set(idx); }$/;"	f	class:GATE
SetValue2	gate.h	/^        void SetValue2() { WireValue[1].set(); }$/;"	f	class:GATE
SetValue2	gate.h	/^        void SetValue2(bitset<PatternNum> &value) { WireValue[1] = value; }$/;"	f	class:GATE
SetValue2	gate.h	/^        void SetValue2(unsigned idx) { WireValue[1].set(idx); }$/;"	f	class:GATE
SetValue_t	gate.h	/^        void SetValue_t(VALUE v) {Value_t = v;}$/;"	f	class:GATE
SetWireValue	gate.h	/^        void SetWireValue(unsigned i) { WireValue[i].set(); }$/;"	f	class:GATE
SetWireValue	gate.h	/^        void SetWireValue(unsigned i, bitset<PatternNum> &value) { WireValue[i] = value; }$/;"	f	class:GATE
SetWireValue	gate.h	/^        void SetWireValue(unsigned i, unsigned idx) { WireValue[i].set(idx); }$/;"	f	class:GATE
SetupIO_ID	circuit.cc	/^void CIRCUIT::SetupIO_ID()$/;"	f	class:CIRCUIT
SetupOption	main.cc	/^int SetupOption(int argc, char ** argv)$/;"	f
SortFaninByLevel	atpg.cc	/^void CIRCUIT::SortFaninByLevel()$/;"	f	class:CIRCUIT
Status	fault.h	/^        FAULT_STATUS Status;$/;"	m	class:FAULT
Status	tfault.h	/^        FAULT_STATUS Status;$/;"	m	class:TFAULT
Str_hash_function	hash.h	/^class Str_hash_function$/;"	c
TARGET	Makefile	/^TARGET  = atpg$/;"	m
TFAULT	tfault.h	/^        TFAULT(GATE* gptr, GATE* ogptr, VALUE value): Value(value), Input(gptr),$/;"	f	class:TFAULT
TFAULT	tfault.h	/^class TFAULT$/;"	c
TFAULT_H	tfault.h	2;"	d
TFAtpg	tfatpg.cc	/^void CIRCUIT::TFAtpg()$/;"	f	class:CIRCUIT
TFaultSim	stfsim.cc	/^void CIRCUIT::TFaultSim()$/;"	f	class:CIRCUIT
TFaultSimVectors	stfsim.cc	/^void CIRCUIT::TFaultSimVectors()$/;"	f	class:CIRCUIT
TFaultSim_t	stfsim.cc	/^void CIRCUIT::TFaultSim_t()$/;"	f	class:CIRCUIT
TFlist	circuit.h	/^        list<TFAULT*> TFlist; \/\/collapsing fault list$/;"	m	class:CIRCUIT
TRUE	typeemu.h	/^enum ATPG_STATUS { TRUE, CONFLICT, FALSE };$/;"	e	enum:ATPG_STATUS
TestPossible	atpg.cc	/^GATEPTR CIRCUIT::TestPossible(FAULT* fptr)$/;"	f	class:CIRCUIT
TraceDetectedStemFault	atpg.cc	/^void CIRCUIT::TraceDetectedStemFault(GATEPTR gptr, VALUE val)$/;"	f	class:CIRCUIT
TraceUnknownPath	atpg.cc	/^bool CIRCUIT::TraceUnknownPath(GATEPTR gptr)$/;"	f	class:CIRCUIT
UFlist	circuit.h	/^        list<FAULT*> UFlist; \/\/undetected fault list$/;"	m	class:CIRCUIT
UNKNOWN	typeemu.h	/^enum FAULT_STATUS { UNKNOWN, DETECTED, REDUNDANT, ABORT };$/;"	e	enum:FAULT_STATUS
UTFlist	circuit.h	/^        list<TFAULT*> UTFlist; \/\/undetected fault list$/;"	m	class:CIRCUIT
UnSetInversion	gate.h	/^        void UnSetInversion(){Inversion = false;}$/;"	f	class:GATE
VALUE	typeemu.h	/^enum VALUE {S0, S1, X, D, B, ILLIGAL};$/;"	g
Value	fault.h	/^        VALUE Value;$/;"	m	class:FAULT
Value	gate.h	/^        VALUE Value;$/;"	m	class:GATE
Value	tfault.h	/^        VALUE Value;$/;"	m	class:TFAULT
Value_t	gate.h	/^        VALUE Value_t;$/;"	m	class:GATE
WireValue	gate.h	/^        bitset<PatternNum> WireValue[2]; \/\/one pair of WireValues (length defined by PatternNum).$/;"	m	class:GATE
X	typeemu.h	/^enum VALUE {S0, S1, X, D, B, ILLIGAL};$/;"	e	enum:VALUE
XorTable	typeemu.h	/^const VALUE XorTable[5][5] =  { { S0,  S1,  X,  D,  B },$/;"	v
_GetLongOpt_h_	GetLongOpt.h	5;"	d
_size	hash.h	/^    int _size;$/;"	m	class:Cache
_size	hash.h	/^    int _size;$/;"	m	class:Hash
basename	GetLongOpt.cc	/^GetLongOpt::basename(char * const pname) const$/;"	f	class:GetLongOpt
bucket	hash.h	/^    vector<list<pair<KEY, VALUE> > > bucket;$/;"	m	class:Hash
bucket	hash.h	/^    vector<pair<KEY, VALUE> > bucket;$/;"	m	class:Cache
bucket_num	hash.h	/^Hash<KEY, VALUE, HASH_FUNCTION>::bucket_num(KEY k)$/;"	f	class:Hash
circuit	readcircuit.y	/^circuit : $/;"	l
clean	hash.h	/^    void clean() { bucket.erase(bucket.begin(), bucket.end()); }$/;"	f	class:Cache
clean	hash.h	/^Hash<KEY, VALUE, HASH_FUNCTION>::clean()$/;"	f	class:Hash
description	GetLongOpt.h	/^            const char *description;   \/\/ a description of option$/;"	m	struct:GetLongOpt::Cell
enroll	GetLongOpt.cc	/^GetLongOpt::enroll(const char * const opt, const OptType t,$/;"	f	class:GetLongOpt
enroll_done	GetLongOpt.h	/^        int enroll_done;         \/\/ finished enrolling$/;"	m	class:GetLongOpt
eof	ReadPattern.h	/^        bool eof()$/;"	f	class:PATTERN
fanin_list	readcircuit.y	/^fanin_list: $/;"	l
ff_definition	readcircuit.y	/^ff_definition: output EQUAL GDFF LPAR NAMESTRING RPAR EOLINE{$/;"	l
for_each_exec	hash.h	/^Hash<KEY, VALUE, HASH_FUNCTION>::for_each_exec(Exec<VALUE> *e)$/;"	f	class:Hash
for_each_if_else	hash.h	/^    Hash<KEY, VALUE, HASH_FUNCTION>::for_each_if_else$/;"	f	class:Hash
forced_insert	hash.h	/^    void Hash<KEY, VALUE, HASH_FUNCTION>::forced_insert$/;"	f	class:Hash
gate_definition	readcircuit.y	/^gate_definition: output EQUAL gatename LPAR{$/;"	l
gatename	readcircuit.y	/^gatename: GNOT{$$=G_NOT;}$/;"	l
get_value	hash.h	/^Hash<KEY, VALUE, HASH_FUNCTION>::get_value(KEY k)$/;"	f	class:Hash
get_value	hash.h	/^Hash<KEY, VALUE, HASH_FUNCTION>::get_value(KEY k, int b)$/;"	f	class:Hash
inlist	ReadPattern.h	/^        vector<GATE*> inlist;$/;"	m	class:PATTERN
input_definition	readcircuit.y	/^input_definition: GINPUT LPAR NAMESTRING RPAR EOLINE{$/;"	l
insert	hash.h	/^Hash<KEY, VALUE, HASH_FUNCTION>::insert(const KEY k, const VALUE v)$/;"	f	class:Hash
is_member	hash.h	/^Hash<KEY, VALUE, HASH_FUNCTION>::is_member(KEY k)$/;"	f	class:Hash
last	GetLongOpt.h	/^        Cell *last;           \/\/ last entry in option table$/;"	m	class:GetLongOpt
main	main.cc	/^int main(int argc, char ** argv)$/;"	f
netlist	readcircuit.y	/^netlist: circuit{$/;"	l
next	GetLongOpt.h	/^            Cell *next;    \/\/ pointer to the next cell$/;"	m	struct:GetLongOpt::Cell
no_pi_infile	ReadPattern.h	/^        int no_pi_infile;$/;"	m	class:PATTERN
nodes	hash.h	/^    unsigned nodes() { return num_of_nodes; }$/;"	f	class:Hash
num_of_nodes	hash.h	/^    unsigned num_of_nodes;$/;"	m	class:Hash
operator ()	atpg.cc	/^    bool operator()(const GATEPTR gptr1, const GATEPTR gptr2) const$/;"	f	struct:sort_by_level
operator ()	hash.h	/^	int operator() (const string id, const int size)$/;"	f	class:Str_hash_function
operator ()	hash.h	/^	virtual bool operator() (const VALUE v) const$/;"	f	class:Pred
operator []	hash.h	/^    VALUE operator[] (KEY k)$/;"	f	class:Cache
operator []	hash.h	/^    VALUE& operator[] (int b) { return (bucket[b].second); }$/;"	f	class:Cache
operator []	hash.h	/^    list<pair<KEY, VALUE> >& operator[] (int b) { return bucket[b]; }$/;"	f	class:Hash
operator []	hash.h	/^Hash<KEY, VALUE, HASH_FUNCTION>::operator[] (KEY k)$/;"	f	class:Hash
option	GetLongOpt.h	/^            const char *option;  \/\/ option name$/;"	m	struct:GetLongOpt::Cell
option	main.cc	/^GetLongOpt option;$/;"	v
optmarker	GetLongOpt.h	/^        char optmarker;       \/\/ option marker$/;"	m	class:GetLongOpt
output	readcircuit.y	/^output: NAMESTRING $/;"	l
output_definition	readcircuit.y	/^output_definition: GOUTPUT LPAR NAMESTRING RPAR EOLINE{$/;"	l
parse	GetLongOpt.cc	/^GetLongOpt::parse(char * const str, char * const p)$/;"	f	class:GetLongOpt
parse	GetLongOpt.cc	/^GetLongOpt::parse(int argc, char * const *argv)$/;"	f	class:GetLongOpt
patterninput	ReadPattern.h	/^        ifstream patterninput;$/;"	m	class:PATTERN
pname	GetLongOpt.h	/^        char *pname;          \/\/ program basename$/;"	m	class:GetLongOpt
pop_value	hash.h	/^Hash<KEY, VALUE, HASH_FUNCTION>::pop_value(KEY k)$/;"	f	class:Hash
read	hash.h	/^    VALUE read(KEY k)$/;"	f	class:Cache
remove	hash.h	/^Hash<KEY, VALUE, HASH_FUNCTION>::remove(KEY k)$/;"	f	class:Hash
remove_if	hash.h	/^Hash<KEY, VALUE, HASH_FUNCTION>::remove_if(Pred<VALUE> *pred)$/;"	f	class:Hash
remove_if_else	hash.h	/^    Hash<KEY, VALUE, HASH_FUNCTION>::remove_if_else$/;"	f	class:Hash
retrieve	GetLongOpt.cc	/^GetLongOpt::retrieve(const char * const opt) const$/;"	f	class:GetLongOpt
setcell	GetLongOpt.cc	/^GetLongOpt::setcell(Cell *c, char *valtoken, char *nexttoken, char *name)$/;"	f	class:GetLongOpt
size	hash.h	/^    int size() { return _size; }$/;"	f	class:Cache
size	hash.h	/^    int size() { return _size; }$/;"	f	class:Hash
sort_by_level	atpg.cc	/^struct sort_by_level$/;"	s	file:
table	GetLongOpt.h	/^        Cell *table;          \/\/ option table$/;"	m	class:GetLongOpt
test_insert	hash.h	/^Hash<KEY, VALUE, HASH_FUNCTION>::test_insert(KEY k)$/;"	f	class:Hash
type	GetLongOpt.h	/^            OptType type;     \/\/ option type$/;"	m	struct:GetLongOpt::Cell
usage	GetLongOpt.cc	/^GetLongOpt::usage(ostream &outfile) const$/;"	f	class:GetLongOpt
usage	GetLongOpt.h	/^        void usage(const char *str) { ustring = str; }$/;"	f	class:GetLongOpt
ustring	GetLongOpt.h	/^        const char *ustring;        \/\/ usage message$/;"	m	class:GetLongOpt
value	GetLongOpt.h	/^            const char *value;   \/\/ value of option (string)$/;"	m	struct:GetLongOpt::Cell
write	hash.h	/^    void write(const KEY k, const VALUE v)$/;"	f	class:Cache
~CIRCUIT	circuit.h	/^        ~CIRCUIT() {$/;"	f	class:CIRCUIT
~Cache	hash.h	/^    ~Cache() {}$/;"	f	class:Cache
~FAULT	fault.h	/^        ~FAULT() {}$/;"	f	class:FAULT
~GATE	gate.h	/^        ~GATE() {}$/;"	f	class:GATE
~GetLongOpt	GetLongOpt.cc	/^GetLongOpt::~GetLongOpt()$/;"	f	class:GetLongOpt
~Hash	hash.h	/^    ~Hash() { bucket.erase(bucket.begin(), bucket.end()); }$/;"	f	class:Hash
~TFAULT	tfault.h	/^        ~TFAULT() {}$/;"	f	class:TFAULT
