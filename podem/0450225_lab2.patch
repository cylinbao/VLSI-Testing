diff --git a/.gitignore b/.gitignore
index 1377554..09327dc 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1 +1,7 @@
+atpg
 *.swp
+*.o
+*.swo
+*.yy.cc
+readcircuit.*
+tags
diff --git a/input/c17.input b/input/c17.input
new file mode 100644
index 0000000..91cb070
--- /dev/null
+++ b/input/c17.input
@@ -0,0 +1,9 @@
+PI G1 PI G2 PI G3 PI G4 PI G5
+01110
+10101
+00101
+01000
+10001
+00011
+00111
+00000
diff --git a/input/c7552.input b/input/c7552.input
new file mode 100644
index 0000000..b5682fd
--- /dev/null
+++ b/input/c7552.input
@@ -0,0 +1,41 @@
+PI 1_0 PI 5_1 PI 9_2 PI 12_3 PI 15_4 PI 18_5 PI 23_6 PI 26_7 PI 29_8 PI 32_9 PI 35_10 PI 38_11 PI 41_12 PI 44_13 PI 47_14 PI 50_15 PI 53_16 PI 54_17 PI 55_18 PI 56_19 PI 57_20 PI 58_21 PI 59_22 PI 60_23 PI 61_24 PI 62_25 PI 63_26 PI 64_27 PI 65_28 PI 66_29 PI 69_30 PI 70_31 PI 73_32 PI 74_33 PI 75_34 PI 76_35 PI 77_36 PI 78_37 PI 79_38 PI 80_39 PI 81_40 PI 82_41 PI 83_42 PI 84_43 PI 85_44 PI 86_45 PI 87_46 PI 88_47 PI 89_48 PI 94_49 PI 97_50 PI 100_51 PI 103_52 PI 106_53 PI 109_54 PI 110_55 PI 111_56 PI 112_57 PI 113_58 PI 114_59 PI 115_60 PI 118_61 PI 121_62 PI 124_63 PI 127_64 PI 130_65 PI 133_66 PI 134_67 PI 135_68 PI 138_69 PI 141_70 PI 144_71 PI 147_72 PI 150_73 PI 151_74 PI 152_75 PI 153_76 PI 154_77 PI 155_78 PI 156_79 PI 157_80 PI 158_81 PI 159_82 PI 160_83 PI 161_84 PI 162_85 PI 163_86 PI 164_87 PI 165_88 PI 166_89 PI 167_90 PI 168_91 PI 169_92 PI 170_93 PI 171_94 PI 172_95 PI 173_96 PI 174_97 PI 175_98 PI 176_99 PI 177_100 PI 178_101 PI 179_102 PI 180_103 PI 181_104 PI 182_105 PI 183_106 PI 184_107 PI 185_108 PI 186_109 PI 187_110 PI 188_111 PI 189_112 PI 190_113 PI 191_114 PI 192_115 PI 193_116 PI 194_117 PI 195_118 PI 196_119 PI 197_120 PI 198_121 PI 199_122 PI 200_123 PI 201_124 PI 202_125 PI 203_126 PI 204_127 PI 205_128 PI 206_129 PI 207_130 PI 208_131 PI 209_132 PI 210_133 PI 211_134 PI 212_135 PI 213_136 PI 214_137 PI 215_138 PI 216_139 PI 217_140 PI 218_141 PI 219_142 PI 220_143 PI 221_144 PI 222_145 PI 223_146 PI 224_147 PI 225_148 PI 226_149 PI 227_150 PI 228_151 PI 229_152 PI 230_153 PI 231_154 PI 232_155 PI 233_156 PI 234_157 PI 235_158 PI 236_159 PI 237_160 PI 238_161 PI 239_162 PI 240_163 PI IN_339_164 PI 1197_165 PI 1455_166 PI 1459_167 PI 1462_168 PI 1469_169 PI 1480_170 PI 1486_171 PI 1492_172 PI 1496_173 PI 2204_174 PI 2208_175 PI 2211_176 PI 2218_177 PI 2224_178 PI 2230_179 PI 2236_180 PI 2239_181 PI 2247_182 PI 2253_183 PI 2256_184 PI 3698_185 PI 3701_186 PI 3705_187 PI 3711_188 PI 3717_189 PI 3723_190 PI 3729_191 PI 3737_192 PI 3743_193 PI 3749_194 PI 4393_195 PI 4394_196 PI 4400_197 PI 4405_198 PI 4410_199 PI 4415_200 PI 4420_201 PI 4427_202 PI 4432_203 PI 4437_204 PI 4526_205 PI 4528_206 
+0 0 0 0 0 1 1 0 1 1 1 0 1 1 0 1 1 0 0 0 1 1 0 1 1 1 1 0 0 0 1 0 1 1 0 0 1 1 0 0 0 1 0 1 0 0 0 1 1 1 0 0 1 1 0 1 1 1 1 0 0 0 1 1 0 1 1 0 1 0 0 1 0 0 0 1 1 0 1 0 1 1 1 1 1 1 1 0 0 0 1 0 1 0 1 1 0 1 0 0 0 0 1 0 0 1 0 1 0 1 0 0 0 1 1 1 1 0 1 1 1 1 0 1 0 1 0 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 0 1 0 1 0 0 0 1 1 0 1 0 0 1 0 1 0 1 0 1 1 0 0 1 0 1 0 0 0 0 1 1 1 0 0 0 1 1 1 0 1 0 1 1 0 1 1 1 1 0 0 0 0 0 0 1 0 0 0 0 1 1 0 0 0 
+1 0 0 1 1 0 1 1 1 1 0 0 0 0 0 1 0 0 0 1 0 1 0 1 1 0 1 0 0 0 0 1 1 0 1 1 0 1 0 0 1 0 0 1 1 0 0 0 1 1 1 1 1 1 1 1 0 1 0 0 0 0 1 0 1 0 1 1 1 0 0 1 0 0 0 0 0 1 0 1 0 1 0 0 0 0 1 1 1 0 0 1 1 0 1 0 0 1 0 0 1 0 1 0 0 0 0 0 1 1 1 1 1 0 0 1 0 1 1 0 0 1 0 0 0 1 1 1 1 1 0 1 0 0 0 1 0 1 1 0 0 1 0 0 0 0 1 1 0 0 1 1 0 0 0 1 1 0 0 0 1 1 1 1 1 0 1 0 1 0 0 0 1 0 1 1 0 0 1 1 1 0 0 1 0 0 0 1 0 0 1 0 1 0 0 0 1 0 0 0 1 0 1 0 0 1 1 
+1 1 0 1 1 1 0 1 0 1 1 0 1 0 0 1 0 1 0 0 1 0 0 0 1 1 1 0 1 0 0 1 0 0 1 0 0 0 1 1 1 0 1 1 0 1 0 0 1 1 1 0 0 1 0 0 1 1 0 0 0 1 1 1 1 0 0 1 0 0 1 1 0 0 0 0 1 0 0 1 0 1 1 1 1 1 1 1 1 0 0 1 1 0 1 0 0 0 0 0 0 1 0 1 1 1 0 0 0 0 1 1 0 1 1 0 0 1 0 0 0 0 1 0 1 0 1 1 0 0 1 1 0 1 1 0 0 0 1 1 1 1 1 1 1 0 1 1 1 1 0 1 1 1 0 1 0 0 0 0 1 1 0 0 1 1 1 1 1 0 1 0 1 0 0 0 0 1 1 0 1 0 0 1 1 1 0 0 1 0 1 1 1 0 0 1 0 0 0 0 0 1 0 1 1 1 1 
+1 1 0 0 1 1 1 1 1 1 0 1 0 0 1 0 1 0 1 0 1 1 1 0 1 1 0 0 1 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 1 1 0 0 0 0 0 0 1 1 0 0 0 0 0 1 0 1 0 1 1 1 0 1 1 1 0 1 0 1 0 1 0 1 1 1 0 0 1 0 1 0 0 1 0 1 0 1 0 1 1 1 1 0 0 0 1 1 1 0 1 0 0 0 0 0 0 1 0 0 1 0 0 1 0 1 0 1 1 1 0 0 1 0 1 1 1 1 0 1 0 1 0 1 0 0 1 0 0 1 1 0 0 0 1 0 1 0 1 0 1 0 0 0 0 1 0 1 1 1 1 0 1 1 0 0 0 0 0 1 0 1 1 1 0 0 0 0 1 1 1 0 0 0 1 0 0 0 0 0 1 1 1 0 1 0 0 1 1 1 0 0 
+1 1 0 1 0 1 1 1 0 1 0 1 1 1 0 0 1 1 0 0 1 0 0 1 1 1 0 0 0 0 1 1 1 0 0 0 1 1 1 1 1 1 0 1 1 0 0 0 1 0 0 0 1 0 0 1 0 0 0 1 0 1 1 1 1 1 1 0 0 1 0 0 1 0 0 1 1 1 1 0 1 1 1 0 0 0 1 1 0 1 1 1 1 1 0 1 1 0 0 0 1 0 1 0 0 1 1 0 0 1 0 1 1 0 1 1 0 0 0 0 0 1 0 1 0 0 1 0 1 1 1 1 0 1 0 1 0 0 1 1 1 0 0 0 0 0 0 1 1 1 1 1 0 1 1 1 0 1 1 0 0 0 1 0 1 0 1 0 1 1 0 1 0 1 0 0 0 1 0 0 0 0 0 1 1 0 1 1 0 0 1 1 0 0 1 1 1 0 0 0 0 1 1 0 0 1 1 
+1 0 1 1 0 1 1 1 1 0 1 1 1 1 0 1 1 1 0 0 1 1 0 0 1 1 0 0 1 1 1 0 1 0 0 1 1 1 1 1 1 0 1 1 1 1 0 1 1 0 0 0 0 1 1 0 1 1 0 0 0 1 0 1 1 0 1 0 1 0 0 0 0 1 0 1 1 1 1 1 1 0 1 1 0 0 0 1 1 1 1 1 1 0 1 1 1 1 0 1 0 0 0 1 1 0 0 1 0 1 1 1 0 1 1 0 1 1 1 0 0 1 1 1 0 1 0 1 0 1 1 1 1 0 1 1 0 0 0 0 1 0 1 1 0 1 0 0 0 1 1 1 1 0 0 1 0 0 1 0 0 0 1 0 1 1 0 0 0 0 1 1 0 1 0 0 0 0 1 1 0 1 1 0 0 0 0 1 0 0 0 1 1 0 0 1 1 0 0 0 1 0 1 0 0 1 0 
+1 1 1 0 1 1 1 0 0 1 0 1 0 0 0 0 1 0 1 1 0 1 0 1 0 1 0 1 1 1 1 0 1 1 1 1 0 1 1 0 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 1 1 0 0 1 1 0 1 1 1 0 0 0 1 0 0 0 1 0 0 1 0 1 0 1 0 0 1 1 0 0 0 1 1 1 1 1 1 0 1 0 1 0 0 1 1 0 0 0 1 0 0 1 1 1 0 0 1 1 0 1 0 1 0 0 0 0 1 0 1 1 1 0 0 1 1 1 1 1 0 1 0 1 0 1 1 0 0 0 1 1 0 0 1 1 1 1 0 1 1 1 1 0 1 0 0 1 1 1 0 1 1 1 0 0 1 1 1 0 0 0 1 1 1 0 1 1 1 1 0 0 0 1 0 0 1 1 0 1 1 0 1 0 0 1 1 0 0 0 1 1 1 
+0 1 1 0 1 0 0 1 0 1 1 0 0 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 0 0 1 0 1 1 1 1 1 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 1 1 1 0 1 1 0 0 1 1 1 1 0 1 0 0 0 1 0 1 1 0 0 0 0 1 0 0 0 1 1 0 0 1 1 0 0 1 1 0 1 0 0 1 0 0 1 1 0 1 1 1 1 1 1 0 0 0 1 1 0 0 1 0 1 0 1 1 0 0 0 1 0 1 0 0 0 1 0 0 1 0 1 0 1 1 1 0 0 0 1 0 1 1 0 1 0 0 0 0 0 1 0 0 1 0 1 1 0 1 0 1 0 0 1 1 0 1 0 1 1 0 0 1 1 1 1 0 1 0 1 0 1 1 1 0 1 0 1 1 0 1 1 0 1 0 0 0 1 0 0 
+1 0 0 0 0 0 1 0 1 1 1 1 1 0 0 0 1 1 0 0 0 1 1 1 1 1 1 0 0 0 0 0 1 1 0 1 1 1 1 1 1 1 1 0 1 0 0 0 1 0 1 0 0 1 1 0 0 0 0 1 0 0 0 0 0 1 0 1 1 0 0 0 1 0 0 1 1 1 1 1 1 0 0 1 1 0 0 0 1 0 0 1 1 1 1 1 0 1 0 1 1 0 0 0 1 0 0 1 0 0 0 1 0 1 0 0 1 1 0 0 0 1 1 0 1 1 0 0 1 1 1 1 0 1 0 0 0 0 0 1 0 0 0 0 1 1 0 1 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 0 0 1 1 1 1 1 1 0 0 0 1 0 1 1 0 0 1 1 0 1 0 1 0 1 0 1 1 0 0 0 1 1 1 0 1 1 1 0 0 0 0 1 1 
+1 0 0 0 0 1 0 0 0 1 1 0 1 1 1 1 1 0 0 1 0 0 0 0 1 0 0 0 0 0 1 0 1 0 1 0 0 1 1 1 0 0 0 0 1 1 0 0 1 0 1 0 1 1 0 1 1 0 0 1 1 0 1 1 0 1 1 0 1 1 1 0 0 1 1 0 0 0 1 1 0 0 0 0 1 1 1 1 1 0 1 1 1 0 0 0 1 1 0 1 1 1 1 1 1 1 1 0 1 0 0 1 0 1 1 0 1 1 1 1 1 1 1 0 1 0 1 0 0 0 0 1 0 0 0 1 1 0 1 1 1 0 0 1 1 1 0 1 0 0 0 0 1 1 1 0 0 0 0 1 0 0 0 0 1 0 0 1 0 0 1 1 1 1 0 0 0 1 0 1 0 1 0 1 0 0 0 0 1 0 0 1 1 1 0 1 1 0 0 1 0 1 0 0 0 0 0 
+1 1 0 1 0 1 0 1 1 1 0 0 0 1 0 1 1 0 0 1 1 1 0 1 0 1 0 1 0 1 1 1 0 0 1 0 1 1 0 0 0 1 0 0 0 1 1 0 1 0 0 1 0 0 1 1 0 1 0 1 1 0 0 0 0 0 1 1 0 0 1 1 1 0 0 0 1 1 1 1 0 0 0 1 0 1 1 1 1 1 0 0 0 0 0 0 1 0 1 1 0 0 0 0 1 0 0 0 0 0 1 0 0 1 1 1 0 0 0 0 1 0 0 0 0 0 1 1 0 0 0 1 0 1 0 1 1 0 1 0 0 1 1 0 0 0 1 1 1 0 0 0 0 0 0 0 1 0 1 0 1 0 1 0 1 1 1 1 1 1 1 1 0 0 0 1 0 1 0 0 0 1 0 1 0 1 0 1 1 0 1 1 0 1 0 1 0 0 0 0 1 0 1 0 0 0 1 
+1 1 0 1 1 0 0 1 0 0 1 0 0 0 1 0 0 0 0 1 0 0 0 0 1 1 0 0 1 1 1 0 0 0 0 0 1 1 1 1 0 1 1 1 1 0 0 0 1 1 0 0 1 0 1 1 0 0 0 1 0 0 1 1 0 0 1 1 0 1 1 1 1 0 1 1 1 0 1 0 0 1 0 1 0 0 0 1 1 1 1 0 0 0 0 1 0 1 0 0 0 1 1 0 1 1 1 0 1 0 0 0 0 1 0 1 1 0 0 1 1 1 1 1 1 1 1 1 0 0 0 1 0 1 1 1 1 0 1 0 1 0 1 1 0 0 0 0 1 0 0 0 0 1 1 0 1 1 0 0 1 0 0 0 1 1 1 1 1 1 1 1 1 1 0 1 0 1 1 1 0 1 0 1 0 1 0 1 0 1 0 0 1 0 1 1 0 1 0 0 1 1 1 1 0 1 1 
+1 1 0 0 0 1 0 1 0 0 0 1 1 1 0 1 0 1 1 0 0 1 1 0 0 0 1 0 1 0 0 1 1 0 1 1 1 1 0 0 1 1 1 0 1 1 1 1 0 1 0 0 0 0 1 0 1 0 0 0 1 1 1 1 0 1 1 1 0 0 0 1 0 1 0 1 1 1 1 0 1 0 1 1 1 0 1 1 0 1 1 0 1 0 1 1 0 1 0 1 1 0 1 0 1 0 1 1 0 1 0 1 1 1 1 1 1 1 0 1 0 0 1 0 0 1 1 1 0 1 1 1 0 0 1 1 1 1 0 0 1 0 1 1 0 1 1 1 0 0 0 0 0 0 0 0 1 1 1 1 0 1 0 1 0 1 1 0 1 1 0 0 1 1 1 1 1 1 1 0 0 1 0 0 1 0 0 0 1 1 1 1 0 0 0 1 0 1 1 1 1 1 1 1 0 0 0 
+1 0 0 1 0 0 0 0 0 1 0 0 0 1 0 0 0 1 0 1 1 0 0 0 0 0 1 1 0 1 0 1 1 1 1 1 0 0 0 1 0 0 0 1 0 1 0 1 1 0 1 0 1 1 1 1 0 1 1 0 0 0 0 0 0 0 1 0 0 0 1 1 1 0 1 0 0 1 1 0 0 0 1 1 0 0 0 1 1 1 0 1 0 0 0 1 0 0 1 0 1 1 1 0 1 0 1 0 0 1 1 0 1 1 1 1 0 1 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 1 1 0 1 0 1 1 1 1 1 0 0 1 1 0 1 0 0 1 0 0 0 0 1 0 0 0 0 1 0 1 1 0 1 0 0 0 0 1 1 0 0 1 1 0 0 1 0 1 1 0 0 0 0 0 1 1 0 1 0 1 0 1 1 1 1 1 1 1 0 0 0 1 1 
+0 0 1 1 1 1 0 0 1 0 0 1 0 0 0 0 1 0 1 1 1 0 0 1 1 1 0 1 1 1 0 1 1 0 1 0 1 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 1 0 0 1 0 0 1 1 0 0 0 1 1 1 1 0 1 1 1 1 0 1 0 0 1 0 1 1 1 1 0 0 0 0 1 0 1 1 1 1 0 0 0 0 1 0 0 0 1 0 0 1 1 1 0 0 1 1 0 1 0 0 0 0 0 1 0 0 0 0 1 0 1 0 0 1 0 0 1 1 0 1 0 0 1 1 0 1 1 0 1 1 0 0 1 0 0 1 0 1 0 0 1 1 1 0 1 1 1 1 1 0 1 0 1 1 0 0 1 0 1 1 1 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 1 1 0 0 1 0 0 0 0 1 1 0 1 0 0 1 
+0 1 0 0 1 0 1 1 1 1 1 1 1 1 0 0 1 0 1 1 1 0 1 1 0 1 0 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 1 1 0 1 0 1 1 1 1 1 0 1 1 0 1 0 1 1 0 0 0 0 0 0 1 0 0 0 0 1 0 0 1 0 1 0 1 1 1 0 0 1 0 0 0 1 1 0 1 0 1 0 1 0 0 0 0 1 1 1 0 0 0 0 0 1 0 0 1 0 1 0 0 1 1 0 1 0 0 0 0 0 1 1 0 1 1 0 1 0 1 1 1 1 0 0 1 0 1 1 0 1 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 0 1 1 1 0 1 1 0 1 0 1 1 0 0 1 1 1 1 1 0 1 1 1 0 0 0 0 0 1 0 1 
+0 0 0 0 0 0 1 1 1 1 0 1 0 1 1 0 1 0 0 0 0 0 1 0 0 1 1 0 1 1 1 0 0 1 1 0 0 1 1 1 1 0 0 1 1 0 0 1 1 0 0 0 1 0 1 0 1 0 1 0 1 1 0 1 1 0 1 1 1 0 0 0 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 1 0 1 0 1 0 1 0 0 1 1 0 0 1 1 1 1 0 0 0 0 1 0 0 1 1 0 1 0 0 0 0 0 1 1 0 1 0 0 0 0 0 1 1 0 1 0 1 0 1 0 1 1 0 0 0 0 1 1 0 0 0 1 0 1 1 1 0 1 1 0 1 1 1 0 0 0 1 0 1 0 1 1 0 1 1 1 0 1 1 0 0 1 0 1 1 0 0 1 1 1 0 1 1 1 0 1 0 1 1 1 0 1 0 0 1 1 
+0 1 1 0 0 0 1 0 1 1 0 0 0 1 0 0 0 1 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 1 1 1 1 1 1 0 1 0 1 0 0 1 1 1 0 0 0 0 0 0 0 1 1 1 0 0 1 1 1 0 0 0 0 1 1 0 0 1 1 0 0 0 0 0 0 1 0 0 0 1 1 0 1 1 0 0 0 1 0 0 0 1 1 1 1 1 1 0 0 0 0 0 1 1 0 1 0 1 1 1 1 1 0 1 1 0 0 0 1 1 0 0 1 1 1 0 1 1 1 0 1 1 0 1 1 0 0 1 1 0 0 1 0 0 1 1 1 0 0 1 1 0 1 0 0 1 0 0 0 0 0 1 1 0 0 1 0 0 0 0 1 0 1 1 1 1 1 0 0 1 1 0 1 1 1 0 1 1 0 1 0 1 0 0 0 0 1 1 
+1 0 0 1 1 0 0 1 0 0 0 0 0 0 1 1 0 1 0 1 1 1 1 0 0 0 0 1 0 1 1 1 1 0 1 0 0 1 1 0 1 1 0 1 0 0 0 1 0 1 0 0 1 0 0 0 0 0 1 1 1 1 1 0 0 1 1 0 1 0 1 1 0 1 0 1 0 0 1 1 0 1 1 1 0 0 1 0 0 0 0 0 1 1 0 0 0 1 1 1 0 1 1 0 0 0 1 1 0 0 0 0 0 0 0 1 0 1 0 1 1 0 1 0 0 0 1 0 1 1 0 0 0 0 1 1 0 0 0 0 1 1 1 0 1 0 1 1 0 0 1 0 1 1 0 1 0 1 0 0 1 1 0 0 1 0 1 0 0 1 1 0 0 1 1 1 0 1 1 1 1 0 1 1 0 1 1 0 0 0 1 0 0 0 0 1 0 1 1 1 1 1 1 1 0 1 1 
+1 0 0 0 1 0 1 0 0 1 0 0 1 1 0 1 0 1 1 1 0 1 0 0 1 1 1 0 1 0 0 0 0 1 1 1 1 0 0 0 0 0 1 0 1 0 1 1 0 0 0 1 1 0 0 1 0 1 1 1 1 0 0 1 0 1 0 1 1 1 1 0 1 0 1 0 1 1 1 0 0 1 1 0 0 1 0 1 1 0 1 0 0 0 1 1 1 0 0 0 0 1 1 1 1 1 1 1 0 0 1 0 1 1 0 0 1 1 1 1 1 0 0 0 1 0 0 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 0 1 1 1 0 1 1 1 0 0 0 1 1 1 0 0 1 0 0 1 0 0 0 1 1 0 1 0 0 1 0 0 1 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 0 1 1 1 0 1 1 1 0 0 1 0 0 0 
+0 1 1 1 0 1 1 0 0 1 0 1 0 1 1 1 0 1 0 1 0 0 0 1 0 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 1 0 0 1 0 0 0 0 0 1 1 0 1 1 0 1 1 1 1 0 1 1 0 0 1 1 0 1 0 0 1 0 0 1 1 1 1 0 0 0 1 1 1 0 0 1 1 1 1 1 1 1 0 0 1 0 0 1 1 1 0 0 0 0 1 1 1 1 1 0 1 0 0 1 1 0 0 1 1 1 1 0 1 0 0 1 0 1 0 0 1 1 0 0 1 1 1 1 1 0 1 0 1 1 0 1 1 0 0 0 0 1 0 1 0 0 0 0 0 1 0 1 0 1 1 0 1 0 0 0 0 1 0 1 1 0 0 0 1 1 1 1 1 0 1 0 0 0 0 0 1 1 0 1 1 1 0 0 1 1 0 1 1 0 1 
+1 1 1 0 0 0 0 0 0 1 1 0 0 1 0 1 1 1 0 1 0 0 1 1 1 1 1 1 0 1 1 1 0 0 1 0 1 1 1 0 1 0 1 0 1 1 1 0 1 0 1 1 1 0 1 0 1 0 0 1 1 0 0 0 0 0 0 1 0 0 0 1 1 1 0 0 0 1 1 0 1 1 1 0 1 0 0 1 1 1 0 1 0 0 1 1 0 0 1 1 1 0 0 1 0 0 1 1 1 1 0 1 0 0 0 0 0 0 0 1 1 1 1 1 1 1 0 0 1 0 1 1 1 1 0 0 0 0 0 0 1 0 0 1 1 1 0 0 0 0 0 0 0 1 0 0 1 1 0 0 0 1 1 0 0 0 0 0 1 1 1 1 0 0 0 1 1 1 1 0 1 0 1 1 0 1 1 0 1 1 0 1 0 1 1 0 1 1 1 0 0 0 1 0 1 1 0 
+0 1 1 1 0 1 1 0 0 0 0 0 1 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 0 1 1 0 0 0 1 1 1 1 1 0 1 0 0 1 0 0 0 1 1 0 1 0 0 1 1 0 1 0 1 1 1 1 1 1 0 0 0 1 0 1 0 0 1 1 0 1 0 1 1 1 1 1 0 0 1 0 0 1 1 0 0 0 0 0 1 1 1 0 0 0 1 0 1 1 1 0 0 1 0 1 1 1 0 1 1 1 0 1 0 0 1 1 1 0 1 1 1 0 1 0 1 1 0 0 1 1 0 1 0 1 0 1 0 0 1 0 1 1 1 1 0 1 1 1 0 0 0 1 0 1 0 0 1 0 0 1 1 0 1 0 1 1 0 1 0 1 1 1 0 0 1 0 0 1 1 0 1 0 1 0 1 0 0 1 1 1 0 0 0 0 
+0 0 0 1 1 0 0 0 0 1 0 0 0 0 1 1 1 1 0 1 0 0 1 1 1 1 0 0 0 0 1 0 1 1 0 1 0 1 0 0 1 1 1 0 0 0 0 1 0 1 0 1 0 0 1 0 1 0 0 1 1 0 0 0 1 0 1 1 1 0 0 0 0 1 0 1 0 1 0 1 1 0 1 0 1 1 1 1 0 0 0 0 0 1 0 1 1 1 0 0 1 1 0 0 1 1 0 1 0 1 1 0 1 1 0 1 0 1 1 1 1 1 1 0 0 0 0 1 0 0 1 0 0 1 0 0 0 0 0 1 1 1 0 1 0 1 1 1 1 1 0 0 0 1 0 1 0 1 1 1 1 1 1 1 1 0 1 0 0 1 1 1 1 1 0 0 0 1 0 1 0 0 0 1 1 1 1 1 1 1 0 1 0 1 0 0 1 1 0 0 1 1 1 0 1 1 1 
+0 0 1 0 0 0 1 0 0 0 0 1 0 1 1 1 1 1 0 1 0 1 0 0 1 0 0 1 0 1 1 0 0 0 1 1 1 1 1 0 1 0 1 1 0 0 0 1 0 0 1 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 1 0 1 1 0 1 1 0 0 1 0 0 1 0 0 0 0 1 0 1 0 0 0 1 1 1 1 1 1 0 1 1 0 1 0 0 1 0 1 1 0 1 0 0 0 1 1 1 0 1 1 0 1 1 0 0 1 0 1 0 1 0 0 0 0 1 1 0 0 1 0 1 0 1 1 0 1 0 1 0 1 0 1 0 0 1 0 0 0 1 0 0 0 0 0 1 1 1 0 0 0 1 0 1 0 0 1 0 1 1 1 1 0 0 0 0 1 0 1 1 1 0 1 0 1 0 1 1 1 1 1 1 1 0 0 0 0 1 
+0 1 1 1 0 0 0 1 1 0 1 1 0 1 1 1 1 1 1 1 0 0 1 0 0 1 1 0 1 0 0 1 0 0 0 1 0 1 1 0 1 1 0 1 0 1 1 1 0 0 1 1 1 1 1 1 0 1 0 1 0 0 1 1 0 0 0 1 1 1 0 1 0 0 1 0 0 0 0 1 0 1 0 1 1 1 1 0 1 1 1 0 0 1 1 0 1 0 0 1 1 0 1 0 0 0 0 1 0 0 1 1 1 1 1 0 1 0 1 0 0 0 1 0 0 0 0 0 1 1 0 1 0 0 1 1 0 1 1 1 0 1 0 0 1 1 0 0 1 1 0 1 0 0 0 1 0 0 0 1 0 1 1 0 1 1 1 1 0 1 0 0 0 1 1 1 1 1 0 0 1 0 0 1 1 1 0 1 1 0 0 0 0 1 0 1 1 0 1 1 0 1 0 0 1 1 1 
+0 1 1 1 1 1 1 0 1 0 0 1 1 1 1 1 0 0 1 0 0 1 0 0 0 0 0 0 1 0 1 0 0 1 1 1 1 0 0 1 0 0 0 1 0 1 1 1 0 0 0 0 1 1 0 1 1 1 0 0 0 1 1 0 1 0 0 1 0 1 1 0 0 0 1 1 1 1 0 1 0 0 1 1 1 1 0 1 1 1 1 0 1 0 1 1 1 1 1 1 0 1 1 0 0 0 1 0 0 0 1 1 0 0 0 0 0 1 1 1 1 1 0 0 1 0 1 1 0 1 1 0 0 1 0 1 1 0 1 0 1 1 0 0 0 0 1 0 1 1 0 0 1 1 0 1 1 1 1 0 0 1 0 1 1 1 0 0 0 1 1 1 1 0 0 1 0 0 1 1 1 1 1 1 1 1 0 0 0 0 0 1 0 0 1 1 0 1 0 1 0 1 1 0 1 0 1 
+0 1 1 0 1 1 0 0 0 1 0 0 0 0 0 1 1 1 0 1 1 1 0 1 0 1 0 1 1 0 1 0 1 1 1 1 1 0 1 0 1 1 0 1 0 1 1 1 0 1 1 0 1 1 1 0 0 0 1 0 1 1 0 1 0 1 0 0 1 0 1 0 0 0 1 1 1 0 0 0 0 0 0 1 0 1 1 0 0 1 0 0 1 1 0 1 0 1 1 1 1 0 0 1 1 0 0 0 1 0 0 0 1 0 1 1 1 0 0 1 0 0 1 1 0 1 1 1 1 0 1 0 0 0 1 0 0 0 1 1 0 0 0 1 1 1 0 1 1 0 1 0 0 0 1 0 0 1 0 1 1 0 1 1 1 0 1 1 1 0 0 1 0 1 1 0 0 1 1 1 0 0 0 1 0 0 1 0 0 1 0 1 1 1 0 0 1 1 0 1 0 0 1 1 0 1 0 
+1 0 0 0 0 0 1 0 1 0 1 0 1 0 0 1 0 0 1 1 0 0 1 0 0 1 0 1 1 1 0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 1 0 0 1 0 1 1 1 0 1 1 0 1 1 0 0 1 1 1 1 0 1 0 1 1 1 0 0 0 1 1 0 1 1 0 0 1 1 1 0 1 1 1 0 1 0 0 0 0 0 0 0 1 1 1 1 1 1 0 1 0 0 1 1 1 0 0 0 0 1 0 1 0 1 1 1 1 0 0 1 1 0 0 1 0 0 0 0 1 1 1 1 0 0 1 0 0 0 1 1 0 1 1 1 0 1 1 0 0 0 0 1 0 0 0 1 1 1 1 1 0 1 1 0 1 1 0 0 0 0 0 1 0 0 1 1 1 0 1 0 0 0 0 1 1 0 0 0 1 1 0 0 1 0 0 1 1 0 0 1 0 1 
+0 0 1 0 1 0 0 1 0 1 1 0 1 0 1 1 0 1 1 1 1 0 0 0 0 0 1 1 1 1 0 0 1 1 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 1 0 1 0 1 0 0 1 0 0 1 0 1 1 0 1 1 0 1 0 0 0 0 0 0 1 0 0 0 0 1 1 1 1 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0 1 0 1 1 0 0 1 0 1 0 0 0 0 0 1 0 1 0 0 1 0 0 0 1 0 1 1 0 0 0 0 0 1 1 1 0 0 0 0 1 1 1 0 1 1 0 1 0 1 0 1 1 0 0 0 0 1 0 1 1 0 1 1 1 0 1 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 1 1 0 1 0 1 1 1 0 1 1 1 1 0 1 0 1 0 0 0 
+1 0 0 0 1 0 0 1 0 0 0 1 1 1 0 0 0 1 0 1 1 1 0 1 1 0 1 0 1 0 0 1 0 0 1 1 0 0 1 1 0 1 1 1 1 0 1 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0 1 0 1 0 0 1 1 0 1 0 0 0 1 0 0 0 1 0 0 0 1 1 1 1 0 1 1 1 0 1 1 0 0 1 1 0 1 1 0 0 1 1 0 1 0 0 1 1 0 0 1 0 0 0 1 1 0 0 0 1 1 0 0 1 1 0 1 0 0 0 0 1 0 0 0 1 1 0 0 0 0 1 0 1 1 0 1 1 1 1 0 1 0 0 0 0 1 0 0 1 1 1 1 1 1 0 1 1 1 1 0 0 1 1 0 0 0 1 1 1 0 0 0 1 0 1 1 0 0 0 1 1 1 1 0 0 1 0 1 1 0 1 1 1 1 
+1 1 0 0 0 0 0 1 0 1 1 0 0 0 1 0 0 0 0 0 1 1 0 1 1 1 1 1 0 1 1 1 0 0 0 1 0 0 1 0 1 1 1 0 1 1 1 1 0 1 0 0 0 1 0 0 1 0 1 1 0 0 1 1 0 0 1 1 0 1 1 0 1 1 1 1 1 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 0 1 1 0 0 1 0 0 0 0 1 1 0 1 1 0 1 0 0 1 1 0 1 0 0 0 1 1 1 1 0 1 0 0 0 0 0 1 1 1 1 1 1 0 1 0 1 1 0 1 0 0 0 0 1 0 1 1 1 1 0 1 1 0 1 1 0 0 0 0 1 1 1 0 1 1 1 0 0 0 1 1 1 1 1 1 1 1 0 1 1 1 1 0 1 1 0 0 0 1 1 1 0 0 0 0 0 1 1 0 1 
+1 0 0 0 0 0 1 0 1 0 0 0 1 1 1 1 1 1 0 0 0 1 0 0 1 0 1 1 1 0 0 0 1 0 1 1 0 1 0 0 1 1 0 1 0 0 1 1 1 0 1 0 0 1 0 0 1 0 0 0 0 1 0 1 0 0 0 0 0 1 0 1 0 0 1 1 1 0 1 1 1 1 0 1 1 0 0 1 1 1 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 0 1 1 1 1 0 1 0 0 1 1 0 1 0 1 0 0 1 0 0 0 0 0 0 0 1 1 0 0 0 1 0 0 1 1 0 0 0 1 1 0 1 0 0 0 1 0 1 1 1 1 1 1 0 0 0 1 0 0 0 0 1 1 0 0 1 0 1 1 1 1 1 1 1 0 0 1 0 1 1 0 0 1 1 1 1 1 1 0 1 0 0 0 1 0 0 0 0 1 1 
+0 1 1 0 1 1 1 0 0 1 0 1 1 1 0 0 1 0 1 0 0 1 1 1 0 1 0 0 0 1 1 0 0 1 1 0 0 0 1 1 1 0 1 1 1 0 1 0 1 0 1 1 1 1 0 1 0 0 1 0 0 0 1 1 1 0 1 0 1 0 0 1 0 1 0 1 1 1 0 0 1 1 1 0 0 1 1 0 0 0 1 1 1 0 1 0 0 0 1 1 0 0 1 0 1 1 0 1 1 1 0 0 1 0 1 0 0 1 1 0 0 1 1 1 0 0 0 1 1 0 1 0 0 1 0 1 0 1 1 1 0 0 1 1 0 0 1 0 1 0 1 1 1 0 0 1 0 1 0 0 1 1 1 0 1 0 1 0 1 0 1 1 0 1 0 0 1 0 1 1 0 0 1 1 1 1 0 1 0 0 1 1 0 1 0 1 0 0 1 0 0 0 1 1 1 0 1 
+1 0 0 1 1 0 1 1 0 0 1 1 0 0 1 1 1 1 0 0 1 0 0 1 0 1 0 1 1 0 0 0 1 1 1 1 1 1 1 0 1 0 0 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 0 0 1 1 1 1 1 1 0 1 0 1 1 1 1 0 0 0 0 1 0 0 1 0 0 1 1 1 1 0 1 1 0 1 1 1 0 1 0 0 0 1 0 1 1 0 1 1 1 0 1 1 1 0 1 0 1 1 0 0 0 1 1 0 0 0 1 0 1 1 1 0 1 0 1 0 0 1 0 1 0 0 0 1 0 1 1 1 0 0 1 1 0 1 0 0 1 0 0 0 0 0 0 0 1 0 0 0 1 1 0 1 1 1 1 0 0 0 1 0 1 1 0 0 1 0 0 0 0 1 0 1 1 0 0 0 1 1 0 0 0 0 1 1 0 1 0 0 0 
+0 0 0 1 1 1 1 0 0 0 0 0 1 1 1 1 0 0 0 1 1 0 0 0 0 0 0 0 1 1 1 1 1 0 1 0 0 1 1 0 0 0 1 0 1 0 1 1 1 0 1 0 1 1 1 0 0 0 1 0 0 1 0 1 1 1 0 1 1 1 1 0 1 0 0 1 0 1 1 1 1 0 1 1 0 0 1 0 0 0 1 0 0 0 1 1 1 1 1 0 1 1 1 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 1 1 1 0 1 1 0 1 0 1 0 1 0 1 1 0 1 1 1 0 0 1 0 0 0 0 1 1 0 1 1 0 0 0 0 0 0 0 1 0 1 1 0 0 1 1 1 0 0 1 1 1 1 0 1 0 0 0 1 0 1 1 0 1 1 0 0 0 1 1 0 1 0 0 1 0 1 1 0 1 0 1 0 1 0 1 
+1 0 1 1 0 1 0 0 0 0 0 0 0 1 1 1 1 1 0 0 1 1 1 1 1 0 0 0 0 1 0 0 1 0 0 0 1 1 1 0 1 1 1 0 0 1 1 1 0 0 0 0 0 1 0 0 0 0 0 1 1 1 0 1 1 0 1 0 0 1 1 0 0 0 1 1 1 1 1 1 1 0 0 0 1 1 0 1 0 1 1 0 0 1 1 1 1 1 0 1 1 1 0 1 0 0 1 0 1 1 1 1 0 1 1 0 0 1 1 1 0 0 0 0 1 1 0 1 1 1 1 1 1 1 0 0 0 0 0 1 1 0 0 1 1 1 1 1 0 0 0 0 0 1 0 1 0 1 1 0 1 0 1 1 1 1 0 0 0 0 0 0 1 1 0 1 1 1 1 0 1 0 0 1 1 0 0 0 0 0 1 0 0 1 1 1 1 0 1 0 1 0 0 1 1 1 1 
+0 1 1 1 0 0 0 0 0 1 1 0 1 0 0 1 1 1 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 1 0 1 1 0 0 1 0 1 1 0 0 1 1 0 0 0 1 0 1 1 0 0 0 0 1 0 0 1 1 0 1 0 0 0 1 1 0 1 0 0 1 1 0 1 1 1 0 0 0 0 0 1 1 0 0 1 0 1 1 1 0 1 0 0 1 0 1 1 1 1 1 1 0 0 0 0 1 0 1 0 1 0 1 1 1 0 1 1 1 0 0 1 1 1 0 1 1 0 1 0 1 0 1 1 1 0 0 1 1 1 0 1 1 1 0 1 0 0 1 0 1 0 0 0 1 0 0 0 0 1 1 0 0 0 1 1 1 1 0 0 0 0 1 0 0 0 0 1 0 0 1 1 0 1 0 0 0 0 0 0 1 1 1 1 0 1 1 0 1 1 1 0 
+1 1 0 0 0 0 1 1 0 1 0 0 0 1 1 1 1 0 1 0 1 0 1 1 0 1 1 0 0 0 1 0 0 1 0 1 1 1 1 1 0 1 0 0 0 0 0 1 0 1 1 0 1 1 0 0 0 0 1 1 0 1 1 1 1 0 1 1 1 1 0 0 1 1 0 0 0 1 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 1 0 1 1 1 1 0 0 1 0 0 0 1 1 1 0 0 0 0 1 1 1 1 1 1 0 1 1 0 0 0 0 0 0 0 0 0 0 1 1 1 0 1 0 1 0 0 0 1 0 0 0 1 1 1 0 0 0 1 1 1 0 0 0 1 0 1 0 1 0 1 0 1 1 1 0 0 0 0 1 1 0 1 0 1 1 0 1 0 1 0 0 1 0 0 0 0 0 0 0 1 1 0 0 1 0 1 1 1 0 1 0 1 0 
+1 1 1 1 1 1 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 1 0 1 0 0 0 0 0 0 0 0 1 1 1 0 1 0 1 1 0 1 1 1 0 1 0 1 0 1 1 0 0 1 0 0 0 0 1 1 1 0 0 1 1 0 1 0 0 0 1 0 1 0 1 0 0 1 0 1 1 1 0 0 0 1 1 1 0 1 1 1 1 0 0 1 0 0 0 0 1 0 0 0 1 0 0 0 1 0 1 1 0 0 0 0 1 0 0 1 1 0 0 1 1 0 0 0 0 1 0 1 0 0 0 1 1 0 0 1 0 0 1 0 0 0 0 1 0 0 0 1 0 1 1 0 1 0 0 0 0 0 1 0 1 0 0 1 1 0 1 1 1 0 1 1 0 1 0 1 1 0 0 0 1 0 1 1 0 1 0 0 1 1 0 1 1 1 0 
diff --git a/output/c17.output b/output/c17.output
new file mode 100644
index 0000000..28e291b
--- /dev/null
+++ b/output/c17.output
@@ -0,0 +1,8 @@
+PI: 01110       PO: 00
+PI: 10101       PO: 11
+PI: 00101       PO: 01
+PI: 01000       PO: 11
+PI: 10001       PO: 01
+PI: 00011       PO: 01
+PI: 00111       PO: 00
+PI: 00000       PO: 00
diff --git a/output/c7552.output b/output/c7552.output
new file mode 100644
index 0000000..1fbb93c
--- /dev/null
+++ b/output/c7552.output
@@ -0,0 +1,40 @@
+PI: 000001101110110110001101111000101100110001010001110011011110001101101001000110101111111000101011010000100101010001111011110101000101111111110001010001101001010101100101000011100011101011011110000001000011000	PO: 000100011001110101101111000001000011010001111101010111001111101010100111111110000110111000000000000011110111
+PI: 100110111100000100010101101000011011010010011000111111110100001010111001000001010100001110011010010010100000111110010110010001111101000101100100001100110001100011111010100010110011100100010010100010001010011	PO: 111000010101110010001001010000001010001010111111101000110011001101000101100000000110110101111111111000110010
+PI: 110111010110100101001000111010010010001110110100111001001100011110010011000010010111111110011010000001011100001101100100001010110011011000111111101111011101000011001111101010000110100111001011100100000101111	PO: 111101010011010011100101110010000101101001111111101101110000010010000111000001100110010110011100111100011011
+PI: 110011111101001010101110110010010111111010011110000001100000101011101110101010111001010010101011110001110100000010010010101110010111101010100100110001010101000010111101100000101110000111000100000111010011100	PO: 111100000011000011100010000011010011101111111111101101101111111010011111111010101011111111111111101101000101
+PI: 110101110101110011001001110000111000111111011000100010010001011111100100100111101110001101111101100010100110010110110000010100101111010100111000000111110111011000101010110101000100000110110011001110000110011	PO: 111010101010000011011001100110000110011011111110111111110111111110011111111111100100111001000000011111011011
+PI: 101101111011110111001100110011101001111110111101100001101100010110101000010111111011000111111011110100011001011101101110011101010111101100001011010001111001001000101100001101000011011000010001100110001010010	PO: 111001101001101100001000110010001010010011111111010111100111101110001111101111101000111110001100100110100011
+PI: 111011100101000010110101010111101111011001101101101101111001101110001000100101010011000111111010100110001001110011010100001011100111110101011000110011110111101001110111001110001110111100010011011010011000111	PO: 011101110011011110001001101100011000100111111111101101100111100000001111100110111011111110100011011110101100
+PI: 011010010110000101111111110000101111101010000000001000101110110011110100010110000100011001100110100100110111111000110010101100010100010010101110001011010000010010110101001101011001111010101110101101101000100	PO: 000101101100111101010111010111101000100101010100101101000111100111000111101111100001111001100000011011101000
+PI: 100000101111100011000111111000001101111111101000101001100001000001011000100111111001100010011111010110001001000101001100011011001111010000010000110110111111111001000111111000101100110101010110001110111000011	PO: 011111000010011010101011000110111000011110111111010111101111110001000111100110011100011101001111001000101010
+PI: 100001000110111110010000100000101010011100001100101011011001101101101110011000110000111110111000110111111110100101101111111010100001000110111001110100001110000100001001001111000101010100001001110110010100000	PO: 111101111010101010000100111010010100010010111111111111111000000010001111011101011110010110101111000001100010
+PI: 110101011100010110011101010101110010110001000110100100110101100000110011100011110001011111000000101100001000001001110000100000110001010110100110001110000000101010101111111100010100010101011011010100001010001	PO: 111111100110001010101101101010001010011001111110111111111000011101100111001100000110010101011111010101101001
+PI: 110110010010001000010000110011100000111101111000110010110001001100110111101110100101000111100001010001101110100001011001111111110001011110101011000010000110110010001111111111010111010101010100101101001111011	PO: 111111111111101010101010010111001111001001111110101101100000001011010010010100100001010101010011010000101101
+PI: 110001010001110101100110001010011011110011101111010000101000111101110001010111101011101101101011010110101011010111111101001001110111001111001011011100000000111101010110110011111110010010001111000101111111000	PO: 011010011111001001000111100011111111011101111110111111111111111100001111111110111101011010111111110101011010
+PI: 100100000100010001011000001101011111000100010101101011110110000000100011101001100011000111010001001011101010011011110101000010000000011010111110011010010000100001011010000110011001011000001101010111111100011	PO: 111000110100101100000110101011111100010111111111111111100000000101011111001000110010110110001111000110001011
+PI: 001111001001000010111001110111011010100100010001000001001001100011110111101001011110000101111000010001001110011010000010000101001001101001101101100100101001110111110101100101110010000000001001100100001101001	PO: 000100101101000000000100110010001101001001111101000000001111101000100111111110100010111000010000110000001000
+PI: 010010111111110010111011010111010000000000000101000001101011111011010110000001000010010101110010001101010100001110000010010100110100000110110101111001011010000100000001000000110111011010110011111011100000101	PO: 000100000111101101011001111101100000100011111101101101001111111010011111101110010110111010011111000000111101
+PI: 000000111101011010000010011011100110011110011001100010101010110110111000011000010000000010101010100110011110000100110100000110100000110101010110000110001011101101110001010110111011001011001110111010111010011	PO: 000110110101100101100111011100111010010110111100111010000111100011000111111110101011011010111100100101110111
+PI: 011000101100010001100101001001010010011111110101001110000000111001110000110011000000100011011000100011111100000110101111101100011001110111011011001100100111001101001000001100100001011111001101110110101000011	PO: 100001100000101111100110111010101000010011111100111111000100101110010111011010100001111000000000101110011001
+PI: 100110010000001101011110000101111010011011010001010010000011111001101011010100110111001000001100011101100011000000010101101000101100001100001110101100101101010011001010011001110111101101100010000101111111011	PO: 111011001111110110110001000011111111000001111110101101111011000010001111101001111101010100011100111101000110
+PI: 100010100100110101110100111010000111100000101011000110010111100101011110101011100110010110100011100001111111001011001111100010011111011111111110111011100011100100100011010010011001001001010010001110111001000	PO: 011110010100100100101001000110111001000110111110101101100111100110101010101111001111011110110000000100010101
+PI: 011101100101011101010001001000101001001001100100000110110111101100110100100111100011100111111100100111000011111010011001111010010100110011111010110110000101000001010110100001011000111110100000110111001101101	PO: 000000001100011111010000011011001101111111111100111111001111100001110111100011010111111000010000110011011111
+PI: 111000000110010111010011111101110010111010101110101110101001100000010001110001101110100111010011001110010011110100000001111111001011110000001001110000000100110001100000111100011110101101101101011011100010110	PO: 011011100111010110110110101101100010111111111110111111101111100011011111100111111001011100000000110101000010
+PI: 011101100000100011000000000000111110110001111101001000110100110101111110001010011010111110010011000001110001011100101110111010011101110101100110101010010111101110001010010011010110101110010011010101001110000	PO: 100010011111010111001001101011001110010001111000111111001000001001001111011000111111010000101111000101110111
+PI: 000110000100001111010011110000101101010011100001010100101001100010111000010101011010111100000101110011001101011011010111111000010010010000011101011111000101011111111010011111000101000111111101010011001110111	PO: 100011111010100011111110101001001110100010101100101000001000010000100111011100110001010001110011000010110010
+PI: 001000100001011111010100100101100011111010110001001000000100001000010101101100100100001010001111110110100101101000111011011001010100001100101011010101010010001000001110001010010111100001011101010111111100001	PO: 100001010111110000101110101011111100010010111100010111001111111001010111111111100101111111001100110110101000
+PI: 011100011011011111110010011010010001011011010111001111110101001100011101001000010101111011100110100110100001001111101010001000001101001101110100110011010001000101101111010001111100100111011000010110110100111	PO: 100110001110010011101100001010110100110111111101111111000111110001000111101011101110011001110000011011000001
+PI: 011111101001111100100100000010100111100100010111000011011100011010010110001111010011110111101011111101100010001100000111110010110110010110101100001011001101111001011100011110010011111111000001001101010110101	PO: 100011110101111111100000100111010110100001101101101101001100110001110111001010101000011000000011011001011110
+PI: 011011000100000111011101010110101111101011010111011011100010110101001010001110000001011001001101011110011000100010111001001101111010001000110001110110100010010110111011100101100111000100100101110011010011010	PO: 100100101011100010010010111001010011001011111101101101000000000100010111011101010100010001111111000000010111
+PI: 100000101010100100110010010111000000000011110100101110110110011110101110001101100111011101000000011111101001110000101011110011001000011110010001101110110000100011111011011000001001110100001100011001001100101	PO: 111111000000111010000110001101001100110100111110111111110100101110010111011110000101011101010000110000110001
+PI: 001010010110101101111000001111001100100000000100010101001001011011010000001000011111001001100010011000000010110010100000101001000101100000111000011101101010110000101101110110010100101000111010111011110101000	PO: 100110110110010100011101011101110101001011111101000101001111101101100111100011111010011110010000011010101000
+PI: 100010010001110001011101101010010011001101111011000000010001001010011010001000100011110111011001101100110100110010001100011001101000010001100001011011110100001001111110111100110001110001011000111100101101111	PO: 111011100100111000101100011110101101101001111110000101101111111110011101110011111001011110111111100100101010
+PI: 110000010110001000001101111101110001001011101111010001001011001100110110111110000000100100100100011001000011011010011010001111010000011111101011010000101111011011000011101110001111111101111011000111000001101	PO: 011101110011111110111101100011000001111111111111111111100000001100010111010101001000110011111111110011111000
+PI: 100000101000111111000100101110001011010011010011101001001000010100000101001110111101100111100100101010001000111101001101010010000000110001001100011010001011111100010000110010111111100101100111111010001000011	PO: 011010010111110010110011111100001000011110111111111111100000010010100111010001011110010101011111000001001110
+PI: 011011100101110010100111010001100110001110111010101111010010001110101001010111001110011000111010001100101101110010100110011100011010010101110011001010111001010011101010101101001011001111010011010100100011101	PO: 100001101001100111101001101010100011101101111101101101001111110011111111100010111100011111010000011111101000
+PI: 100110110011001111001001010110001111111010000110011001100100111111010111100001001001111011011101000101101110111010110001100010111010100101000101110011010010000000100011011110001011001000010110001100001101000	PO: 011111110001100100001011000110001101000101110111101101111111110001110111101110101000011110101111011100000000
+PI: 000111100000111100011000000011111010011000101011101011100010010111011110100101111011001000100011111011100100000000100001011101101010101101110010000110110000000101100111001111010001011011000110100101101010101	PO: 000101111100101101100011010011101010100001111101000101001000010001101111010000110100110110010000101011010110
+PI: 101101000000011111001111100001001000111011100111000001000001110110100110001111111000110101100111110111010010111101100111000011011111110000011001111100000101011010111100000011011110100110000010011110101001111	PO: 111000011111010011000001001110101001110111111111010111100000000101001111011000100110110001110000000110111100
+PI: 011100000110100111000100000001000010110010110011000101100001001101000110100110111000001100101110100101111110000101010111011100111011010101110011101110100101000100001100011110000100001001101000000111101101110	PO: 100011110010000100110100000011101101110011111101111111000000011101100111011000000000010111011111100000011000
+PI: 110000110100011110101011011000100101111101000001011011000011011110111100110001000000010100000101111001000111000011111101100000000001110101000100011100011100010101010111000011010110101001000000011001011101010	PO: 011100011111010100100000001101011101010001011111111111100111111101010111111110010110111110100000001000010110
+PI: 111111000101000000010111111011010000000011101011011101010110010000111001101000101010010111000111011110010000100010001011000010011001100001010001100100100001000101101000001010011011101101011000101101001101110	PO: 111001010101110110101100010111001101100101111111101101100111100101010111111010011100111100111100101010000110
diff --git a/podem/Makefile b/podem/Makefile
index 9d34cc6..c36b0e8 100644
--- a/podem/Makefile
+++ b/podem/Makefile
@@ -1,19 +1,24 @@
-
 CXX      = g++
 LINK     = g++
-CXXFLAGS = -O2 -Wall -DDEBUG
+# Remove -DDEBUG flag for VLST-Testing Lab0
+CXXFLAGS = -O2 -Wall
+#CXXFLAGS = -O2 -Wall -DDEBUG
 #CXXFLAGS = -g -DDEBUG_ATPG -Wall #Turn on debugging
 INCPATH  =
 LIBS     = -lreadline -lcurses
 DEL_FILE = rm -f
+DEL_DIR  = rm -fr
+MEMUSG	 = /usr/bin/time -f "Average memory usage: %K \nMaximum memory usage: %M\n"
 
 ####### Files
 
-HEADERS = gate.h fault.h circuit.h GetLongOpt.h typeemu.h readcircuit.tab.h ReadPattern.h hash.h tfault.h
+HEADERS = gate.h fault.h circuit.h GetLongOpt.h typeemu.h readcircuit.tab.h pattern.h hash.h tfault.h
 
-SOURCES = readcircuit.tab.cc lex.yy.cc circuit.cc main.cc GetLongOpt.cc atpg.cc fsim.cc sim.cc psim.cc stfsim.cc tfatpg.cc
+# Add source file assignment.c to be compiled
+SOURCES = readcircuit.tab.cc lex.yy.cc circuit.cc main.cc GetLongOpt.cc atpg.cc fsim.cc sim.cc psim.cc stfsim.cc tfatpg.cc path.cc pattern.cc
 
-OBJECTS = readcircuit.tab.o lex.yy.o circuit.o main.o GetLongOpt.o atpg.o fsim.o sim.o psim.o stfsim.o tfatpg.o
+# Add object file assignment.o to be linked
+OBJECTS = readcircuit.tab.o lex.yy.o circuit.o main.o GetLongOpt.o atpg.o fsim.o sim.o psim.o stfsim.o tfatpg.o path.o pattern.o
 
 TARGET  = atpg
 
@@ -46,4 +51,46 @@ lex.yy.cc: readcircuit.l readcircuit.y
 clean:
 	@$(DEL_FILE) $(OBJECTS) $(TARGET)
 	@$(DEL_FILE) readcircuit.tab.cc readcircuit.tab.h lex.yy.cc
+	@$(DEL_DIR)	 output input
+
+lab2.1-17-1:
+	$(MEMUSG) ./$(TARGET) -pattern -num 100 -output c17.output ../circuits/iscas85/c17.bench
+
+lab2.1-17U-1:
+	$(MEMUSG) ./$(TARGET) -pattern -num 100 -unknown -output c17.output ../circuits/iscas85/c17.bench
+
+lab2.1-17-2:
+	$(MEMUSG) ./$(TARGET) -pattern -num 1000 -output c17.output ../circuits/iscas85/c17.bench
+
+lab2.1-17U-2:
+	$(MEMUSG) ./$(TARGET) -pattern -num 1000 -unknown -output c17.output ../circuits/iscas85/c17.bench
+
+lab2.1-17-3:
+	$(MEMUSG) ./$(TARGET) -pattern -num 10000 -output c17.output ../circuits/iscas85/c17.bench
+
+lab2.1-17U-3:
+	$(MEMUSG) ./$(TARGET) -pattern -num 10000 -unknown -output c17.output ../circuits/iscas85/c17.bench
+
+lab2.1-7552-1:
+	$(MEMUSG) ./$(TARGET) -pattern -num 100 -output c7552.output ../circuits/iscas85/c7552.bench
+
+lab2.1-7552U-1:
+	$(MEMUSG) ./$(TARGET) -pattern -num 100 -output c7552.output ../circuits/iscas85/c7552.bench
+
+lab2.1-7552-2:
+	$(MEMUSG) ./$(TARGET) -pattern -num 1000 -output c7552.output ../circuits/iscas85/c7552.bench
+
+lab2.1-7552U-2:
+	$(MEMUSG) ./$(TARGET) -pattern -num 1000 -output c7552.output ../circuits/iscas85/c7552.bench
+
+lab2.1-7552-3:
+	$(MEMUSG) ./$(TARGET) -pattern -num 10000 -output c7552.output ../circuits/iscas85/c7552.bench
+
+lab2.1-7552U-3:
+	$(MEMUSG) ./$(TARGET) -pattern -num 10000 -output c7552.output ../circuits/iscas85/c7552.bench
+
+lab2.2-17:
+	$(MEMUSG) ./$(TARGET) -mod_logicsim -input ../input/c17.input ../circuits/iscas85/c17.bench
 
+lab2.2-7552:
+	$(MEMUSG) ./$(TARGET) -mod_logicsim -input ../input/c7552.input ../circuits/iscas85/c7552.bench
diff --git a/podem/ReadPattern.h b/podem/ReadPattern.h
deleted file mode 100644
index f0ded87..0000000
--- a/podem/ReadPattern.h
+++ /dev/null
@@ -1,26 +0,0 @@
-#ifndef READPATTERN_H
-#define READPATTERN_H
-
-#include <fstream>
-#include "gate.h"
-using namespace std;
-
-class PATTERN
-{
-    private:
-        ifstream patterninput;
-        vector<GATE*> inlist;
-        int no_pi_infile;
-    public:
-        PATTERN(): no_pi_infile(0){}
-        void Initialize(char* InFileName, int no_pi, string TAG);
-        //Assign next input pattern to PI
-        void ReadNextPattern();
-        void ReadNextPattern_t();
-	void ReadNextPattern(unsigned idx);
-        bool eof()
-        {
-            return (patterninput.eof());
-        }
-};
-#endif
diff --git a/podem/circuit.cc b/podem/circuit.cc
index 32a119c..6702103 100644
--- a/podem/circuit.cc
+++ b/podem/circuit.cc
@@ -157,3 +157,45 @@ void CIRCUIT::SetupIO_ID()
         }
     }
 }
+
+// VLSI-Testing Lab1
+// Print out the netlist stored in the Netlist data structure
+void CIRCUIT::printNetlist()
+{
+	char* GATEFUNC_Table[12] = {"G_PI", "G_PO", "G_PPI", "G_PPO", "G_NOT",
+	"G_AND", "G_NAND", "G_OR", "G_NOR", "G_DFF", "G_BUF", "G_BAD"};
+	vector<GATE*>::iterator it_net;
+
+	for(it_net = Netlist.begin(); it_net != Netlist.end(); ++it_net){
+		cout << "Gate Nate: " << (*it_net)->GetName();
+		cout << ", Gate function: ";
+		cout << GATEFUNC_Table[(*it_net)->GetFunction()];
+		cout << ";\n";
+	}
+}
+
+void CIRCUIT::printPOInputList()
+{
+	unsigned no_gate_fanin, i;
+	vector<GATE*>::iterator it_po;
+
+	for(it_po = POlist.begin(); it_po != POlist.end(); ++it_po){
+		cout << "PO: " << (*it_po)->GetName() << endl;
+		no_gate_fanin = (*it_po)->No_Fanin();
+		for(i = 0; i < no_gate_fanin; ++i)
+			cout << "  " << (*it_po)->Fanin(i)->GetName() << endl;
+	}
+}
+
+void CIRCUIT::printGateOutput()
+{
+	unsigned no_gate_fanout, i;
+	vector<GATE*>::iterator it_net;
+
+	for(it_net = Netlist.begin(); it_net != Netlist.end(); ++it_net){
+		cout << "Gate: " << (*it_net)->GetName() << endl;
+		no_gate_fanout = (*it_net)->No_Fanout();
+		for(i = 0; i < no_gate_fanout; ++i)
+			cout << "  " << (*it_net)->Fanout(i)->GetName() << endl;
+	}
+}
diff --git a/podem/circuit.h b/podem/circuit.h
index 3319a6e..3ae32f1 100644
--- a/podem/circuit.h
+++ b/podem/circuit.h
@@ -2,159 +2,227 @@
 #define CIRCUIT_H
 #include "fault.h"
 #include "tfault.h"
-#include "ReadPattern.h"
+#include "pattern.h"
 #include <stdlib.h>
+#include <string>
+#include <vector>
+#include <fstream>
+#include <string.h>
+#include <bitset>
+
+#define xstr(s) str(s)
+#define str(s) #s
+#define OUTDIR output
 
 typedef GATE* GATEPTR;
 
 class CIRCUIT
 {
-    private:
-        string Name;
-        PATTERN Pattern;
-        vector<GATE*> Netlist;
-        vector<GATE*> PIlist; //store the gate indexes of PI
-        vector<GATE*> POlist;
-        vector<GATE*> PPIlist;
-        vector<GATE*> PPOlist;
-        list<FAULT*> Flist; //collapsing fault list
-        list<FAULT*> UFlist; //undetected fault list
-        list<TFAULT*> TFlist; //collapsing fault list
-        list<TFAULT*> UTFlist; //undetected fault list
-        unsigned MaxLevel;
-        unsigned BackTrackLimit; //backtrack limit for Podem
-        typedef list<GATE*> ListofGate;
-        typedef list<GATE*>::iterator ListofGateIte;
-        ListofGate* Queue;
-        ListofGate GateStack;
-        ListofGate PropagateTree;
-        ListofGateIte QueueIte;
-
-    public:
-        //Initialize netlist
-        CIRCUIT(): MaxLevel(0), BackTrackLimit(10000) {
-            Netlist.reserve(32768);
-            PIlist.reserve(128);
-            POlist.reserve(512);
-            PPIlist.reserve(2048);
-            PPOlist.reserve(2048);
-        }
-        CIRCUIT(unsigned NO_GATE, unsigned NO_PI = 128, unsigned NO_PO = 512,
-                unsigned NO_PPI = 2048, unsigned NO_PPO = 2048) {
-            Netlist.reserve(NO_GATE);
-            PIlist.reserve(NO_PI);
-            POlist.reserve(NO_PO);
-            PPIlist.reserve(NO_PPI);
-            PPOlist.reserve(NO_PPO);
-        }
-        ~CIRCUIT() {
-            for (unsigned i = 0;i<Netlist.size();++i) { delete Netlist[i]; }
-            list<FAULT*>::iterator fite;
-            for (fite = Flist.begin();fite!=Flist.end();++fite) { delete *fite; }
-        }
-
-        void AddGate(GATE* gptr) { Netlist.push_back(gptr); }
-        void SetName(string n){ Name = n;}
-        string GetName(){ return Name;}
-        int GetMaxLevel(){ return MaxLevel;}
-        void SetBackTrackLimit(unsigned bt) { BackTrackLimit = bt; }
-
-        //Access the gates by indexes
-        GATE* Gate(unsigned index) { return Netlist[index]; }
-        GATE* PIGate(unsigned index) { return PIlist[index]; }
-        GATE* POGate(unsigned index) { return POlist[index]; }
-        GATE* PPIGate(unsigned index) { return PPIlist[index]; }
-        GATE* PPOGate(unsigned index) { return PPOlist[index]; }
-        unsigned No_Gate() { return Netlist.size(); }
-        unsigned No_PI() { return PIlist.size(); }
-        unsigned No_PO() { return POlist.size(); }
-        unsigned No_PPI() { return PPIlist.size(); }
-        unsigned No_PPO() { return PPOlist.size(); }
-
-        void InitPattern(const char *pattern) {
-            Pattern.Initialize(const_cast<char *>(pattern), PIlist.size(), "PI");
-        }
-
-        void Schedule(GATE* gptr)
-        {
-            if (!gptr->GetFlag(SCHEDULED)) {
-                gptr->SetFlag(SCHEDULED);
-                Queue[gptr->GetLevel()].push_back(gptr);
-            }
-        }
-
-        //defined in circuit.cc
-        void Levelize();
-        void FanoutList();
-        void Check_Levelization();
-        void SetMaxLevel();
-        void SetupIO_ID();
-
-        //defined in sim.cc
-        void SetPPIZero(); //Initialize PPI state
-        void InitializeQueue();
-        void ScheduleFanout(GATE*);
-        void SchedulePI();
-        void SchedulePPI();
-        void LogicSimVectors();
-        void LogicSim();
-        void PrintIO();
-        VALUE Evaluate(GATEPTR gptr);
-
-        //defined in atpg.cc
-        void GenerateAllFaultList();
-        void GenerateCheckPointFaultList();
-        void GenerateFaultList();
-        void Atpg();
-        void SortFaninByLevel();
-        bool CheckTest();
-        bool TraceUnknownPath(GATEPTR gptr);
-        bool FaultEvaluate(FAULT* fptr);
-        ATPG_STATUS Podem(FAULT* fptr, unsigned &total_backtrack_num);
-        ATPG_STATUS SetUniqueImpliedValue(FAULT* fptr);
-        ATPG_STATUS BackwardImply(GATEPTR gptr, VALUE value);
-        GATEPTR FindPropagateGate();
-        GATEPTR FindHardestControl(GATEPTR gptr);
-        GATEPTR FindEasiestControl(GATEPTR gptr);
-        GATEPTR FindPIAssignment(GATEPTR gptr, VALUE value);
-        GATEPTR TestPossible(FAULT* fptr);
-        void TraceDetectedStemFault(GATEPTR gptr, VALUE val);
-
-        //defined in fsim.cc
-        void MarkOutputGate();
-        void MarkPropagateTree(GATEPTR gptr);
-        void FaultSimVectors();
-        void FaultSim();
-        void FaultSimEvaluate(GATE* gptr);
-        bool CheckFaultyGate(FAULT* fptr);
-        void InjectFaultValue(GATEPTR gptr, unsigned idx,VALUE value);
-
-	//defined in psim.cc for parallel logic simulation
-	void ParallelLogicSimVectors();
-	void ParallelLogicSim();
-	void ParallelEvaluate(GATEPTR gptr);
-	void PrintParallelIOs(unsigned idx);
-	void ScheduleAllPIs();
-
-	//defined in stfsim.cc for single pattern single transition-fault simulation
-	void GenerateAllTFaultList();
-	void TFaultSimVectors();
-	void TFaultSim_t();
-	void TFaultSim();
-	bool CheckTFaultyGate(TFAULT* fptr);
-	bool CheckTFaultyGate_t(TFAULT* fptr);
-	VALUE Evaluate_t(GATEPTR gptr);
-	void LogicSim_t();
-        void PrintTransition();
-        void PrintTransition_t();
-        void PrintIO_t();
-
-	//defined in tfatpg.cc for transition fault ATPG
-	void TFAtpg();
-	ATPG_STATUS Initialization(GATEPTR gptr, VALUE target, unsigned &total_backtrack_num);
-	ATPG_STATUS BackwardImply_t(GATEPTR gptr, VALUE value);
-	GATEPTR FindPIAssignment_t(GATEPTR gptr, VALUE value);
-	GATEPTR FindEasiestControl_t(GATEPTR gptr);
-	GATEPTR FindHardestControl_t(GATEPTR gptr);
+	private:
+		string Name;
+		PATTERN Pattern;
+		vector<GATE*> Netlist;
+		vector<GATE*> PIlist; //store the gate indexes of PI
+		vector<GATE*> POlist;
+		vector<GATE*> PPIlist;
+		vector<GATE*> PPOlist;
+		list<FAULT*> Flist; //collapsing fault list
+		list<FAULT*> UFlist; //undetected fault list
+		list<TFAULT*> TFlist; //collapsing fault list
+		list<TFAULT*> UTFlist; //undetected fault list
+		unsigned MaxLevel;
+		unsigned BackTrackLimit; //backtrack limit for Podem
+		typedef list<GATE*> ListofGate;
+		typedef list<GATE*>::iterator ListofGateIte;
+		ListofGate* Queue;
+		ListofGate GateStack;
+		ListofGate PropagateTree;
+		ListofGateIte QueueIte;
+		//VLSI-Testing Lab1, stack for path
+		std::vector<GATE*> path_stack;
+		int path_count;
+		string dest_gate_name;
+		string input_name, output_name;
+		ofstream ofs; // for printing logicsim output file
+
+	public:
+		//Initialize netlist
+		CIRCUIT(): MaxLevel(0), BackTrackLimit(10000) {
+			Netlist.reserve(32768);
+			PIlist.reserve(128);
+			POlist.reserve(512);
+			PPIlist.reserve(2048);
+			PPOlist.reserve(2048);
+			path_stack.clear();
+			path_count = 0;
+		}
+		CIRCUIT(unsigned NO_GATE, unsigned NO_PI = 128, unsigned NO_PO = 512,
+				unsigned NO_PPI = 2048, unsigned NO_PPO = 2048) {
+			Netlist.reserve(NO_GATE);
+			PIlist.reserve(NO_PI);
+			POlist.reserve(NO_PO);
+			PPIlist.reserve(NO_PPI);
+			PPOlist.reserve(NO_PPO);
+			path_stack.clear();
+			path_count = 0;
+		}
+		~CIRCUIT() {
+			for (unsigned i = 0;i<Netlist.size();++i) { delete Netlist[i]; }
+			list<FAULT*>::iterator fite;
+			for (fite = Flist.begin();fite!=Flist.end();++fite) { delete *fite; }
+			if(ofs.is_open())
+				ofs.close();
+		}
+
+		void AddGate(GATE* gptr) { Netlist.push_back(gptr); }
+		void SetName(string n){ Name = n;}
+		string GetName(){ return Name;}
+		int GetMaxLevel(){ return MaxLevel;}
+		void SetBackTrackLimit(unsigned bt) { BackTrackLimit = bt; }
+
+		//Access the gates by indexes
+		GATE* Gate(unsigned index) { return Netlist[index]; }
+		GATE* PIGate(unsigned index) { return PIlist[index]; }
+		GATE* POGate(unsigned index) { return POlist[index]; }
+		GATE* PPIGate(unsigned index) { return PPIlist[index]; }
+		GATE* PPOGate(unsigned index) { return PPOlist[index]; }
+		unsigned No_Gate() { return Netlist.size(); }
+		unsigned No_PI() { return PIlist.size(); }
+		unsigned No_PO() { return POlist.size(); }
+		unsigned No_PPI() { return PPIlist.size(); }
+		unsigned No_PPO() { return PPOlist.size(); }
+
+		void copyPItoPattern(){
+			vector<GATE*>::iterator it; 
+			for(it = PIlist.begin(); it != PIlist.end(); it++){
+				Pattern.addInList(*it);
+			}
+		}
+		void genRandomPattern(string pattern_name, int number){
+			Pattern.setPatternName(pattern_name);
+			copyPItoPattern();
+			Pattern.genRandomPattern(number);
+			Pattern.setPatterninput();
+		}
+		void genRandomPatternUnknown(string pattern_name, int number){
+			Pattern.setPatternName(pattern_name);
+			copyPItoPattern();
+			Pattern.genRandomPatternUnknown(number);
+			Pattern.setPatterninput();
+		}
+
+		void InitPattern(const char *pattern) {
+			Pattern.Initialize(const_cast<char *>(pattern), PIlist.size(), "PI");
+		}
+
+		void openOutputFile(string file_name) {
+			char str[] = "mkdir ";
+			strcat(str, xstr(OUTDIR));
+			system(str);
+
+			strcpy(str, "./"); 
+			strcat(str, xstr(OUTDIR));
+			strcat(str, "/");
+			strcat(str, file_name.c_str());
+			ofs.open(str, ofstream::out | ofstream::trunc);
+			if(!ofs.is_open())
+				cout << "Cannot open file!\n";
+		}
+
+		void Schedule(GATE* gptr)
+		{
+			if (!gptr->GetFlag(SCHEDULED)) {
+				gptr->SetFlag(SCHEDULED);
+				Queue[gptr->GetLevel()].push_back(gptr);
+			}
+		}
+
+		// VLSI-Testing Lab1
+		// defined in path.cc
+		void path(string src_name_gate, string dest_gate_name);
+		bool findPath();
+		void printPath();
+
+		//defined in circuit.cc
+		void Levelize();
+		void FanoutList();
+		void Check_Levelization();
+		void SetMaxLevel();
+		void SetupIO_ID();
+		// print useful infomation
+		void printNetlist();
+		void printPOInputList();
+		void printGateOutput();
+
+		//defined in sim.cc
+		void SetPPIZero(); //Initialize PPI state
+		void InitializeQueue();
+		void ScheduleFanout(GATE*);
+		void SchedulePI();
+		void SchedulePPI();
+		void LogicSimVectors();
+		void LogicSim();
+		void ModLogicSimVectors();
+		void ModLogicSim();
+		void PrintIO();
+		void PrintModIO();
+		VALUE Evaluate(GATEPTR gptr);
+		bitset<2> ModEvaluate(GATEPTR gptr);
+
+		//defined in atpg.cc
+		void GenerateAllFaultList();
+		void GenerateCheckPointFaultList();
+		void GenerateFaultList();
+		void Atpg();
+		void SortFaninByLevel();
+		bool CheckTest();
+		bool TraceUnknownPath(GATEPTR gptr);
+		bool FaultEvaluate(FAULT* fptr);
+		ATPG_STATUS Podem(FAULT* fptr, unsigned &total_backtrack_num);
+		ATPG_STATUS SetUniqueImpliedValue(FAULT* fptr);
+		ATPG_STATUS BackwardImply(GATEPTR gptr, VALUE value);
+		GATEPTR FindPropagateGate();
+		GATEPTR FindHardestControl(GATEPTR gptr);
+		GATEPTR FindEasiestControl(GATEPTR gptr);
+		GATEPTR FindPIAssignment(GATEPTR gptr, VALUE value);
+		GATEPTR TestPossible(FAULT* fptr);
+		void TraceDetectedStemFault(GATEPTR gptr, VALUE val);
+
+		//defined in fsim.cc
+		void MarkOutputGate();
+		void MarkPropagateTree(GATEPTR gptr);
+		void FaultSimVectors();
+		void FaultSim();
+		void FaultSimEvaluate(GATE* gptr);
+		bool CheckFaultyGate(FAULT* fptr);
+		void InjectFaultValue(GATEPTR gptr, unsigned idx,VALUE value);
+
+		//defined in psim.cc for parallel logic simulation
+		void ParallelLogicSimVectors();
+		void ParallelLogicSim();
+		void ParallelEvaluate(GATEPTR gptr);
+		void PrintParallelIOs(unsigned idx);
+		void ScheduleAllPIs();
+
+		//defined in stfsim.cc for single pattern single transition-fault simulation
+		void GenerateAllTFaultList();
+		void TFaultSimVectors();
+		void TFaultSim_t();
+		void TFaultSim();
+		bool CheckTFaultyGate(TFAULT* fptr);
+		bool CheckTFaultyGate_t(TFAULT* fptr);
+		VALUE Evaluate_t(GATEPTR gptr);
+		void LogicSim_t();
+		void PrintTransition();
+		void PrintTransition_t();
+		void PrintIO_t();
+
+		//defined in tfatpg.cc for transition fault ATPG
+		void TFAtpg();
+		ATPG_STATUS Initialization(GATEPTR gptr, VALUE target, unsigned &total_backtrack_num);
+		ATPG_STATUS BackwardImply_t(GATEPTR gptr, VALUE value);
+		GATEPTR FindPIAssignment_t(GATEPTR gptr, VALUE value);
+		GATEPTR FindEasiestControl_t(GATEPTR gptr);
+		GATEPTR FindHardestControl_t(GATEPTR gptr);
 };
 #endif
diff --git a/podem/cscope.files b/podem/cscope.files
new file mode 100644
index 0000000..924d345
--- /dev/null
+++ b/podem/cscope.files
@@ -0,0 +1,9 @@
+./fault.h
+./circuit.h
+./tfault.h
+./ReadPattern.h
+./gate.h
+./hash.h
+./typeemu.h
+./GetLongOpt.h
+./readcircuit.tab.h
diff --git a/podem/cscope.out b/podem/cscope.out
new file mode 100644
index 0000000..3b0342e
--- /dev/null
+++ b/podem/cscope.out
@@ -0,0 +1,19752 @@
+cscope 15 $HOME/Program/VLSI-Testing/podem               0000106701
+	@GetLongOpt.h
+
+4 #ide
+_GLgO_h_
+
+
+5 
+	#_GLgO_h_
+
+
+	)
+
+7 
+	~<ioam
+>
+
+8 
+	~<rg
+>
+
+9 
+	~<crg
+>
+
+10 
+usg
+ 
+mea
+ 
+	gd
+;
+
+12 as
+	cGLgO
+
+
+14 
+	mpublic
+:
+
+15 
+	eOTy
+ {
+
+16 
+NoVue
+, 
+	mOiVue
+, 
+	mMdyVue
+
+
+18 
+	give
+:
+
+19 
+	sCl
+
+
+21 c *
+ti
+;
+
+22 
+OTy
+ 
+	gty
+;
+
+23 c *
+	gdesti
+;
+
+24 c *
+	gvue
+;
+
+25 
+Cl
+ *
+	gxt
+;
+
+27 
+Cl
+({ 
+	gti
+ = 
+desti
+ = 
+vue
+ = 0; 
+	gxt
+ = 0; }
+
+29 
+	give
+:
+
+30 
+Cl
+ *
+b
+;
+
+31 c *
+	gurg
+;
+
+32 *
+	game
+;
+
+33 
+	gtmk
+;
+
+35 
+	grl_de
+;
+
+36 
+Cl
+ *
+	g
+;
+
+38 
+	give
+:
+
+39 *
+	$bame
+(* c 
+p
+) const;
+
+40 
+	`t
+(
+Cl
+ *
+c
+, *
+vtok
+, *
+xok
+, *
+p
+);
+
+41 
+public
+:
+
+42 
+	`GLgO
+(c 
+tmk
+ = '-');
+
+43 ~
+	`GLgO
+();
+
+45 
+	`r
+(
+gc
+, * c *
+gv
+);
+
+46 
+	`r
+(* c 
+r
+, * c 
+p
+);
+
+48 
+	`rl
+(c * c 
+t
+, c 
+OTy
+ 
+t
+,
+
+49 c * c 
+desc
+, c * c 
+v
+);
+
+50 c *
+	$ve
+(c * c 
+t
+) const;
+
+52 
+	$uge
+(
+oam
+ &
+outfe
+ = 
+cout
+) const;
+
+53 
+	$uge
+(c *
+r
+{ 
+urg
+ = s; 
+	}
+}
+
+	@ReadPattern.h
+
+1 #ide
+READPATTERN_H
+
+
+2 
+	#READPATTERN_H
+
+
+	)
+
+4 
+	~<fam
+>
+
+5 
+	~"ge.h
+"
+
+6 
+usg
+ 
+mea
+ 
+	gd
+;
+
+8 as
+	cPATTERN
+
+
+10 
+	mive
+:
+
+11 
+ifam
+ 
+nput
+;
+
+12 
+	mve
+<
+	mGATE
+*> 
+	mli
+;
+
+13 
+	mno_pi_fe
+;
+
+14 
+	mpublic
+:
+
+15 
+	$PATTERN
+(): 
+	$no_pi_fe
+(0){}
+
+16 
+	`Inlize
+(* 
+InFeName
+, 
+no_pi
+, 
+rg
+ 
+TAG
+);
+
+18 
+	`RdNextP
+();
+
+19 
+	`RdNextP_t
+();
+
+20 
+	`RdNextP
+(
+idx
+);
+
+21 
+bo
+ 
+	$eof
+()
+
+23  (
+nput
+.
+	`eof
+());
+
+24 
+	}
+}
+
+	@circuit.h
+
+1 #ide
+CIRCUIT_H
+
+
+2 
+	#CIRCUIT_H
+
+
+	)
+
+3 
+	~"u.h
+"
+
+4 
+	~"tu.h
+"
+
+5 
+	~"RdP.h
+"
+
+6 
+	~<dlib.h
+>
+
+8 
+GATE
+* 
+	tGATEPTR
+;
+
+10 as
+	cCIRCUIT
+
+
+12 
+	mive
+:
+
+13 
+rg
+ 
+Name
+;
+
+14 
+PATTERN
+ 
+	mP
+;
+
+15 
+	mve
+<
+	mGATE
+*> 
+	mNli
+;
+
+16 
+	mve
+<
+	mGATE
+*> 
+	mPIli
+;
+
+17 
+	mve
+<
+	mGATE
+*> 
+	mPOli
+;
+
+18 
+	mve
+<
+	mGATE
+*> 
+	mPPIli
+;
+
+19 
+	mve
+<
+	mGATE
+*> 
+	mPPOli
+;
+
+20 
+	mli
+<
+	mFAULT
+*> 
+	mFli
+;
+
+21 
+	mli
+<
+	mFAULT
+*> 
+	mUFli
+;
+
+22 
+	mli
+<
+	mTFAULT
+*> 
+	mTFli
+;
+
+23 
+	mli
+<
+	mTFAULT
+*> 
+	mUTFli
+;
+
+24 
+	mMaxLev
+;
+
+25 
+	mBackTckLim
+;
+
+26 
+	mli
+<
+	tGATE
+*> 
+	tLiofGe
+;
+
+27 
+	mli
+<
+	tGATE
+*>::
+	t
+ 
+	tLiofGeI
+;
+
+28 
+LiofGe
+* 
+	mQueue
+;
+
+29 
+LiofGe
+ 
+	mGeSck
+;
+
+30 
+LiofGe
+ 
+	mPrageTe
+;
+
+31 
+LiofGeI
+ 
+	mQueueI
+;
+
+33 
+	mpublic
+:
+
+35 
+	$CIRCUIT
+(): 
+	`MaxLev
+(0), 
+	$BackTckLim
+(10000) {
+
+36 
+Nli
+.
+	`rve
+(32768);
+
+37 
+PIli
+.
+	`rve
+(128);
+
+38 
+POli
+.
+	`rve
+(512);
+
+39 
+PPIli
+.
+	`rve
+(2048);
+
+40 
+PPOli
+.
+	`rve
+(2048);
+
+42 
+	$CIRCUIT
+(
+NO_GATE
+, 
+NO_PI
+ = 128, 
+NO_PO
+ = 512,
+
+43 
+NO_PPI
+ = 2048, 
+NO_PPO
+ = 2048) {
+
+44 
+Nli
+.
+	`rve
+(
+NO_GATE
+);
+
+45 
+PIli
+.
+	`rve
+(
+NO_PI
+);
+
+46 
+POli
+.
+	`rve
+(
+NO_PO
+);
+
+47 
+PPIli
+.
+	`rve
+(
+NO_PPI
+);
+
+48 
+PPOli
+.
+	`rve
+(
+NO_PPO
+);
+
+49 
+	}
+}
+
+50 ~
+	$CIRCUIT
+() {
+
+51 
+i
+ = 0;i<
+Nli
+.
+	`size
+();++i{ 
+de
+ Netlist[i]; }
+
+52 
+li
+<
+FAULT
+*>::
+
+ 
+fe
+;
+
+53 
+fe
+ = 
+Fli
+.
+	`beg
+();fe!=Fli.
+	`d
+();++fe{ 
+de
+ *fite; }
+
+54 
+	}
+}
+
+56 
+	$AddGe
+(
+GATE
+* 
+gr
+{ 
+Nli
+.
+	`push_back
+(gr); 
+	}
+}
+
+57 
+	$SName
+(
+rg
+ 
+n
+){ 
+Name
+ =;
+	}
+}
+
+58 
+rg
+ 
+	$GName
+(){  
+Name
+;
+	}
+}
+
+59 
+	$GMaxLev
+(){  
+MaxLev
+;
+	}
+}
+
+60 
+	$SBackTckLim
+(
+bt
+{ 
+BackTckLim
+ = bt; 
+	}
+}
+
+63 
+GATE
+* 
+	$Ge
+(
+dex
+{  
+Nli
+[dex]; 
+	}
+}
+
+64 
+GATE
+* 
+	$PIGe
+(
+dex
+{  
+PIli
+[dex]; 
+	}
+}
+
+65 
+GATE
+* 
+	$POGe
+(
+dex
+{  
+POli
+[dex]; 
+	}
+}
+
+66 
+GATE
+* 
+	$PPIGe
+(
+dex
+{  
+PPIli
+[dex]; 
+	}
+}
+
+67 
+GATE
+* 
+	$PPOGe
+(
+dex
+{  
+PPOli
+[dex]; 
+	}
+}
+
+68 
+	$No_Ge
+({  
+Nli
+.
+	`size
+(); 
+	}
+}
+
+69 
+	$No_PI
+({  
+PIli
+.
+	`size
+(); 
+	}
+}
+
+70 
+	$No_PO
+({  
+POli
+.
+	`size
+(); 
+	}
+}
+
+71 
+	$No_PPI
+({  
+PPIli
+.
+	`size
+(); 
+	}
+}
+
+72 
+	$No_PPO
+({  
+PPOli
+.
+	`size
+(); 
+	}
+}
+
+74 
+	$InP
+(c *
+n
+) {
+
+75 
+P
+.
+	`Inlize
+(
+c_
+<*>(
+n
+), 
+PIli
+.
+	`size
+(), "PI");
+
+76 
+	}
+}
+
+78 
+	$Schedu
+(
+GATE
+* 
+gr
+)
+
+80 i(!
+gr
+->
+	`GFg
+(
+SCHEDULED
+)) {
+
+81 
+gr
+->
+	`SFg
+(
+SCHEDULED
+);
+
+82 
+Queue
+[
+gr
+->
+	`GLev
+()].
+	`push_back
+(gptr);
+
+84 
+	}
+}
+
+87 
+Levize
+();
+
+88 
+FoutLi
+();
+
+89 
+Check_Levizi
+();
+
+90 
+SMaxLev
+();
+
+91 
+SupIO_ID
+();
+
+94 
+SPPIZo
+();
+
+95 
+InlizeQueue
+();
+
+96 
+ScheduFout
+(
+GATE
+*);
+
+97 
+ScheduPI
+();
+
+98 
+ScheduPPI
+();
+
+99 
+LogicSimVes
+();
+
+100 
+LogicSim
+();
+
+101 
+PrtIO
+();
+
+102 
+VALUE
+ 
+Evue
+(
+GATEPTR
+ 
+gr
+);
+
+105 
+GeAFauLi
+();
+
+106 
+GeCheckPotFauLi
+();
+
+107 
+GeFauLi
+();
+
+108 
+Ag
+();
+
+109 
+StFByLev
+();
+
+110 
+bo
+ 
+CheckTe
+();
+
+111 
+bo
+ 
+TUnknownPh
+(
+GATEPTR
+ 
+gr
+);
+
+112 
+bo
+ 
+FauEvue
+(
+FAULT
+* 
+
+);
+
+113 
+ATPG_STATUS
+ 
+Podem
+(
+FAULT
+* 
+
+, &
+t_backack_num
+);
+
+114 
+ATPG_STATUS
+ 
+SUniqueImdVue
+(
+FAULT
+* 
+
+);
+
+115 
+ATPG_STATUS
+ 
+BackwdImy
+(
+GATEPTR
+ 
+gr
+, 
+VALUE
+ 
+vue
+);
+
+116 
+GATEPTR
+ 
+FdPrageGe
+();
+
+117 
+GATEPTR
+ 
+FdHdeC
+(GATEPTR 
+gr
+);
+
+118 
+GATEPTR
+ 
+FdEasC
+(GATEPTR 
+gr
+);
+
+119 
+GATEPTR
+ 
+FdPIAssignmt
+(GATEPTR 
+gr
+, 
+VALUE
+ 
+vue
+);
+
+120 
+GATEPTR
+ 
+TePossib
+(
+FAULT
+* 
+
+);
+
+121 
+TDeedSmFau
+(
+GATEPTR
+ 
+gr
+, 
+VALUE
+ 
+v
+);
+
+124 
+MkOuutGe
+();
+
+125 
+MkPrageTe
+(
+GATEPTR
+ 
+gr
+);
+
+126 
+FauSimVes
+();
+
+127 
+FauSim
+();
+
+128 
+FauSimEvue
+(
+GATE
+* 
+gr
+);
+
+129 
+bo
+ 
+CheckFauyGe
+(
+FAULT
+* 
+
+);
+
+130 
+InjeFauVue
+(
+GATEPTR
+ 
+gr
+, 
+idx
+,
+VALUE
+ 
+vue
+);
+
+133 
+PlLogicSimVes
+();
+
+134 
+PlLogicSim
+();
+
+135 
+PlEvue
+(
+GATEPTR
+ 
+gr
+);
+
+136 
+PrtPlIOs
+(
+idx
+);
+
+137 
+ScheduAPIs
+();
+
+140 
+GeATFauLi
+();
+
+141 
+TFauSimVes
+();
+
+142 
+TFauSim_t
+();
+
+143 
+TFauSim
+();
+
+144 
+bo
+ 
+CheckTFauyGe
+(
+TFAULT
+* 
+
+);
+
+145 
+bo
+ 
+CheckTFauyGe_t
+(
+TFAULT
+* 
+
+);
+
+146 
+VALUE
+ 
+Evue_t
+(
+GATEPTR
+ 
+gr
+);
+
+147 
+LogicSim_t
+();
+
+148 
+PrtTnsi
+();
+
+149 
+PrtTnsi_t
+();
+
+150 
+PrtIO_t
+();
+
+153 
+TFAg
+();
+
+154 
+ATPG_STATUS
+ 
+Inlizi
+(
+GATEPTR
+ 
+gr
+, 
+VALUE
+ 
+rg
+, &
+t_backack_num
+);
+
+155 
+ATPG_STATUS
+ 
+BackwdImy_t
+(
+GATEPTR
+ 
+gr
+, 
+VALUE
+ 
+vue
+);
+
+156 
+GATEPTR
+ 
+FdPIAssignmt_t
+(GATEPTR 
+gr
+, 
+VALUE
+ 
+vue
+);
+
+157 
+GATEPTR
+ 
+FdEasC_t
+(GATEPTR 
+gr
+);
+
+158 
+GATEPTR
+ 
+FdHdeC_t
+(GATEPTR 
+gr
+);
+
+	@fault.h
+
+1 #ide
+FAULT_H
+
+
+2 
+	#FAULT_H
+
+
+	)
+
+3 
+	~"ge.h
+"
+
+5 as
+	cFAULT
+
+
+7 
+	mive
+:
+
+8 
+VALUE
+ 
+Vue
+;
+
+9 
+GATE
+* 
+	mIut
+;
+
+10 
+GATE
+* 
+	mOuut
+;
+
+12 
+bo
+ 
+	mBnch
+;
+
+13 
+	mEqvFauNum
+;
+
+14 
+FAULT_STATUS
+ 
+	mStus
+;
+
+15 
+	mpublic
+:
+
+16 
+	$FAULT
+(
+GATE
+* 
+gr
+, GATE* 
+ogr
+, 
+VALUE
+ 
+vue
+): 
+	`Vue
+(vue), 
+	`Iut
+(gptr),
+
+17 
+	`Ouut
+(
+ogr
+), 
+	`Bnch
+(
+l
+), 
+	`EqvFauNum
+(1), 
+	$Stus
+(
+UNKNOWN
+) {}
+
+18 ~
+	$FAULT
+({
+	}
+}
+
+19 
+VALUE
+ 
+	$GVue
+({  
+Vue
+; 
+	}
+}
+
+20 
+GATE
+* 
+	$GIutGe
+({  
+Iut
+; 
+	}
+}
+
+21 
+GATE
+* 
+	$GOuutGe
+({  
+Ouut
+; 
+	}
+}
+
+22 
+	$SBnch
+(
+bo
+ 
+b
+{ 
+Bnch
+ = b; 
+	}
+}
+
+23 
+bo
+ 
+	$Is_Bnch
+({  
+Bnch
+; 
+	}
+}
+
+24 
+	$SEqvFauNum
+(
+n
+{ 
+EqvFauNum
+ =; 
+	}
+}
+
+25 
+	$IncEqvFauNum
+({ ++
+EqvFauNum
+; 
+	}
+}
+
+26 
+	$GEqvFauNum
+({  
+EqvFauNum
+; 
+	}
+}
+
+27 
+	$SStus
+(
+FAULT_STATUS
+ 
+us
+{ 
+Stus
+ = stus; 
+	}
+}
+
+28 
+FAULT_STATUS
+ 
+	$GStus
+({  
+Stus
+; 
+	}
+}
+
+	@gate.h
+
+1 #ide
+GATE_H
+
+
+2 
+	#GATE_H
+
+
+	)
+
+3 
+	~<bt
+>
+
+4 
+	~"tyemu.h
+"
+
+5 
+usg
+ 
+mea
+ 
+	gd
+;
+
+7 as
+	cGATE
+
+
+9 
+	mive
+:
+
+10 
+rg
+ 
+Name
+;
+
+11 
+	mID
+;
+
+12 
+GATEFUNC
+ 
+	mFuni
+;
+
+13 
+	mve
+<
+	mGATE
+*> 
+	mIut_li
+;
+
+14 
+	mve
+<
+	mGATE
+*> 
+	mOuut_li
+;
+
+15 
+	mbt
+<
+	mNumFgs
+> 
+	mFg
+;
+
+16 
+	mLev
+;
+
+17 
+VALUE
+ 
+	mVue
+;
+
+18 
+VALUE
+ 
+	mVue_t
+;
+
+19 
+bo
+ 
+	mInvsi
+;
+
+21 
+	mCou
+[2];
+
+24 
+	mbt
+<
+	mPNum
+> 
+	mWeVue
+[2];
+
+25 
+	mbt
+<
+	mPNum
+> 
+	mFauFg
+;
+
+26 
+	mpublic
+:
+
+28 
+	$GATE
+(): 
+	`Funi
+(
+G_BAD
+), 
+	`Lev
+(0), 
+	`Vue
+(
+X
+), 
+	`Vue_t
+(X), 
+	$Invsi
+(
+l
+) {
+
+29 
+Iut_li
+.
+	`rve
+(4);
+
+30 
+Ouut_li
+.
+	`rve
+(4);
+
+31 
+Cou
+[0] = (0);
+
+32 
+Cou
+[1] = (0);
+
+33 
+WeVue
+[0].
+	`t
+();
+
+34 
+WeVue
+[1].
+	`t
+();
+
+36 ~
+	$GATE
+({
+	}
+}
+
+37 
+	$SName
+(
+rg
+ 
+n
+){ 
+Name
+ =;
+	}
+}
+
+38 
+	$SID
+(
+id
+){ 
+ID
+ = id;
+	}
+}
+
+39 
+	$SFuni
+(
+GATEFUNC
+ 
+f
+){ 
+Funi
+ = f;
+	}
+}
+
+40 
+	$AddIut_li
+(
+GATE
+* 
+gr
+){
+Iut_li
+.
+	`push_back
+(gr);
+	}
+}
+
+41 
+	gve
+<
+	gGATE
+*> &
+	$GIut_li
+({  
+Iut_li
+; 
+	}
+}
+
+42 
+	$AddOuut_li
+(
+GATE
+* 
+gr
+){
+Ouut_li
+.
+	`push_back
+(gr);
+	}
+}
+
+43 
+	$SLev
+(
+l
+){ 
+Lev
+ =;
+	}
+}
+
+44 
+	$SVue
+(
+VALUE
+ 
+v
+{
+Vue
+ = v;
+	}
+}
+
+45 
+	$InvVue
+({
+Vue
+ = 
+NTab
+[Vue];
+	}
+}
+
+46 
+	$SVue_t
+(
+VALUE
+ 
+v
+{
+Vue_t
+ = v;
+	}
+}
+
+47 
+	$InvVue_t
+({
+Vue_t
+ = 
+NTab
+[Vue_t];
+	}
+}
+
+48 
+	$IncCou
+(
+i
+ = 0{
+Cou
+[i]++;
+	}
+}
+
+49 
+	$DecCou
+(
+i
+ = 0{
+Cou
+[i]--;
+	}
+}
+
+50 
+	$RetCou
+(
+i
+ = 0{
+Cou
+[i] = 0;
+	}
+}
+
+51 
+	$RetACou
+({
+Cou
+[0] = 0;Cou[1] = 0;
+	}
+}
+
+52 
+	$GCou
+(
+i
+ = 0{  
+Cou
+[i];
+	}
+}
+
+53 
+rg
+ 
+	$GName
+(){  
+Name
+;
+	}
+}
+
+54 
+	$GID
+(){  
+ID
+;
+	}
+}
+
+55 
+GATEFUNC
+ 
+	$GFuni
+(){  
+Funi
+;
+	}
+}
+
+56 
+	$No_F
+({  
+Iut_li
+.
+	`size
+();
+	}
+}
+
+57 
+	$No_Fout
+({  
+Ouut_li
+.
+	`size
+();
+	}
+}
+
+58 
+GATE
+* 
+	$F
+(
+i
+{  
+Iut_li
+[i];
+	}
+}
+
+59 
+GATE
+* 
+	$Fout
+(
+i
+{  
+Ouut_li
+[i];
+	}
+}
+
+60 
+	$ChgeF
+(
+i
+, 
+GATE
+* 
+g
+{
+Iut_li
+[i] = g;
+	}
+}
+
+61 
+	$ChgeFout
+(
+i
+, 
+GATE
+* 
+g
+{
+Ouut_li
+[i] = g;
+	}
+}
+
+62 
+	$GLev
+({  
+Lev
+;
+	}
+}
+
+63 
+VALUE
+ 
+	$GVue
+({  
+Vue
+;
+	}
+}
+
+64 
+VALUE
+ 
+	$GVue_t
+({  
+Vue_t
+;
+	}
+}
+
+65 
+	$SInvsi
+(){
+Invsi
+ = 
+ue
+;
+	}
+}
+
+66 
+	$UnSInvsi
+(){
+Invsi
+ = 
+l
+;
+	}
+}
+
+67 
+	$SFg
+(
+FLAGS
+ 
+f
+{ 
+Fg
+.
+	`t
+(f); 
+	}
+}
+
+68 
+	$RetFg
+(
+FLAGS
+ 
+f
+{ 
+Fg
+.
+	`t
+(f); 
+	}
+}
+
+69 
+	$RetFg
+({ 
+Fg
+.
+	`t
+(); 
+	}
+}
+
+70 
+bo
+ 
+	$GFg
+(
+FLAGS
+ 
+f
+{  
+Fg
+[f]; 
+	}
+}
+
+71 
+bo
+ 
+	$Is_Invsi
+({  
+Invsi
+;
+	}
+}
+
+72 
+bo
+ 
+	$Is_Unique
+(
+j
+)
+
+74 
+i
+ = 0;< 
+j
+;i++) {
+
+75 i(
+	`F
+(
+i
+)->
+	`GID
+(=F(
+j
+)->GID() 
+l
+;
+
+77  
+ue
+;
+
+78 
+	}
+}
+
+81 
+	$SVue1
+({ 
+WeVue
+[0].
+	`t
+(); 
+	}
+}
+
+82 
+SVue1
+(
+bt
+<
+PNum
+> &
+vue
+{ 
+	gWeVue
+[0] = value; }
+
+83 
+	$SVue1
+(
+idx
+{ 
+WeVue
+[0].
+	`t
+(idx); 
+	}
+}
+
+84 
+	$RetVue1
+({ 
+WeVue
+[0].
+	`t
+(); 
+	}
+}
+
+85 
+	$RetVue1
+(
+idx
+{ 
+WeVue
+[0].
+	`t
+(idx); 
+	}
+}
+
+86 
+bo
+ 
+	$GVue1
+(
+idx
+{  
+WeVue
+[0][idx]; 
+	}
+}
+
+87 
+	gbt
+<
+	gPNum
+> 
+	$GVue1
+({  
+WeVue
+[0]; 
+	}
+}
+
+88 
+SVue2
+(
+bt
+<
+PNum
+> &
+vue
+{ 
+	gWeVue
+[1] = value; }
+
+89 
+	$SVue2
+({ 
+WeVue
+[1].
+	`t
+(); 
+	}
+}
+
+90 
+	$SVue2
+(
+idx
+{ 
+WeVue
+[1].
+	`t
+(idx); 
+	}
+}
+
+91 
+	$RetVue2
+({ 
+WeVue
+[1].
+	`t
+(); 
+	}
+}
+
+92 
+	$RetVue2
+(
+idx
+{ 
+WeVue
+[1].
+	`t
+(idx); 
+	}
+}
+
+93 
+bo
+ 
+	$GVue2
+(
+idx
+{  
+WeVue
+[1][idx]; 
+	}
+}
+
+94 
+	gbt
+<
+	gPNum
+> 
+	$GVue2
+({  
+WeVue
+[1]; 
+	}
+}
+
+95 
+	$PlInv
+() {
+
+96 
+bt
+<
+PNum
+> 
+	`vue
+(~
+WeVue
+[0]);
+
+97 
+WeVue
+[0] = ~WireValue[1];
+
+98 
+WeVue
+[1] = 
+vue
+;
+
+99 
+	}
+}
+
+100 
+	$SFauFg
+(
+idx
+{ 
+FauFg
+.
+	`t
+(idx); 
+	}
+}
+
+101 
+	$RetFauFg
+({ 
+FauFg
+.
+	`t
+(); 
+	}
+}
+
+102 
+bo
+ 
+	$GFauFg
+(
+idx
+{  
+FauFg
+[idx]; 
+	}
+}
+
+103 
+	$SFauFeVue
+() {
+
+104 
+Vue
+) {
+
+105 
+S1
+:
+
+106 
+WeVue
+[0].
+	`t
+(); WireValue[1].set();
+
+108 
+S0
+:
+
+109 
+WeVue
+[0].
+	`t
+(); WireValue[1].reset();
+
+111 
+X
+:
+
+112 
+WeVue
+[0].
+	`t
+(); WeVue[1].
+	`t
+();
+
+116 
+	}
+}
+
+118 
+	$SWeVue
+(
+i
+{ 
+WeVue
+[i].
+	`t
+(); 
+	}
+}
+
+119 
+SWeVue
+(
+i
+, 
+bt
+<
+PNum
+> &
+vue
+{ 
+	gWeVue
+[i] = value; }
+
+120 
+	$SWeVue
+(
+i
+, 
+idx
+{ 
+WeVue
+[i].
+	`t
+(idx); 
+	}
+}
+
+121 
+	$RetWeVue
+(
+i
+{ 
+WeVue
+[i].
+	`t
+(); 
+	}
+}
+
+122 
+	$RetWeVue
+(
+i
+, 
+idx
+{ 
+WeVue
+[i].
+	`t
+(idx); 
+	}
+}
+
+123 
+bo
+ 
+	$GWeVue
+(
+i
+, 
+idx
+{  
+WeVue
+[i][idx]; 
+	}
+}
+
+124 
+	gbt
+<
+	gPNum
+> 
+	$GWeVue
+(
+i
+{  
+WeVue
+[i]; 
+	}
+}
+
+125 
+	$GTnsi_t
+(){
+
+126 i(
+Vue
+==
+S0
+){
+
+127 if(
+Vue_t
+==
+S0
+) {  '0'; }
+
+131 if(
+Vue_t
+==
+S0
+) {  'F'; }
+
+134 
+	}
+}
+
+135 
+	$GTnsi
+(){
+
+136 i(
+Vue_t
+==
+S0
+){
+
+137 if(
+Vue
+==
+S0
+) {  '0'; }
+
+141 if(
+Vue
+==
+S0
+) {  'F'; }
+
+144 
+	}
+}
+
+	@hash.h
+
+16 #ide
+HASH_H
+
+
+17 
+	#HASH_H
+
+
+	)
+
+19 
+	~<rg
+>
+
+20 
+	~<ve
+>
+
+21 
+	~<li
+>
+
+22 
+	~<ioam
+>
+
+23 
+	~<dlib.h
+>
+
+24 
+usg
+ 
+mea
+ 
+	gd
+;
+
+26 as
+	cS_hash_funi
+
+
+28 
+	mpublic
+:
+
+29 
+	$
+((c 
+rg
+ 
+id
+, c 
+size
+)
+
+31 
+ba_key
+, 
+tmp_key
+, 
+ch
+;
+
+32 
+ba_key
+ = 
+tmp_key
+ = 
+ch
+ = 0;
+
+33 
+i
+ = 0; i < 
+id
+.
+	`size
+(); i++) {
+
+34 
+tmp_key
+ =mp_key << 8;
+
+35 
+tmp_key
+ +
+id
+[
+i
+];
+
+36 i(
+i
+ % 4 == 3) {
+
+37 
+ba_key
+ +
+tmp_key
+;
+
+38 
+tmp_key
+ = 0;
+
+41 
+ba_key
+ +
+tmp_key
+;
+
+42  (
+ba_key
+ % 
+size
+);
+
+44 
+	}
+};
+
+46 
+	gme
+ <
+ass
+ 
+	gVALUE
+>
+
+47 as
+	cPd
+
+
+49 
+	mpublic
+:
+
+50 
+vtu
+ 
+bo
+ 
+	$
+((c 
+VALUE
+ 
+v
+) const
+
+54 
+	}
+};
+
+56 
+	gme
+ <
+ass
+ 
+	gVALUE
+>
+
+57 as
+	cExec
+
+
+59 
+	mpublic
+:
+
+60 
+vtu
+ 
+	$
+((
+VALUE
+ 
+v
+) = 0;
+
+63 
+me
+ <
+ass
+ 
+KEY
+, cs
+VALUE
+, cs
+HASH_FUNCTION
+>
+
+64 as
+	cCache
+
+
+66 
+_size
+;
+
+67 
+ve
+<
+
+<
+KEY
+, 
+VALUE
+> > 
+buck
+;
+
+68 
+public
+:
+
+69 
+	$Cache
+(
+s
+ = 8191: 
+	$buck
+(
+s
+{ 
+_size
+ = s; }
+
+70 ~
+	$Cache
+({
+	}
+}
+
+71 
+	$size
+({  
+_size
+; 
+	}
+}
+
+72 
+	$wre
+(c 
+KEY
+ 
+k
+, c 
+VALUE
+ 
+v
+)
+
+74 
+HASH_FUNCTION
+ 
+f
+;
+
+75 
+buck
+[
+	`f
+(
+k
+, 
+_size
+)] = 
+	`make_
+(k, 
+v
+);
+
+76 
+	}
+}
+
+77 
+VALUE
+ 
+	$ad
+(
+KEY
+ 
+k
+)
+
+79 
+HASH_FUNCTION
+ 
+f
+; 
+b
+ = 
+	`f
+(
+k
+, 
+_size
+);
+
+80 i(
+buck
+[
+b
+].
+f
+ =
+k
+ (buck[b].
+cd
+);
+
+81  
+	`VALUE
+(0);
+
+82 
+	}
+}
+
+83 
+VALUE
+ 
+	g
+[] (
+KEY
+ 
+	gk
+)
+
+85 
+HASH_FUNCTION
+ 
+	gf
+; 
+	gb
+ = 
+f
+(
+k
+, 
+_size
+);
+
+86 i(
+	gbuck
+[
+b
+].
+	gf
+ =
+k
+ (
+buck
+[b].
+cd
+);
+
+87  
+VALUE
+(0);
+
+89 
+	gVALUE
+& 
+	g
+[] (
+	gb
+{  (
+	gbuck
+[
+b
+].
+	gcd
+); }
+
+90 
+	$n
+({ 
+buck
+.
+	`a
+(buck.
+	`beg
+(), buck.
+	`d
+()); 
+	}
+}
+
+93 
+	gme
+ <
+ass
+ 
+	gKEY
+, cs
+	gVALUE
+, cs
+	gHASH_FUNCTION
+>
+
+94 as
+	cHash
+
+
+96 
+	m_size
+;
+
+97 
+	mnum_of_nodes
+;
+
+98 
+	mve
+<
+	mli
+<
+	m
+<
+	mKEY
+, 
+	mVALUE
+> > > 
+	mbuck
+;
+
+99 
+	mpublic
+:
+
+100 
+	$Hash
+(
+s
+ = 509)
+
+102 
+_size
+ = 
+s
+; 
+num_of_nodes
+ = 0;
+
+103 
+buck
+.
+	`rve
+(
+_size
+);
+
+104 
+i
+ = 0; i < 
+_size
+; i++{ 
+li
+<
+
+<
+KEY
+, 
+VALUE
+> > 
+l
+; 
+buck
+.
+	`push_back
+(l); }
+
+106 ~
+	$Hash
+({ 
+buck
+.
+	`a
+(buck.
+	`beg
+(), buck.
+	`d
+()); 
+	}
+}
+
+107 
+	$size
+({  
+_size
+; 
+	}
+}
+
+108 
+	$nodes
+({  
+num_of_nodes
+; 
+	}
+}
+
+109 
+buck_num
+(
+KEY
+ 
+k
+);
+
+110 
+_
+(
+KEY
+ 
+k
+);
+
+112 
+
+(c 
+KEY
+ 
+k
+, c 
+VALUE
+ 
+v
+);
+
+113 
+fd_
+(c 
+b
+, c 
+KEY
+ 
+k
+, c 
+VALUE
+ 
+v
+);
+
+114 
+is_memb
+(
+KEY
+ 
+k
+);
+
+115 
+VALUE
+ 
+p_vue
+(
+KEY
+ 
+k
+);
+
+116 
+VALUE
+ 
+g_vue
+(
+KEY
+ 
+k
+);
+
+117 
+VALUE
+ 
+g_vue
+(
+KEY
+ 
+k
+, 
+b
+);
+
+118 
+move
+(
+KEY
+ 
+k
+);
+
+119 
+move_if
+(
+Pd
+<
+VALUE
+> *
+ed
+);
+
+120 
+move_if_
+(
+Pd
+<
+VALUE
+> *
+ed
+, 
+Exec
+<VALUE> *
+e
+);
+
+121 
+n
+();
+
+122 
+VALUE
+ 
+	g
+[] (
+KEY
+ 
+	gk
+);
+
+124 
+	gli
+<
+	g
+<
+	gKEY
+, 
+	gVALUE
+> >& 
+	g
+[] (
+	gb
+{  
+	gbuck
+[
+b
+]; }
+
+125 
+f_ch_exec
+(
+Exec
+<
+VALUE
+> *
+e
+);
+
+126 
+f_ch_if_
+(
+Pd
+<
+VALUE
+> *, 
+Exec
+<VALUE> *, Exec<VALUE> *);
+
+129 
+	gme
+ <
+ass
+ 
+	gKEY
+, cs
+	gVALUE
+, cs
+	gHASH_FUNCTION
+>
+
+131 
+	gHash
+<
+	gKEY
+, 
+	gVALUE
+, 
+	gHASH_FUNCTION
+>::
+	$buck_num
+(
+KEY
+ 
+k
+)
+
+133 
+HASH_FUNCTION
+ 
+f
+;
+
+134 
+b
+ = 
+	`f
+(
+k
+, 
+_size
+);
+
+135 i(
+buck
+[
+b
+].
+	`emy
+())
+
+137 
+tyme
+ 
+li
+<
+
+<
+KEY
+, 
+VALUE
+> >::
+
+ 
+li
+ = 
+buck
+[
+b
+].
+	`beg
+();
+
+138 
+tyme
+ 
+li
+<
+
+<
+KEY
+, 
+VALUE
+> >::
+
+ 
+
+ = 
+buck
+[
+b
+].
+	`d
+();
+
+139 ; 
+li
+ !
+
+;i++)
+
+140 i((*
+li
+).
+f
+ =
+k
+)
+
+141  
+b
+;
+
+143 
+	}
+}
+
+145 
+	gme
+ <
+ass
+ 
+	gKEY
+, cs
+	gVALUE
+, cs
+	gHASH_FUNCTION
+>
+
+147 
+	gHash
+<
+	gKEY
+, 
+	gVALUE
+, 
+	gHASH_FUNCTION
+>::
+	$_
+(
+KEY
+ 
+k
+)
+
+149 
+HASH_FUNCTION
+ 
+f
+;
+
+150 
+b
+ = 
+	`f
+(
+k
+, 
+_size
+);
+
+151 i(
+buck
+[
+b
+].
+	`emy
+())
+
+152  
+b
+;
+
+153 
+tyme
+ 
+li
+<
+
+<
+KEY
+, 
+VALUE
+> >::
+
+ 
+li
+ = 
+buck
+[
+b
+].
+	`beg
+();
+
+154 
+tyme
+ 
+li
+<
+
+<
+KEY
+, 
+VALUE
+> >::
+
+ 
+
+ = 
+buck
+[
+b
+].
+	`d
+();
+
+155 ; 
+li
+ !
+
+;i++)
+
+156 i((*
+li
+).
+f
+ =
+k
+)
+
+158  
+b
+;
+
+159 
+	}
+}
+
+161 
+	gme
+ <
+ass
+ 
+	gKEY
+, cs
+	gVALUE
+, cs
+	gHASH_FUNCTION
+>
+
+163 
+	gHash
+<
+	gKEY
+, 
+	gVALUE
+, 
+	gHASH_FUNCTION
+>::
+	$
+(c 
+KEY
+ 
+k
+, c 
+VALUE
+ 
+v
+)
+
+165 
+HASH_FUNCTION
+ 
+f
+;
+
+166 
+b
+ = 
+	`f
+(
+k
+, 
+_size
+);
+
+167 i(
+buck
+[
+b
+].
+	`emy
+()) {
+
+168 
+buck
+[
+b
+].
+	`push_back
+(
+	`make_
+(
+k
+, 
+v
+));
+
+169 
+num_of_nodes
+++;
+
+172 
+tyme
+ 
+li
+<
+
+<
+KEY
+, 
+VALUE
+> >::
+
+ 
+li
+ = 
+buck
+[
+b
+].
+	`beg
+();
+
+173 
+tyme
+ 
+li
+<
+
+<
+KEY
+, 
+VALUE
+> >::
+
+ 
+
+ = 
+buck
+[
+b
+].
+	`d
+();
+
+174 ; 
+li
+ !
+
+;i++)
+
+175 i((*
+li
+).
+f
+ =
+k
+) {
+
+179 
+
+<
+KEY
+, 
+VALUE
+> 
+p
+ = 
+	`make_
+(
+k
+, 
+v
+);
+
+180 
+buck
+[
+b
+].
+	`push_back
+(
+p
+);
+
+181 
+num_of_nodes
+++;
+
+183 
+	}
+}
+
+185 
+	gme
+ <
+ass
+ 
+	gKEY
+, cs
+	gVALUE
+, cs
+	gHASH_FUNCTION
+>
+
+186 
+	gHash
+<
+	gKEY
+, 
+	gVALUE
+, 
+	gHASH_FUNCTION
+>::
+fd_
+
+
+187 (c 
+b
+, c 
+KEY
+ 
+	gk
+, c 
+VALUE
+ 
+	gv
+)
+
+189 
+	g
+<
+	gKEY
+, 
+	gVALUE
+> 
+	gp
+ = 
+make_
+(
+k
+, 
+v
+);
+
+190 
+	gbuck
+[
+b
+].
+push_back
+(
+p
+);
+
+191 
+	gnum_of_nodes
+++;
+
+194 
+	gme
+ <
+ass
+ 
+	gKEY
+, cs
+	gVALUE
+, cs
+	gHASH_FUNCTION
+>
+
+196 
+	gHash
+<
+	gKEY
+, 
+	gVALUE
+, 
+	gHASH_FUNCTION
+>::
+	$is_memb
+(
+KEY
+ 
+k
+)
+
+198 
+HASH_FUNCTION
+ 
+f
+;
+
+199 
+b
+ = 
+	`f
+(
+k
+, 
+_size
+);
+
+200 i(
+buck
+[
+b
+].
+	`emy
+())
+
+202 
+tyme
+ 
+li
+<
+
+<
+KEY
+, 
+VALUE
+> >::
+
+ 
+li
+ = 
+buck
+[
+b
+].
+	`beg
+();
+
+203 
+tyme
+ 
+li
+<
+
+<
+KEY
+, 
+VALUE
+> >::
+
+ 
+
+ = 
+buck
+[
+b
+].
+	`d
+();
+
+204 ; 
+li
+ !
+
+;i++)
+
+205 i((*
+li
+).
+f
+ =
+k
+)
+
+208 
+	}
+}
+
+210 
+	gme
+ <
+ass
+ 
+	gKEY
+, cs
+	gVALUE
+, cs
+	gHASH_FUNCTION
+>
+
+211 
+VALUE
+
+
+212 
+	gHash
+<
+	gKEY
+, 
+	gVALUE
+, 
+	gHASH_FUNCTION
+>::
+	$p_vue
+(
+KEY
+ 
+k
+)
+
+214 
+HASH_FUNCTION
+ 
+f
+;
+
+215 
+b
+ = 
+	`f
+(
+k
+, 
+_size
+);
+
+216 i(
+buck
+[
+b
+].
+	`emy
+())
+
+217  
+	`VALUE
+(0);
+
+218 
+tyme
+ 
+li
+<
+
+<
+KEY
+, 
+VALUE
+> >::
+
+ 
+li
+ = 
+buck
+[
+b
+].
+	`beg
+();
+
+219 
+tyme
+ 
+li
+<
+
+<
+KEY
+, 
+VALUE
+> >::
+
+ 
+
+ = 
+buck
+[
+b
+].
+	`d
+();
+
+220 ; 
+li
+ !
+
+;i++)
+
+221 i((*
+li
+).
+f
+ =
+k
+) {
+
+222 
+VALUE
+ 
+v
+ = (*
+li
+).
+cd
+;
+
+223 
+buck
+[
+b
+].
+	`a
+(
+li
+);
+
+224 
+num_of_nodes
+--;
+
+225  
+v
+;
+
+227  
+	`VALUE
+(0);
+
+228 
+	}
+}
+
+230 
+	gme
+ <
+ass
+ 
+	gKEY
+, cs
+	gVALUE
+, cs
+	gHASH_FUNCTION
+>
+
+231 
+VALUE
+
+
+232 
+	gHash
+<
+	gKEY
+, 
+	gVALUE
+, 
+	gHASH_FUNCTION
+>::
+	$g_vue
+(
+KEY
+ 
+k
+)
+
+234 
+HASH_FUNCTION
+ 
+f
+;
+
+235 
+b
+ = 
+	`f
+(
+k
+, 
+_size
+);
+
+236 i(
+buck
+[
+b
+].
+	`emy
+())
+
+237  
+	`VALUE
+(0);
+
+238 
+tyme
+ 
+li
+<
+
+<
+KEY
+, 
+VALUE
+> >::
+
+ 
+li
+ = 
+buck
+[
+b
+].
+	`beg
+();
+
+239 
+tyme
+ 
+li
+<
+
+<
+KEY
+, 
+VALUE
+> >::
+
+ 
+
+ = 
+buck
+[
+b
+].
+	`d
+();
+
+240 ; 
+li
+ !
+
+;i++)
+
+241 i((*
+li
+).
+f
+ =
+k
+)
+
+242  (*
+li
+).
+cd
+;
+
+243  
+	`VALUE
+(0);
+
+244 
+	}
+}
+
+246 
+	gme
+ <
+ass
+ 
+	gKEY
+, cs
+	gVALUE
+, cs
+	gHASH_FUNCTION
+>
+
+247 
+VALUE
+
+
+248 
+	gHash
+<
+	gKEY
+, 
+	gVALUE
+, 
+	gHASH_FUNCTION
+>::
+	$g_vue
+(
+KEY
+ 
+k
+, 
+b
+)
+
+250 i(
+b
+ >
+_size
+ || b < 0) {
+
+251 
+
+ << "E : buckumb ouonge!!" << 
+dl
+;
+
+252 
+	`ex
+( -1);
+
+254 i(
+buck
+[
+b
+].
+	`emy
+())
+
+255  
+	`VALUE
+(0);
+
+256 
+tyme
+ 
+li
+<
+
+<
+KEY
+, 
+VALUE
+> >::
+
+ 
+li
+ = 
+buck
+[
+b
+].
+	`beg
+();
+
+257 
+tyme
+ 
+li
+<
+
+<
+KEY
+, 
+VALUE
+> >::
+
+ 
+
+ = 
+buck
+[
+b
+].
+	`d
+();
+
+258 ; 
+li
+ !
+
+;i++)
+
+259 i((*
+li
+).
+f
+ =
+k
+)
+
+260  (*
+li
+).
+cd
+;
+
+261  
+	`VALUE
+(0);
+
+262 
+	}
+}
+
+264 
+	gme
+ <
+ass
+ 
+	gKEY
+, cs
+	gVALUE
+, cs
+	gHASH_FUNCTION
+>
+
+266 
+	gHash
+<
+	gKEY
+, 
+	gVALUE
+, 
+	gHASH_FUNCTION
+>::
+	$move
+(
+KEY
+ 
+k
+)
+
+268 
+HASH_FUNCTION
+ 
+f
+;
+
+269 
+b
+ = 
+	`f
+(
+k
+, 
+_size
+);
+
+270 i(
+buck
+[
+b
+].
+	`emy
+())
+
+272 
+tyme
+ 
+li
+<
+
+<
+KEY
+, 
+VALUE
+> >::
+
+ 
+li
+ = 
+buck
+[
+b
+].
+	`beg
+();
+
+273 
+tyme
+ 
+li
+<
+
+<
+KEY
+, 
+VALUE
+> >::
+
+ 
+
+ = 
+buck
+[
+b
+].
+	`d
+();
+
+274 ; 
+li
+ !
+
+;i++)
+
+275 i((*
+li
+).
+f
+ =
+k
+) {
+
+276 
+buck
+[
+b
+].
+	`a
+(
+li
+);
+
+277 
+num_of_nodes
+--;
+
+281 
+	}
+}
+
+283 
+	gme
+ <
+ass
+ 
+	gKEY
+, cs
+	gVALUE
+, cs
+	gHASH_FUNCTION
+>
+
+285 
+	gHash
+<
+	gKEY
+, 
+	gVALUE
+, 
+	gHASH_FUNCTION
+>::
+move_if
+(
+Pd
+<
+VALUE
+> *
+ed
+)
+
+287 
+t_moved
+ = 0;
+
+288 
+	gb
+ = 0; b < 
+	g_size
+; b++) {
+
+289 i(
+	gbuck
+[
+b
+].
+emy
+()) ;
+
+290 
+tyme
+ 
+	gli
+<
+	g
+<
+	gKEY
+, 
+	gVALUE
+> >::
+
+ 
+li
+ = 
+buck
+[
+b
+].
+beg
+();
+
+291 
+tyme
+ 
+	gli
+<
+	g
+<
+	gKEY
+, 
+	gVALUE
+> >::
+
+ 
+
+ = 
+buck
+[
+b
+].
+d
+();
+
+292 
+	gli
+ !
+
+) {
+
+293 
+tyme
+ 
+li
+<
+
+<
+KEY
+, 
+VALUE
+> >::
+
+ 
+this_li
+ = 
+li
+++;
+
+294 i((*
+	ged
+)((*
+	gthis_li
+).
+	gcd
+)) {
+
+295 
+	gbuck
+[
+b
+].
+a
+(
+this_li
+);
+
+296 
+	gnum_of_nodes
+--;
+
+297 
+	gt_moved
+++;
+
+301  
+	gt_moved
+;
+
+304 
+	gme
+ <
+ass
+ 
+	gKEY
+, cs
+	gVALUE
+, cs
+	gHASH_FUNCTION
+>
+
+306 
+	gHash
+<
+	gKEY
+, 
+	gVALUE
+, 
+	gHASH_FUNCTION
+>::
+move_if_
+
+
+307 (
+Pd
+<
+VALUE
+> *
+ed
+, 
+	gExec
+<
+	gVALUE
+> *
+	ge
+)
+
+309 
+	gt_moved
+ = 0;
+
+310 
+	gb
+ = 0; b < 
+	g_size
+; b++) {
+
+311 i(
+	gbuck
+[
+b
+].
+emy
+()) ;
+
+312 
+tyme
+ 
+	gli
+<
+	g
+<
+	gKEY
+, 
+	gVALUE
+> >::
+
+ 
+li
+ = 
+buck
+[
+b
+].
+beg
+();
+
+313 
+tyme
+ 
+	gli
+<
+	g
+<
+	gKEY
+, 
+	gVALUE
+> >::
+
+ 
+
+ = 
+buck
+[
+b
+].
+d
+();
+
+314 
+	gli
+ !
+
+) {
+
+315 
+tyme
+ 
+li
+<
+
+<
+KEY
+, 
+VALUE
+> >::
+
+ 
+this_li
+ = 
+li
+++;
+
+316 i((*
+	ged
+)((*
+	gthis_li
+).
+	gcd
+)) {
+
+317 
+	gbuck
+[
+b
+].
+a
+(
+this_li
+);
+
+318 
+	gnum_of_nodes
+--;
+
+319 
+	gt_moved
+++;
+
+321 (*
+	ge
+)((*
+	gthis_li
+).
+	gcd
+);
+
+324  
+	gt_moved
+;
+
+327 
+	gme
+ <
+ass
+ 
+	gKEY
+, cs
+	gVALUE
+, cs
+	gHASH_FUNCTION
+>
+
+329 
+	gHash
+<
+	gKEY
+, 
+	gVALUE
+, 
+	gHASH_FUNCTION
+>::
+	$n
+()
+
+331 
+num_of_nodes
+ = 0;
+
+332 
+b
+ = 0; b < 
+_size
+; b++)
+
+333 
+buck
+[
+b
+].
+	`a
+(buck[b].
+	`beg
+(), buck[b].
+	`d
+());
+
+334 
+	}
+}
+
+336 
+	gme
+ <
+ass
+ 
+	gKEY
+, cs
+	gVALUE
+, cs
+	gHASH_FUNCTION
+>
+
+337 
+VALUE
+
+
+338 
+	gHash
+<
+	gKEY
+, 
+	gVALUE
+, 
+	gHASH_FUNCTION
+>::
+
+[] (
+KEY
+ 
+k
+)
+
+340 
+HASH_FUNCTION
+ 
+f
+;
+
+341 
+	gb
+ = 
+f
+(
+k
+, 
+_size
+);
+
+342 i(
+	gbuck
+[
+b
+].
+emy
+())
+
+343  
+VALUE
+(0);
+
+344 
+tyme
+ 
+	gli
+<
+	g
+<
+	gKEY
+, 
+	gVALUE
+> >::
+
+ 
+li
+ = 
+buck
+[
+b
+].
+beg
+();
+
+345 
+tyme
+ 
+	gli
+<
+	g
+<
+	gKEY
+, 
+	gVALUE
+> >::
+
+ 
+
+ = 
+buck
+[
+b
+].
+d
+();
+
+346 ; 
+	gli
+ !
+
+;i++)
+
+347 i((*
+	gli
+).
+	gf
+ =
+k
+)
+
+348  (*
+li
+).
+cd
+;
+
+349  
+VALUE
+(0);
+
+352 
+	gme
+ <
+ass
+ 
+	gKEY
+, cs
+	gVALUE
+, cs
+	gHASH_FUNCTION
+>
+
+354 
+	gHash
+<
+	gKEY
+, 
+	gVALUE
+, 
+	gHASH_FUNCTION
+>::
+f_ch_exec
+(
+Exec
+<
+VALUE
+> *
+e
+)
+
+356 
+b
+ = 0; 
+	gb
+ < 
+	g_size
+; b++) {
+
+357 i(
+	gbuck
+[
+b
+].
+emy
+()) ;
+
+358 
+tyme
+ 
+	gli
+<
+	g
+<
+	gKEY
+, 
+	gVALUE
+> >::
+
+ 
+li
+ = 
+buck
+[
+b
+].
+beg
+();
+
+359 
+tyme
+ 
+	gli
+<
+	g
+<
+	gKEY
+, 
+	gVALUE
+> >::
+
+ 
+
+ = 
+buck
+[
+b
+].
+d
+();
+
+360 
+	gli
+ !
+
+)
+
+361 (*
+e
+)((*
+li
+++).
+cd
+);
+
+365 
+	gme
+ <
+ass
+ 
+	gKEY
+, cs
+	gVALUE
+, cs
+	gHASH_FUNCTION
+>
+
+367 
+	gHash
+<
+	gKEY
+, 
+	gVALUE
+, 
+	gHASH_FUNCTION
+>::
+f_ch_if_
+
+
+368 (
+Pd
+<
+VALUE
+> *
+ed
+, 
+	gExec
+<
+	gVALUE
+> *
+	gif_e
+, Exec<VALUE> *
+	g_e
+)
+
+370 
+	gb
+ = 0; b < 
+	g_size
+; b++) {
+
+371 i(
+	gbuck
+[
+b
+].
+emy
+()) ;
+
+372 
+tyme
+ 
+	gli
+<
+	g
+<
+	gKEY
+, 
+	gVALUE
+> >::
+
+ 
+li
+ = 
+buck
+[
+b
+].
+beg
+();
+
+373 
+tyme
+ 
+	gli
+<
+	g
+<
+	gKEY
+, 
+	gVALUE
+> >::
+
+ 
+
+ = 
+buck
+[
+b
+].
+d
+();
+
+374 
+	gli
+ !
+
+) {
+
+375 i((*
+ed
+)((*
+li
+).
+cd
+))
+
+376 (*
+if_e
+)((*
+li
+++).
+cd
+);
+
+377 (*
+	g_e
+)((*
+	gli
+++).
+	gcd
+);
+
+	@readcircuit.tab.h
+
+33 #ide
+YY_YY_READCIRCUIT_TAB_H_INCLUDED
+
+
+34 
+	#YY_YY_READCIRCUIT_TAB_H_INCLUDED
+
+
+	)
+
+36 #ide
+YYDEBUG
+
+
+37 
+	#YYDEBUG
+ 1
+
+	)
+
+39 #i
+YYDEBUG
+
+
+40 
+yydebug
+;
+
+44 #ide
+YYTOKENTYPE
+
+
+45 
+	#YYTOKENTYPE
+
+
+	)
+
+46 
+	eyytokty
+
+
+48 
+	mGINPUT
+ = 258,
+
+49 
+	mGOUTPUT
+ = 259,
+
+50 
+	mGDFF
+ = 260,
+
+51 
+	mGNOT
+ = 261,
+
+52 
+	mGBUF
+ = 262,
+
+53 
+	mGAND
+ = 263,
+
+54 
+	mGOR
+ = 264,
+
+55 
+	mGNAND
+ = 265,
+
+56 
+	mGNOR
+ = 266,
+
+57 
+	mEOLINE
+ = 267,
+
+58 
+	mLPAR
+ = 268,
+
+59 
+	mRPAR
+ = 269,
+
+60 
+	mCOMMA
+ = 270,
+
+61 
+	mEQUAL
+ = 271,
+
+62 
+	mNAMESTRING
+ = 272
+
+67 #i! 
+defed
+ 
+YYSTYPE
+ && ! defed 
+YYSTYPE_IS_DECLARED
+
+
+69 
+	uYYSTYPE
+
+
+73 
+	mnum
+;
+
+74 
+	mr
+[256];
+
+75 
+GATEFUNC
+ 
+	mfunc
+;
+
+80 
+YYSTYPE
+ 
+	tYYSTYPE
+;
+
+81 
+	#YYSTYPE_IS_TRIVIAL
+ 1
+
+	)
+
+82 
+	#YYSTYPE_IS_DECLARED
+ 1
+
+	)
+
+86 
+YYSTYPE
+ 
+yylv
+;
+
+88 
+yyr
+ ();
+
+	@tfault.h
+
+1 #ide
+TFAULT_H
+
+
+2 
+	#TFAULT_H
+
+
+	)
+
+3 
+	~"ge.h
+"
+
+5 as
+	cTFAULT
+
+
+7 
+	mive
+:
+
+8 
+VALUE
+ 
+Vue
+;
+
+9 
+GATE
+* 
+	mIut
+;
+
+10 
+GATE
+* 
+	mOuut
+;
+
+12 
+bo
+ 
+	mBnch
+;
+
+13 
+	mEqvFauNum
+;
+
+14 
+FAULT_STATUS
+ 
+	mStus
+;
+
+15 
+	mpublic
+:
+
+16 
+	$TFAULT
+(
+GATE
+* 
+gr
+, GATE* 
+ogr
+, 
+VALUE
+ 
+vue
+): 
+	`Vue
+(vue), 
+	`Iut
+(gptr),
+
+17 
+	`Ouut
+(
+ogr
+), 
+	`Bnch
+(
+l
+), 
+	`EqvFauNum
+(1), 
+	$Stus
+(
+UNKNOWN
+) {}
+
+18 ~
+	$TFAULT
+({
+	}
+}
+
+19 
+VALUE
+ 
+	$GVue
+({  
+Vue
+; 
+	}
+}
+
+20 
+GATE
+* 
+	$GIutGe
+({  
+Iut
+; 
+	}
+}
+
+21 
+GATE
+* 
+	$GOuutGe
+({  
+Ouut
+; 
+	}
+}
+
+22 
+	$SBnch
+(
+bo
+ 
+b
+{ 
+Bnch
+ = b; 
+	}
+}
+
+23 
+bo
+ 
+	$Is_Bnch
+({  
+Bnch
+; 
+	}
+}
+
+24 
+	$SEqvFauNum
+(
+n
+{ 
+EqvFauNum
+ =; 
+	}
+}
+
+25 
+	$IncEqvFauNum
+({ ++
+EqvFauNum
+; 
+	}
+}
+
+26 
+	$GEqvFauNum
+({  
+EqvFauNum
+; 
+	}
+}
+
+27 
+	$SStus
+(
+FAULT_STATUS
+ 
+us
+{ 
+Stus
+ = stus; 
+	}
+}
+
+28 
+FAULT_STATUS
+ 
+	$GStus
+({  
+Stus
+; 
+	}
+}
+
+	@typeemu.h
+
+2 
+	~<rg
+>
+
+3 
+	~<ve
+>
+
+4 
+	~<li
+>
+
+6 
+	eVALUE
+ {
+	mS0
+, 
+	mS1
+, 
+	mX
+, 
+	mD
+, 
+	mB
+, 
+	mILLIGAL
+};
+
+8 
+	eGATEFUNC
+ {
+	mG_PI
+, 
+	mG_PO
+, 
+	mG_PPI
+, 
+	mG_PPO
+, 
+	mG_NOT
+, 
+	mG_AND
+, 
+	mG_NAND
+, 
+	mG_OR
+, 
+	mG_NOR
+, 
+	mG_DFF
+, 
+	mG_BUF
+, 
+	mG_BAD
+ };
+
+9 
+	eFLAGS
+ { 
+	mALL_ASSIGNED
+, 
+	mMARKED
+, 
+	mFAULT_INJECTED
+, 
+	mFAULTY
+, 
+	mSCHEDULED
+, 
+	mOUTPUT
+, 
+	mNumFgs
+ };
+
+10 
+	eATPG_STATUS
+ { 
+	mTRUE
+, 
+	mCONFLICT
+, 
+	mFALSE
+ };
+
+11 
+	eFAULT_STATUS
+ { 
+	mUNKNOWN
+, 
+	mDETECTED
+, 
+	mREDUNDANT
+, 
+	mABORT
+ };
+
+14 c 
+VALUE
+ 
+	gCV
+[] = {
+X
+, X, X, X, X, 
+S0
+, S0, 
+S1
+, S1, X, X, X};
+
+16 c 
+VALUE
+ 
+	gNCV
+[] = {
+X
+, X, X, X, X, 
+S1
+, S1, 
+S0
+, S0, X, X, X};
+
+18 c 
+	gPNum
+ = 16;
+
+20 c 
+VALUE
+ 
+	gNTab
+[] = {
+S1
+, 
+S0
+, 
+X
+, 
+B
+, 
+D
+, 
+ILLIGAL
+};
+
+22 c 
+VALUE
+ 
+	gAndTab
+[5][5] = { { 
+S0
+, S0, S0, S0, S0 },
+
+23 { 
+S0
+, 
+S1
+, 
+X
+, 
+D
+, 
+B
+ },
+
+24 { 
+S0
+, 
+X
+, X, X, X },
+
+25 { 
+S0
+, 
+D
+, 
+X
+, D, S0 },
+
+26 { 
+S0
+, 
+B
+, 
+X
+, S0, B } };
+
+28 c 
+VALUE
+ 
+	gOrTab
+[5][5] = { { 
+S0
+, 
+S1
+, 
+X
+, 
+D
+, 
+B
+ },
+
+29 { 
+S1
+, S1, S1, S1, S1 },
+
+30 { 
+X
+, 
+S1
+, X, X, X },
+
+31 { 
+D
+, 
+S1
+, 
+X
+, D, S1 },
+
+32 { 
+B
+, 
+S1
+, 
+X
+, S1, B } };
+
+34 c 
+VALUE
+ 
+	gXTab
+[5][5] = { { 
+S0
+, 
+S1
+, 
+X
+, 
+D
+, 
+B
+ },
+
+35 { 
+S1
+, 
+S0
+, 
+X
+, 
+B
+, 
+D
+ },
+
+36 { 
+X
+, X, X, X, X },
+
+37 { 
+D
+, 
+B
+, 
+X
+, 
+S0
+, 
+S1
+ },
+
+38 { 
+B
+, 
+D
+, 
+X
+, 
+S1
+, 
+S0
+ } };
+
+40 c 
+VALUE
+ 
+	gEqvTab
+[5][5] = { { 
+S1
+, 
+S0
+, 
+X
+, 
+B
+, 
+D
+ },
+
+41 { 
+S0
+, 
+S1
+, 
+X
+, 
+D
+, 
+B
+ },
+
+42 { 
+X
+, X, X, X, X },
+
+43 { 
+B
+, 
+D
+, 
+X
+, 
+S1
+, 
+S0
+ },
+
+44 { 
+D
+, 
+B
+, 
+X
+, 
+S0
+, 
+S1
+ } };
+
+	@/usr/include/stdlib.h
+
+22 #idef 
+_STDLIB_H
+
+
+24 
+	~<us.h
+>
+
+27 
+	#__ed_size_t
+
+
+	)
+
+28 #ide
+__ed_mloc_d_oc
+
+
+29 
+	#__ed_wch_t
+
+
+	)
+
+30 
+	#__ed_NULL
+
+
+	)
+
+32 
+	~<ddef.h
+>
+
+34 
+	g__BEGIN_DECLS
+
+
+36 #ide
+__ed_mloc_d_oc
+
+
+37 
+	#_STDLIB_H
+ 1
+
+	)
+
+39 #i(
+defed
+ 
+__USE_XOPEN
+ || defed 
+__USE_XOPEN2K8
+&& !defed 
+_SYS_WAIT_H
+
+
+41 
+	~<bs/waags.h
+>
+
+42 
+	~<bs/waus.h
+>
+
+44 #ifde
+__USE_MISC
+
+
+49 #i
+defed
+ 
+__GNUC__
+ && !defed 
+__lulus
+
+
+50 
+	#__WAIT_INT
+(
+us
+) \
+
+51 (
+	`__exnsi__
+ (((uni { 
+	`__tyof
+(
+us
+
+__
+; 
+__i
+; }) \
+
+52 { .
+__
+ = (
+us
+}).
+__i
+))
+
+	)
+
+54 
+	#__WAIT_INT
+(
+us
+(*(*&(us))
+
+	)
+
+62 #i!
+defed
+ 
+__GNUC__
+ || __GNUC__ < 2 || defed 
+__lulus
+
+
+63 
+	#__WAIT_STATUS
+ *
+
+	)
+
+64 
+	#__WAIT_STATUS_DEFN
+ *
+
+	)
+
+69 
+wa
+ *
+	m__ur
+;
+
+70 *
+	m__
+;
+
+71 } 
+	t__WAIT_STATUS
+ 
+	t__ibu__
+ ((
+	t__t_uni__
+));
+
+72 
+	#__WAIT_STATUS_DEFN
+ *
+
+	)
+
+77 
+	#__WAIT_INT
+(
+us
+(us)
+
+	)
+
+78 
+	#__WAIT_STATUS
+ *
+
+	)
+
+79 
+	#__WAIT_STATUS_DEFN
+ *
+
+	)
+
+84 
+	#WEXITSTATUS
+(
+us
+
+	`__WEXITSTATUS
+ (
+	`__WAIT_INT
+ (us))
+
+	)
+
+85 
+	#WTERMSIG
+(
+us
+
+	`__WTERMSIG
+ (
+	`__WAIT_INT
+ (us))
+
+	)
+
+86 
+	#WSTOPSIG
+(
+us
+
+	`__WSTOPSIG
+ (
+	`__WAIT_INT
+ (us))
+
+	)
+
+87 
+	#WIFEXITED
+(
+us
+
+	`__WIFEXITED
+ (
+	`__WAIT_INT
+ (us))
+
+	)
+
+88 
+	#WIFSIGNALED
+(
+us
+
+	`__WIFSIGNALED
+ (
+	`__WAIT_INT
+ (us))
+
+	)
+
+89 
+	#WIFSTOPPED
+(
+us
+
+	`__WIFSTOPPED
+ (
+	`__WAIT_INT
+ (us))
+
+	)
+
+90 #ifde
+__WIFCONTINUED
+
+
+91 
+	#WIFCONTINUED
+(
+us
+
+	`__WIFCONTINUED
+ (
+	`__WAIT_INT
+ (us))
+
+	)
+
+95 
+__BEGIN_NAMESPACE_STD
+
+
+99 
+	mqu
+;
+
+100 
+	mm
+;
+
+101 } 
+	tdiv_t
+;
+
+104 #ide
+__ldiv_t_defed
+
+
+107 
+	mqu
+;
+
+108 
+	mm
+;
+
+109 } 
+	tldiv_t
+;
+
+110 
+	#__ldiv_t_defed
+ 1
+
+	)
+
+112 
+	g__END_NAMESPACE_STD
+
+
+114 #i
+defed
+ 
+__USE_ISOC99
+ && !defed 
+__div_t_defed
+
+
+115 
+__BEGIN_NAMESPACE_C99
+
+
+117 
+__exnsi__
+ struct
+
+119 
+	mqu
+;
+
+120 
+	mm
+;
+
+121 } 
+	tdiv_t
+;
+
+122 
+	#__div_t_defed
+ 1
+
+	)
+
+123 
+	g__END_NAMESPACE_C99
+
+
+128 
+	#RAND_MAX
+ 2147483647
+
+	)
+
+133 
+	#EXIT_FAILURE
+ 1
+
+	)
+
+134 
+	#EXIT_SUCCESS
+ 0
+
+	)
+
+138 
+	#MB_CUR_MAX
+ (
+	`__y_g_mb_cur_max
+ ())
+
+	)
+
+139 
+size_t
+ 
+	$__y_g_mb_cur_max
+ (
+__THROW
+ 
+__wur
+;
+
+142 
+__BEGIN_NAMESPACE_STD
+
+
+144 
+	$of
+ (c *
+__
+)
+
+145 
+__THROW
+ 
+__ibu_pu__
+ 
+	`__nnu
+ ((1)
+__wur
+;
+
+147 
+	$oi
+ (c *
+__
+)
+
+148 
+__THROW
+ 
+__ibu_pu__
+ 
+	`__nnu
+ ((1)
+__wur
+;
+
+150 
+	$
+ (c *
+__
+)
+
+151 
+__THROW
+ 
+__ibu_pu__
+ 
+	`__nnu
+ ((1)
+__wur
+;
+
+152 
+__END_NAMESPACE_STD
+
+
+154 #ifde
+__USE_ISOC99
+
+
+155 
+__BEGIN_NAMESPACE_C99
+
+
+157 
+__exnsi__
+ 
+	$l
+ (c *
+__
+)
+
+158 
+__THROW
+ 
+__ibu_pu__
+ 
+	`__nnu
+ ((1)
+__wur
+;
+
+159 
+__END_NAMESPACE_C99
+
+
+162 
+__BEGIN_NAMESPACE_STD
+
+
+164 
+	$od
+ (c *
+__ri
+ 
+__
+,
+
+165 **
+__ri
+ 
+__dr
+)
+
+166 
+__THROW
+ 
+	`__nnu
+ ((1));
+
+167 
+__END_NAMESPACE_STD
+
+
+169 #ifdef 
+__USE_ISOC99
+
+
+170 
+__BEGIN_NAMESPACE_C99
+
+
+172 
+	$of
+ (c *
+__ri
+ 
+__
+,
+
+173 **
+__ri
+ 
+__dr
+
+__THROW
+ 
+	`__nnu
+ ((1));
+
+175 
+	$d
+ (c *
+__ri
+ 
+__
+,
+
+176 **
+__ri
+ 
+__dr
+)
+
+177 
+__THROW
+ 
+	`__nnu
+ ((1));
+
+178 
+__END_NAMESPACE_C99
+
+
+181 
+__BEGIN_NAMESPACE_STD
+
+
+183 
+	$
+ (c *
+__ri
+ 
+__
+,
+
+184 **
+__ri
+ 
+__dr
+, 
+__ba
+)
+
+185 
+__THROW
+ 
+	`__nnu
+ ((1));
+
+187 
+	$oul
+ (c *
+__ri
+ 
+__
+,
+
+188 **
+__ri
+ 
+__dr
+, 
+__ba
+)
+
+189 
+__THROW
+ 
+	`__nnu
+ ((1));
+
+190 
+__END_NAMESPACE_STD
+
+
+192 #ifde
+__USE_MISC
+
+
+194 
+__exnsi__
+
+
+195 
+	$oq
+ (c *
+__ri
+ 
+__
+,
+
+196 **
+__ri
+ 
+__dr
+, 
+__ba
+)
+
+197 
+__THROW
+ 
+	`__nnu
+ ((1));
+
+199 
+__exnsi__
+
+
+200 
+	$ouq
+ (c *
+__ri
+ 
+__
+,
+
+201 **
+__ri
+ 
+__dr
+, 
+__ba
+)
+
+202 
+__THROW
+ 
+	`__nnu
+ ((1));
+
+205 #ifde
+__USE_ISOC99
+
+
+206 
+__BEGIN_NAMESPACE_C99
+
+
+208 
+__exnsi__
+
+
+209 
+	$l
+ (c *
+__ri
+ 
+__
+,
+
+210 **
+__ri
+ 
+__dr
+, 
+__ba
+)
+
+211 
+__THROW
+ 
+	`__nnu
+ ((1));
+
+213 
+__exnsi__
+
+
+214 
+	$ou
+ (c *
+__ri
+ 
+__
+,
+
+215 **
+__ri
+ 
+__dr
+, 
+__ba
+)
+
+216 
+__THROW
+ 
+	`__nnu
+ ((1));
+
+217 
+__END_NAMESPACE_C99
+
+
+221 #ifde
+__USE_GNU
+
+
+235 
+	~<xlo.h
+>
+
+239 
+	$_l
+ (c *
+__ri
+ 
+__
+,
+
+240 **
+__ri
+ 
+__dr
+, 
+__ba
+,
+
+241 
+__lo_t
+ 
+__loc
+
+__THROW
+ 
+	`__nnu
+ ((1, 4));
+
+243 
+	$oul_l
+ (c *
+__ri
+ 
+__
+,
+
+244 **
+__ri
+ 
+__dr
+,
+
+245 
+__ba
+, 
+__lo_t
+ 
+__loc
+)
+
+246 
+__THROW
+ 
+	`__nnu
+ ((1, 4));
+
+248 
+__exnsi__
+
+
+249 
+	$l_l
+ (c *
+__ri
+ 
+__
+,
+
+250 **
+__ri
+ 
+__dr
+, 
+__ba
+,
+
+251 
+__lo_t
+ 
+__loc
+)
+
+252 
+__THROW
+ 
+	`__nnu
+ ((1, 4));
+
+254 
+__exnsi__
+
+
+255 
+	$ou_l
+ (c *
+__ri
+ 
+__
+,
+
+256 **
+__ri
+ 
+__dr
+,
+
+257 
+__ba
+, 
+__lo_t
+ 
+__loc
+)
+
+258 
+__THROW
+ 
+	`__nnu
+ ((1, 4));
+
+260 
+	$od_l
+ (c *
+__ri
+ 
+__
+,
+
+261 **
+__ri
+ 
+__dr
+, 
+__lo_t
+ 
+__loc
+)
+
+262 
+__THROW
+ 
+	`__nnu
+ ((1, 3));
+
+264 
+	$of_l
+ (c *
+__ri
+ 
+__
+,
+
+265 **
+__ri
+ 
+__dr
+, 
+__lo_t
+ 
+__loc
+)
+
+266 
+__THROW
+ 
+	`__nnu
+ ((1, 3));
+
+268 
+	$d_l
+ (c *
+__ri
+ 
+__
+,
+
+269 **
+__ri
+ 
+__dr
+,
+
+270 
+__lo_t
+ 
+__loc
+)
+
+271 
+__THROW
+ 
+	`__nnu
+ ((1, 3));
+
+275 #ifde
+__USE_EXTERN_INLINES
+
+
+276 
+__BEGIN_NAMESPACE_STD
+
+
+277 
+__ex_le
+ 
+
+278 
+	`__NTH
+ (
+	$oi
+ (c *
+__
+))
+
+280  (
+	`
+ (
+__
+, (**
+NULL
+, 10);
+
+281 
+	}
+}
+
+282 
+__ex_le
+ 
+
+283 
+__NTH
+ (
+	$
+ (c *
+__
+))
+
+285  
+	`
+ (
+__
+, (**
+NULL
+, 10);
+
+286 
+	}
+}
+
+287 
+	g__END_NAMESPACE_STD
+
+
+289 #ifde
+__USE_ISOC99
+
+
+290 
+__BEGIN_NAMESPACE_C99
+
+
+291 
+__exnsi__
+ 
+__ex_le
+ 
+
+292 
+__NTH
+ (
+	$l
+ (c *
+__
+))
+
+294  
+	`l
+ (
+__
+, (**
+NULL
+, 10);
+
+295 
+	}
+}
+
+296 
+	g__END_NAMESPACE_C99
+
+
+301 #i
+defed
+ 
+__USE_MISC
+ || defed 
+__USE_XOPEN_EXTENDED
+
+
+305 *
+	$l64a
+ (
+__n
+
+__THROW
+ 
+__wur
+;
+
+308 
+	$a64l
+ (c *
+__s
+)
+
+309 
+__THROW
+ 
+__ibu_pu__
+ 
+	`__nnu
+ ((1)
+__wur
+;
+
+313 #i
+defed
+ 
+__USE_MISC
+ || defed 
+__USE_XOPEN_EXTENDED
+
+
+314 
+	~<sys/tys.h
+>
+
+321 
+	$ndom
+ (
+__THROW
+;
+
+324 
+	$dom
+ (
+__ed
+
+__THROW
+;
+
+330 *
+	$e
+ (
+__ed
+, *
+__ebuf
+,
+
+331 
+size_t
+ 
+__
+
+__THROW
+ 
+	`__nnu
+ ((2));
+
+335 *
+	$te
+ (*
+__ebuf
+
+__THROW
+ 
+	`__nnu
+ ((1));
+
+338 #ifde
+__USE_MISC
+
+
+343 
+	sndom_da
+
+
+345 
+t32_t
+ *
+
+;
+
+346 
+t32_t
+ *
+
+;
+
+347 
+t32_t
+ *
+e
+;
+
+348 
+nd_ty
+;
+
+349 
+nd_deg
+;
+
+350 
+nd_p
+;
+
+351 
+t32_t
+ *
+d_r
+;
+
+354 
+	$ndom_r
+ (
+ndom_da
+ *
+__ri
+ 
+__buf
+,
+
+355 
+t32_t
+ *
+__ri
+ 
+__su
+
+__THROW
+ 
+	`__nnu
+ ((1, 2));
+
+357 
+	$dom_r
+ (
+__ed
+, 
+ndom_da
+ *
+__buf
+)
+
+358 
+__THROW
+ 
+	`__nnu
+ ((2));
+
+360 
+	$e_r
+ (
+__ed
+, *
+__ri
+ 
+__ebuf
+,
+
+361 
+size_t
+ 
+__
+,
+
+362 
+ndom_da
+ *
+__ri
+ 
+__buf
+)
+
+363 
+__THROW
+ 
+	`__nnu
+ ((2, 4));
+
+365 
+	$te_r
+ (*
+__ri
+ 
+__ebuf
+,
+
+366 
+ndom_da
+ *
+__ri
+ 
+__buf
+)
+
+367 
+__THROW
+ 
+	`__nnu
+ ((1, 2));
+
+372 
+__BEGIN_NAMESPACE_STD
+
+
+374 
+	$nd
+ (
+__THROW
+;
+
+376 
+	$d
+ (
+__ed
+
+__THROW
+;
+
+377 
+__END_NAMESPACE_STD
+
+
+379 #ifde
+__USE_POSIX
+
+
+381 
+	$nd_r
+ (*
+__ed
+
+__THROW
+;
+
+385 #i
+defed
+ 
+__USE_MISC
+ || defed 
+__USE_XOPEN
+
+
+389 
+	$dnd48
+ (
+__THROW
+;
+
+390 
+	$d48
+ (
+__xsubi
+[3]
+__THROW
+ 
+	`__nnu
+ ((1));
+
+393 
+	$d48
+ (
+__THROW
+;
+
+394 
+	$d48
+ (
+__xsubi
+[3])
+
+395 
+__THROW
+ 
+	`__nnu
+ ((1));
+
+398 
+	$mnd48
+ (
+__THROW
+;
+
+399 
+	$jnd48
+ (
+__xsubi
+[3])
+
+400 
+__THROW
+ 
+	`__nnu
+ ((1));
+
+403 
+	$d48
+ (
+__edv
+
+__THROW
+;
+
+404 *
+	$ed48
+ (
+__ed16v
+[3])
+
+405 
+__THROW
+ 
+	`__nnu
+ ((1));
+
+406 
+	$lcg48
+ (
+__m
+[7]
+__THROW
+ 
+	`__nnu
+ ((1));
+
+408 #ifde
+__USE_MISC
+
+
+412 
+	sdnd48_da
+
+
+414 
+__x
+[3];
+
+415 
+__d_x
+[3];
+
+416 
+__c
+;
+
+417 
+__
+;
+
+418 
+__exnsi__
+ 
+__a
+;
+
+423 
+	$dnd48_r
+ (
+dnd48_da
+ *
+__ri
+ 
+__bufr
+,
+
+424 *
+__ri
+ 
+__su
+
+__THROW
+ 
+	`__nnu
+ ((1, 2));
+
+425 
+	$d48_r
+ (
+__xsubi
+[3],
+
+426 
+dnd48_da
+ *
+__ri
+ 
+__bufr
+,
+
+427 *
+__ri
+ 
+__su
+
+__THROW
+ 
+	`__nnu
+ ((1, 2));
+
+430 
+	$d48_r
+ (
+dnd48_da
+ *
+__ri
+ 
+__bufr
+,
+
+431 *
+__ri
+ 
+__su
+)
+
+432 
+__THROW
+ 
+	`__nnu
+ ((1, 2));
+
+433 
+	$d48_r
+ (
+__xsubi
+[3],
+
+434 
+dnd48_da
+ *
+__ri
+ 
+__bufr
+,
+
+435 *
+__ri
+ 
+__su
+)
+
+436 
+__THROW
+ 
+	`__nnu
+ ((1, 2));
+
+439 
+	$mnd48_r
+ (
+dnd48_da
+ *
+__ri
+ 
+__bufr
+,
+
+440 *
+__ri
+ 
+__su
+)
+
+441 
+__THROW
+ 
+	`__nnu
+ ((1, 2));
+
+442 
+	$jnd48_r
+ (
+__xsubi
+[3],
+
+443 
+dnd48_da
+ *
+__ri
+ 
+__bufr
+,
+
+444 *
+__ri
+ 
+__su
+)
+
+445 
+__THROW
+ 
+	`__nnu
+ ((1, 2));
+
+448 
+	$d48_r
+ (
+__edv
+, 
+dnd48_da
+ *
+__bufr
+)
+
+449 
+__THROW
+ 
+	`__nnu
+ ((2));
+
+451 
+	$ed48_r
+ (
+__ed16v
+[3],
+
+452 
+dnd48_da
+ *
+__bufr
+
+__THROW
+ 
+	`__nnu
+ ((1, 2));
+
+454 
+	$lcg48_r
+ (
+__m
+[7],
+
+455 
+dnd48_da
+ *
+__bufr
+)
+
+456 
+__THROW
+ 
+	`__nnu
+ ((1, 2));
+
+462 #ide
+__mloc_d_oc_defed
+
+
+463 
+	#__mloc_d_oc_defed
+
+
+	)
+
+464 
+__BEGIN_NAMESPACE_STD
+
+
+466 *
+	$mloc
+ (
+size_t
+ 
+__size
+
+__THROW
+ 
+__ibu_mloc__
+ 
+__wur
+;
+
+468 *
+	$oc
+ (
+size_t
+ 
+__nmemb
+, size_
+__size
+)
+
+469 
+__THROW
+ 
+__ibu_mloc__
+ 
+__wur
+;
+
+470 
+__END_NAMESPACE_STD
+
+
+473 #ide
+__ed_mloc_d_oc
+
+
+474 
+__BEGIN_NAMESPACE_STD
+
+
+480 *
+	$loc
+ (*
+__r
+, 
+size_t
+ 
+__size
+)
+
+481 
+__THROW
+ 
+__ibu_wn_unud_su__
+;
+
+483 
+	$
+ (*
+__r
+
+__THROW
+;
+
+484 
+__END_NAMESPACE_STD
+
+
+486 #ifdef 
+__USE_MISC
+
+
+488 
+	$c
+ (*
+__r
+
+__THROW
+;
+
+491 #ifde
+__USE_MISC
+
+
+492 
+	~<lo.h
+>
+
+495 #i(
+defed
+ 
+__USE_XOPEN_EXTENDED
+ && !defed 
+__USE_XOPEN2K
+) \
+
+496 || 
+defed
+ 
+__USE_MISC
+
+
+498 *
+	$vloc
+ (
+size_t
+ 
+__size
+
+__THROW
+ 
+__ibu_mloc__
+ 
+__wur
+;
+
+501 #ifde
+__USE_XOPEN2K
+
+
+503 
+	$posix_memign
+ (**
+__memr
+, 
+size_t
+ 
+__ignmt
+, size_
+__size
+)
+
+504 
+__THROW
+ 
+	`__nnu
+ ((1)
+__wur
+;
+
+507 #ifde
+__USE_ISOC11
+
+
+509 *
+	$igd_loc
+ (
+size_t
+ 
+__ignmt
+, size_
+__size
+)
+
+510 
+__THROW
+ 
+__ibu_mloc__
+ 
+	`__ibu_loc_size__
+ ((2)
+__wur
+;
+
+513 
+__BEGIN_NAMESPACE_STD
+
+
+515 
+	$abt
+ (
+__THROW
+ 
+	`__ibu__
+ ((
+__nu__
+));
+
+519 
+	`ex
+ ((*
+__func
+()
+__THROW
+ 
+	`__nnu
+ ((1));
+
+521 #i
+defed
+ 
+__USE_ISOC11
+ || defed 
+__USE_ISOCXX11
+
+
+523 #ifde
+__lulus
+
+
+524 "C++" 
+	`_quick_ex
+ ((*
+__func
+) ())
+
+525 
+__THROW
+ 
+	`__asm
+ ("_quick_ex"
+	`__nnu
+ ((1));
+
+527 
+	`_quick_ex
+ ((*
+__func
+()
+__THROW
+ 
+	`__nnu
+ ((1));
+
+530 
+__END_NAMESPACE_STD
+
+
+532 #ifdef 
+__USE_MISC
+
+
+535 
+	`_ex
+ ((*
+__func
+(
+__us
+, *
+__g
+), *__arg)
+
+536 
+__THROW
+ 
+	`__nnu
+ ((1));
+
+539 
+__BEGIN_NAMESPACE_STD
+
+
+543 
+	$ex
+ (
+__us
+
+__THROW
+ 
+	`__ibu__
+ ((
+__nu__
+));
+
+545 #i
+defed
+ 
+__USE_ISOC11
+ || defed 
+__USE_ISOCXX11
+
+
+549 
+	$quick_ex
+ (
+__us
+
+__THROW
+ 
+	`__ibu__
+ ((
+__nu__
+));
+
+551 
+__END_NAMESPACE_STD
+
+
+553 #ifde
+__USE_ISOC99
+
+
+554 
+__BEGIN_NAMESPACE_C99
+
+
+557 
+	$_Ex
+ (
+__us
+
+__THROW
+ 
+	`__ibu__
+ ((
+__nu__
+));
+
+558 
+__END_NAMESPACE_C99
+
+
+562 
+__BEGIN_NAMESPACE_STD
+
+
+564 *
+	$gv
+ (c *
+__me
+
+__THROW
+ 
+	`__nnu
+ ((1)
+__wur
+;
+
+565 
+__END_NAMESPACE_STD
+
+
+567 #ifde
+__USE_GNU
+
+
+570 *
+	$cu_gv
+ (c *
+__me
+)
+
+571 
+__THROW
+ 
+	`__nnu
+ ((1)
+__wur
+;
+
+574 #i
+defed
+ 
+__USE_MISC
+ || defed 
+__USE_XOPEN
+
+
+578 
+	$punv
+ (*
+__rg
+
+__THROW
+ 
+	`__nnu
+ ((1));
+
+581 #ifde
+__USE_XOPEN2K
+
+
+584 
+	$nv
+ (c *
+__me
+, c *
+__vue
+, 
+__a
+)
+
+585 
+__THROW
+ 
+	`__nnu
+ ((2));
+
+588 
+	$unnv
+ (c *
+__me
+
+__THROW
+ 
+	`__nnu
+ ((1));
+
+591 #ifdef 
+__USE_MISC
+
+
+595 
+	$nv
+ (
+__THROW
+;
+
+599 #i
+defed
+ 
+__USE_MISC
+ \
+
+600 || (
+defed
+ 
+__USE_XOPEN_EXTENDED
+ && !defed 
+__USE_XOPEN2K8
+)
+
+606 *
+	$mkmp
+ (*
+__me
+
+__THROW
+ 
+	`__nnu
+ ((1));
+
+609 #i
+defed
+ 
+__USE_XOPEN_EXTENDED
+ || defed 
+__USE_XOPEN2K8
+
+
+618 #ide
+__USE_FILE_OFFSET64
+
+
+619 
+	$mkemp
+ (*
+__me
+
+	`__nnu
+ ((1)
+__wur
+;
+
+621 #ifde
+__REDIRECT
+
+
+622 
+	`__REDIRECT
+ (
+mkemp
+, (*
+__me
+), 
+mkemp64
+)
+
+623 
+	`__nnu
+ ((1)
+__wur
+;
+
+625 
+	#mkemp
+ 
+mkemp64
+
+
+	)
+
+628 #ifde
+__USE_LARGEFILE64
+
+
+629 
+	$mkemp64
+ (*
+__me
+
+	`__nnu
+ ((1)
+__wur
+;
+
+633 #ifde
+__USE_MISC
+
+
+640 #ide
+__USE_FILE_OFFSET64
+
+
+641 
+	$mkemps
+ (*
+__me
+, 
+__suffixn
+
+	`__nnu
+ ((1)
+__wur
+;
+
+643 #ifde
+__REDIRECT
+
+
+644 
+	`__REDIRECT
+ (
+mkemps
+, (*
+__me
+, 
+__suffixn
+),
+
+645 
+mkemps64
+
+	`__nnu
+ ((1)
+__wur
+;
+
+647 
+	#mkemps
+ 
+mkemps64
+
+
+	)
+
+650 #ifde
+__USE_LARGEFILE64
+
+
+651 
+	$mkemps64
+ (*
+__me
+, 
+__suffixn
+)
+
+652 
+	`__nnu
+ ((1)
+__wur
+;
+
+656 #ifde
+__USE_XOPEN2K8
+
+
+662 *
+	$mkdmp
+ (*
+__me
+
+__THROW
+ 
+	`__nnu
+ ((1)
+__wur
+;
+
+665 #ifde
+__USE_GNU
+
+
+672 #ide
+__USE_FILE_OFFSET64
+
+
+673 
+	$mkoemp
+ (*
+__me
+, 
+__ags
+
+	`__nnu
+ ((1)
+__wur
+;
+
+675 #ifde
+__REDIRECT
+
+
+676 
+	`__REDIRECT
+ (
+mkoemp
+, (*
+__me
+, 
+__ags
+), 
+mkoemp64
+)
+
+677 
+	`__nnu
+ ((1)
+__wur
+;
+
+679 
+	#mkoemp
+ 
+mkoemp64
+
+
+	)
+
+682 #ifde
+__USE_LARGEFILE64
+
+
+683 
+	$mkoemp64
+ (*
+__me
+, 
+__ags
+
+	`__nnu
+ ((1)
+__wur
+;
+
+692 #ide
+__USE_FILE_OFFSET64
+
+
+693 
+	$mkoemps
+ (*
+__me
+, 
+__suffixn
+, 
+__ags
+)
+
+694 
+	`__nnu
+ ((1)
+__wur
+;
+
+696 #ifde
+__REDIRECT
+
+
+697 
+	`__REDIRECT
+ (
+mkoemps
+, (*
+__me
+, 
+__suffixn
+,
+
+698 
+__ags
+), 
+mkoemps64
+)
+
+699 
+	`__nnu
+ ((1)
+__wur
+;
+
+701 
+	#mkoemps
+ 
+mkoemps64
+
+
+	)
+
+704 #ifde
+__USE_LARGEFILE64
+
+
+705 
+	$mkoemps64
+ (*
+__me
+, 
+__suffixn
+, 
+__ags
+)
+
+706 
+	`__nnu
+ ((1)
+__wur
+;
+
+711 
+__BEGIN_NAMESPACE_STD
+
+
+716 
+	$syem
+ (c *
+__commd
+
+__wur
+;
+
+717 
+__END_NAMESPACE_STD
+
+
+720 #ifdef 
+__USE_GNU
+
+
+723 *
+	$nilize_fe_me
+ (c *
+__me
+)
+
+724 
+__THROW
+ 
+	`__nnu
+ ((1)
+__wur
+;
+
+727 #i
+defed
+ 
+__USE_MISC
+ || defed 
+__USE_XOPEN_EXTENDED
+
+
+733 *
+	$th
+ (c *
+__ri
+ 
+__me
+,
+
+734 *
+__ri
+ 
+__sved
+
+__THROW
+ 
+__wur
+;
+
+739 #ide
+__COMPAR_FN_T
+
+
+740 
+	#__COMPAR_FN_T
+
+
+	)
+
+741 (*
+	t__comr__t
+) (const *, const *);
+
+743 #ifdef 
+__USE_GNU
+
+
+744 
+__comr__t
+ 
+	tcomris__t
+;
+
+747 #ifde
+__USE_GNU
+
+
+748 (*
+	t__comr_d__t
+) (const *, const *, *);
+
+751 
+__BEGIN_NAMESPACE_STD
+
+
+754 *
+	$bch
+ (c *
+__key
+, c *
+__ba
+,
+
+755 
+size_t
+ 
+__nmemb
+, size_
+__size
+, 
+__comr__t
+ 
+__comr
+)
+
+756 
+	`__nnu
+ ((1, 2, 5)
+__wur
+;
+
+758 #ifde
+__USE_EXTERN_INLINES
+
+
+759 
+	~<bs/dlib-bch.h
+>
+
+764 
+	$qst
+ (*
+__ba
+, 
+size_t
+ 
+__nmemb
+, size_
+__size
+,
+
+765 
+__comr__t
+ 
+__comr
+
+	`__nnu
+ ((1, 4));
+
+766 #ifde
+__USE_GNU
+
+
+767 
+	$qst_r
+ (*
+__ba
+, 
+size_t
+ 
+__nmemb
+, size_
+__size
+,
+
+768 
+__comr_d__t
+ 
+__comr
+, *
+__g
+)
+
+769 
+	`__nnu
+ ((1, 4));
+
+774 
+	$abs
+ (
+__x
+
+__THROW
+ 
+	`__ibu__
+ ((
+__c__
+)
+__wur
+;
+
+775 
+	$bs
+ (
+__x
+
+__THROW
+ 
+	`__ibu__
+ ((
+__c__
+)
+__wur
+;
+
+776 
+__END_NAMESPACE_STD
+
+
+778 #ifde
+__USE_ISOC99
+
+
+779 
+__exnsi__
+ 
+	$abs
+ (
+__x
+)
+
+780 
+__THROW
+ 
+	`__ibu__
+ ((
+__c__
+)
+__wur
+;
+
+784 
+__BEGIN_NAMESPACE_STD
+
+
+788 
+div_t
+ 
+	$div
+ (
+__num
+, 
+__dom
+)
+
+789 
+__THROW
+ 
+	`__ibu__
+ ((
+__c__
+)
+__wur
+;
+
+790 
+ldiv_t
+ 
+	$ldiv
+ (
+__num
+, 
+__dom
+)
+
+791 
+__THROW
+ 
+	`__ibu__
+ ((
+__c__
+)
+__wur
+;
+
+792 
+__END_NAMESPACE_STD
+
+
+794 #ifde
+__USE_ISOC99
+
+
+795 
+__BEGIN_NAMESPACE_C99
+
+
+796 
+__exnsi__
+ 
+div_t
+ 
+	$div
+ (
+__num
+,
+
+797 
+__dom
+)
+
+798 
+__THROW
+ 
+	`__ibu__
+ ((
+__c__
+)
+__wur
+;
+
+799 
+__END_NAMESPACE_C99
+
+
+803 #i(
+defed
+ 
+__USE_XOPEN_EXTENDED
+ && !defed 
+__USE_XOPEN2K8
+) \
+
+804 || 
+defed
+ 
+__USE_MISC
+
+
+811 *
+	$ecvt
+ (
+__vue
+, 
+__ndig
+, *
+__ri
+ 
+__det
+,
+
+812 *
+__ri
+ 
+__sign
+
+__THROW
+ 
+	`__nnu
+ ((3, 4)
+__wur
+;
+
+817 *
+	$fcvt
+ (
+__vue
+, 
+__ndig
+, *
+__ri
+ 
+__det
+,
+
+818 *
+__ri
+ 
+__sign
+
+__THROW
+ 
+	`__nnu
+ ((3, 4)
+__wur
+;
+
+823 *
+	$gcvt
+ (
+__vue
+, 
+__ndig
+, *
+__buf
+)
+
+824 
+__THROW
+ 
+	`__nnu
+ ((3)
+__wur
+;
+
+827 #ifde
+__USE_MISC
+
+
+829 *
+	$qecvt
+ (
+__vue
+, 
+__ndig
+,
+
+830 *
+__ri
+ 
+__det
+, *__ri 
+__sign
+)
+
+831 
+__THROW
+ 
+	`__nnu
+ ((3, 4)
+__wur
+;
+
+832 *
+	$qfcvt
+ (
+__vue
+, 
+__ndig
+,
+
+833 *
+__ri
+ 
+__det
+, *__ri 
+__sign
+)
+
+834 
+__THROW
+ 
+	`__nnu
+ ((3, 4)
+__wur
+;
+
+835 *
+	$qgcvt
+ (
+__vue
+, 
+__ndig
+, *
+__buf
+)
+
+836 
+__THROW
+ 
+	`__nnu
+ ((3)
+__wur
+;
+
+841 
+	$ecvt_r
+ (
+__vue
+, 
+__ndig
+, *
+__ri
+ 
+__det
+,
+
+842 *
+__ri
+ 
+__sign
+, *__ri 
+__buf
+,
+
+843 
+size_t
+ 
+__n
+
+__THROW
+ 
+	`__nnu
+ ((3, 4, 5));
+
+844 
+	$fcvt_r
+ (
+__vue
+, 
+__ndig
+, *
+__ri
+ 
+__det
+,
+
+845 *
+__ri
+ 
+__sign
+, *__ri 
+__buf
+,
+
+846 
+size_t
+ 
+__n
+
+__THROW
+ 
+	`__nnu
+ ((3, 4, 5));
+
+848 
+	$qecvt_r
+ (
+__vue
+, 
+__ndig
+,
+
+849 *
+__ri
+ 
+__det
+, *__ri 
+__sign
+,
+
+850 *
+__ri
+ 
+__buf
+, 
+size_t
+ 
+__n
+)
+
+851 
+__THROW
+ 
+	`__nnu
+ ((3, 4, 5));
+
+852 
+	$qfcvt_r
+ (
+__vue
+, 
+__ndig
+,
+
+853 *
+__ri
+ 
+__det
+, *__ri 
+__sign
+,
+
+854 *
+__ri
+ 
+__buf
+, 
+size_t
+ 
+__n
+)
+
+855 
+__THROW
+ 
+	`__nnu
+ ((3, 4, 5));
+
+859 
+__BEGIN_NAMESPACE_STD
+
+
+862 
+	$mbn
+ (c *
+__s
+, 
+size_t
+ 
+__n
+
+__THROW
+;
+
+865 
+	$mbtowc
+ (
+wch_t
+ *
+__ri
+ 
+__pwc
+,
+
+866 c *
+__ri
+ 
+__s
+, 
+size_t
+ 
+__n
+
+__THROW
+;
+
+869 
+	$womb
+ (*
+__s
+, 
+wch_t
+ 
+__wch
+
+__THROW
+;
+
+873 
+size_t
+ 
+	$mbowcs
+ (
+wch_t
+ *
+__ri
+ 
+__pwcs
+,
+
+874 c *
+__ri
+ 
+__s
+, 
+size_t
+ 
+__n
+
+__THROW
+;
+
+876 
+size_t
+ 
+	$wcombs
+ (*
+__ri
+ 
+__s
+,
+
+877 c 
+wch_t
+ *
+__ri
+ 
+__pwcs
+, 
+size_t
+ 
+__n
+)
+
+878 
+__THROW
+;
+
+879 
+__END_NAMESPACE_STD
+
+
+882 #ifde
+__USE_MISC
+
+
+887 
+	$mch
+ (c *
+__
+
+__THROW
+ 
+	`__nnu
+ ((1)
+__wur
+;
+
+891 #i
+defed
+ 
+__USE_XOPEN_EXTENDED
+ || defed 
+__USE_XOPEN2K8
+
+
+898 
+	$gsubt
+ (**
+__ri
+ 
+__tip
+,
+
+899 *c *
+__ri
+ 
+__toks
+,
+
+900 **
+__ri
+ 
+__vu
+)
+
+901 
+__THROW
+ 
+	`__nnu
+ ((1, 2, 3)
+__wur
+;
+
+905 #ifde
+__USE_XOPEN
+
+
+907 
+	$tkey
+ (c *
+__key
+
+__THROW
+ 
+	`__nnu
+ ((1));
+
+913 #ifde
+__USE_XOPEN2KXSI
+
+
+915 
+	$posix_
+ (
+__oag
+
+__wur
+;
+
+918 #ifde
+__USE_XOPEN
+
+
+923 
+	$g
+ (
+__fd
+
+__THROW
+;
+
+927 
+	$uock
+ (
+__fd
+
+__THROW
+;
+
+932 *
+	$ame
+ (
+__fd
+
+__THROW
+ 
+__wur
+;
+
+935 #ifde
+__USE_GNU
+
+
+939 
+	$ame_r
+ (
+__fd
+, *
+__buf
+, 
+size_t
+ 
+__bu
+)
+
+940 
+__THROW
+ 
+	`__nnu
+ ((2));
+
+943 
+	`g
+ ();
+
+946 #ifde
+__USE_MISC
+
+
+950 
+	$gldavg
+ (
+__ldavg
+[], 
+__m
+)
+
+951 
+__THROW
+ 
+	`__nnu
+ ((1));
+
+954 
+	~<bs/dlib-t.h
+>
+
+957 #i
+__USE_FORTIFY_LEVEL
+ > 0 && 
+defed
+ 
+__ftify_funi
+
+
+958 
+	~<bs/dlib.h
+>
+
+960 #ifde
+__LDBL_COMPAT
+
+
+961 
+	~<bs/dlib-ldbl.h
+>
+
+965 #unde
+__ed_mloc_d_oc
+
+
+967 
+__END_DECLS
+
+
+	@/usr/include/alloca.h
+
+18 #idef 
+_ALLOCA_H
+
+
+19 
+	#_ALLOCA_H
+ 1
+
+	)
+
+21 
+	~<us.h
+>
+
+23 
+	#__ed_size_t
+
+
+	)
+
+24 
+	~<ddef.h
+>
+
+26 
+	g__BEGIN_DECLS
+
+
+29 #unde
+lo
+
+
+32 *
+	$lo
+ (
+size_t
+ 
+__size
+
+__THROW
+;
+
+34 #ifdef 
+__GNUC__
+
+
+35 
+	#lo
+(
+size
+
+	`__but_lo
+ (size)
+
+	)
+
+38 
+__END_DECLS
+
+
+	@/usr/include/bits/stdlib-bsearch.h
+
+19 
+__ex_le
+ *
+
+20 
+	$bch
+ (c *
+__key
+, c *
+__ba
+, 
+size_t
+ 
+__nmemb
+, size_
+__size
+,
+
+21 
+__comr__t
+ 
+__comr
+)
+
+23 
+size_t
+ 
+__l
+, 
+__u
+, 
+__idx
+;
+
+24 c *
+__p
+;
+
+25 
+__comris
+;
+
+27 
+__l
+ = 0;
+
+28 
+__u
+ = 
+__nmemb
+;
+
+29 
+__l
+ < 
+__u
+)
+
+31 
+__idx
+ = (
+__l
+ + 
+__u
+) / 2;
+
+32 
+__p
+ = (*(((c *
+__ba
++ (
+__idx
+ * 
+__size
+));
+
+33 
+__comris
+ = (*
+__comr
+(
+__key
+, 
+__p
+);
+
+34 i(
+__comris
+ < 0)
+
+35 
+__u
+ = 
+__idx
+;
+
+36 i(
+__comris
+ > 0)
+
+37 
+__l
+ = 
+__idx
+ + 1;
+
+39  (*
+__p
+;
+
+42  
+NULL
+;
+
+43 
+	}
+}
+
+	@/usr/include/bits/stdlib-float.h
+
+19 #ide
+_STDLIB_H
+
+
+23 #ifde
+__USE_EXTERN_INLINES
+
+
+24 
+__BEGIN_NAMESPACE_STD
+
+
+25 
+__ex_le
+ 
+
+26 
+__NTH
+ (
+	$of
+ (c *
+__
+))
+
+28  
+	`od
+ (
+__
+, (**
+NULL
+);
+
+29 
+	}
+}
+
+30 
+	g__END_NAMESPACE_STD
+
+
+	@/usr/include/bits/stdlib-ldbl.h
+
+19 #ide
+_STDLIB_H
+
+
+23 #ifdef 
+__USE_ISOC99
+
+
+24 
+__BEGIN_NAMESPACE_C99
+
+
+25 
+	$__LDBL_REDIR1_DECL
+ (
+d
+, 
+od
+)
+
+26 
+__END_NAMESPACE_C99
+
+
+29 #ifde
+__USE_GNU
+
+
+30 
+	$__LDBL_REDIR1_DECL
+ (
+d_l
+, 
+od_l
+)
+
+33 #ifde
+__USE_MISC
+
+
+34 
+	$__LDBL_REDIR1_DECL
+ (
+qecvt
+, 
+ecvt
+)
+
+35 
+	$__LDBL_REDIR1_DECL
+ (
+qfcvt
+, 
+fcvt
+)
+
+36 
+	$__LDBL_REDIR1_DECL
+ (
+qgcvt
+, 
+gcvt
+)
+
+37 
+	$__LDBL_REDIR1_DECL
+ (
+qecvt_r
+, 
+ecvt_r
+)
+
+38 
+	$__LDBL_REDIR1_DECL
+ (
+qfcvt_r
+, 
+fcvt_r
+)
+
+	@/usr/include/bits/stdlib.h
+
+19 #ide
+_STDLIB_H
+
+
+23 *
+	$__th_chk
+ (c *
+__ri
+ 
+__me
+,
+
+24 *
+__ri
+ 
+__sved
+,
+
+25 
+size_t
+ 
+__svedn
+
+__THROW
+ 
+__wur
+;
+
+26 *
+	`__REDIRECT_NTH
+ (
+__th_s
+,
+
+27 (c *
+__ri
+ 
+__me
+,
+
+28 *
+__ri
+ 
+__sved
+), 
+th
+
+__wur
+;
+
+29 *
+	`__REDIRECT_NTH
+ (
+__th_chk_wn
+,
+
+30 (c *
+__ri
+ 
+__me
+,
+
+31 *
+__ri
+ 
+__sved
+,
+
+32 
+size_t
+ 
+__svedn
+), 
+__th_chk
+
+__wur
+
+
+33 
+	`__wr
+ ("secondrgument ofealpath must beither NULL ort "
+
+36 
+__ftify_funi
+ 
+__wur
+ *
+
+37 
+	`__NTH
+ (
+	$th
+ (c *
+__ri
+ 
+__me
+, *__ri 
+__sved
+))
+
+39 i(
+	`__bos
+ (
+__sved
+!(
+size_t
+) -1)
+
+41 #i
+defed
+ 
+_LIBC_LIMITS_H_
+ && defed 
+PATH_MAX
+
+
+42 i(
+	`__bos
+ (
+__sved
+< 
+PATH_MAX
+)
+
+43  
+	`__th_chk_wn
+ (
+__me
+, 
+__sved
+, 
+	`__bos
+ (__resolved));
+
+45  
+	`__th_chk
+ (
+__me
+, 
+__sved
+, 
+	`__bos
+ (__resolved));
+
+48  
+	`__th_s
+ (
+__me
+, 
+__sved
+);
+
+49 
+	}
+}
+
+52 
+	$__ame_r_chk
+ (
+__fd
+, *
+__buf
+, 
+size_t
+ 
+__bu
+,
+
+53 
+size_t
+ 
+__l
+
+__THROW
+ 
+	`__nnu
+ ((2));
+
+54 
+	`__REDIRECT_NTH
+ (
+__ame_r_s
+, (
+__fd
+, *
+__buf
+,
+
+55 
+size_t
+ 
+__bu
+), 
+ame_r
+)
+
+56 
+	`__nnu
+ ((2));
+
+57 
+	`__REDIRECT_NTH
+ (
+__ame_r_chk_wn
+,
+
+58 (
+__fd
+, *
+__buf
+, 
+size_t
+ 
+__bu
+,
+
+59 
+size_t
+ 
+__l
+), 
+__ame_r_chk
+)
+
+60 
+	`__nnu
+ ((2)
+	`__wr
+ ("ptsname_r called with buflen biggerhan "
+
+63 
+__ftify_funi
+ 
+
+64 
+	`__NTH
+ (
+	$ame_r
+ (
+__fd
+, *
+__buf
+, 
+size_t
+ 
+__bu
+))
+
+66 i(
+	`__bos
+ (
+__buf
+!(
+size_t
+) -1)
+
+68 i(!
+	`__but_ct_p
+ (
+__bu
+))
+
+69  
+	`__ame_r_chk
+ (
+__fd
+, 
+__buf
+, 
+__bu
+, 
+	`__bos
+ (__buf));
+
+70 i(
+__bu
+ > 
+	`__bos
+ (
+__buf
+))
+
+71  
+	`__ame_r_chk_wn
+ (
+__fd
+, 
+__buf
+, 
+__bu
+, 
+	`__bos
+ (__buf));
+
+73  
+	`__ame_r_s
+ (
+__fd
+, 
+__buf
+, 
+__bu
+);
+
+74 
+	}
+}
+
+77 
+	$__womb_chk
+ (*
+__s
+, 
+wch_t
+ 
+__wch
+, 
+size_t
+ 
+__bu
+)
+
+78 
+__THROW
+ 
+__wur
+;
+
+79 
+	`__REDIRECT_NTH
+ (
+__womb_s
+, (*
+__s
+, 
+wch_t
+ 
+__wch
+),
+
+80 
+womb
+
+__wur
+;
+
+82 
+__ftify_funi
+ 
+__wur
+ 
+
+83 
+	`__NTH
+ (
+	$womb
+ (*
+__s
+, 
+wch_t
+ 
+__wch
+))
+
+88 
+	#__STDLIB_MB_LEN_MAX
+ 16
+
+	)
+
+89 #i
+defed
+ 
+MB_LEN_MAX
+ && MB_LEN_MAX !
+__STDLIB_MB_LEN_MAX
+
+
+92 i(
+	`__bos
+ (
+__s
+!(
+size_t
+-1 && 
+__STDLIB_MB_LEN_MAX
+ > __bos (__s))
+
+93  
+	`__womb_chk
+ (
+__s
+, 
+__wch
+, 
+	`__bos
+ (__s));
+
+94  
+	`__womb_s
+ (
+__s
+, 
+__wch
+);
+
+95 
+	}
+}
+
+98 
+size_t
+ 
+	$__mbowcs_chk
+ (
+wch_t
+ *
+__ri
+ 
+__d
+,
+
+99 c *
+__ri
+ 
+__c
+,
+
+100 
+size_t
+ 
+__n
+, size_
+__dn
+
+__THROW
+;
+
+101 
+size_t
+ 
+	`__REDIRECT_NTH
+ (
+__mbowcs_s
+,
+
+102 (
+wch_t
+ *
+__ri
+ 
+__d
+,
+
+103 c *
+__ri
+ 
+__c
+,
+
+104 
+size_t
+ 
+__n
+), 
+mbowcs
+);
+
+105 
+size_t
+ 
+	`__REDIRECT_NTH
+ (
+__mbowcs_chk_wn
+,
+
+106 (
+wch_t
+ *
+__ri
+ 
+__d
+,
+
+107 c *
+__ri
+ 
+__c
+,
+
+108 
+size_t
+ 
+__n
+, size_
+__dn
+), 
+__mbowcs_chk
+)
+
+109 
+	`__wr
+ ("mbstowcs called with dst buffer smallerhanen "
+
+112 
+__ftify_funi
+ 
+size_t
+
+
+113 
+	`__NTH
+ (
+	$mbowcs
+ (
+wch_t
+ *
+__ri
+ 
+__d
+, c *__ri 
+__c
+,
+
+114 
+size_t
+ 
+__n
+))
+
+116 i(
+	`__bos
+ (
+__d
+!(
+size_t
+) -1)
+
+118 i(!
+	`__but_ct_p
+ (
+__n
+))
+
+119  
+	`__mbowcs_chk
+ (
+__d
+, 
+__c
+, 
+__n
+,
+
+120 
+	`__bos
+ (
+__d
+/  (
+wch_t
+));
+
+122 i(
+__n
+ > 
+	`__bos
+ (
+__d
+/  (
+wch_t
+))
+
+123  
+	`__mbowcs_chk_wn
+ (
+__d
+, 
+__c
+, 
+__n
+,
+
+124 
+	`__bos
+ (
+__d
+/  (
+wch_t
+));
+
+126  
+	`__mbowcs_s
+ (
+__d
+, 
+__c
+, 
+__n
+);
+
+127 
+	}
+}
+
+130 
+size_t
+ 
+	$__wcombs_chk
+ (*
+__ri
+ 
+__d
+,
+
+131 c 
+wch_t
+ *
+__ri
+ 
+__c
+,
+
+132 
+size_t
+ 
+__n
+, size_
+__dn
+
+__THROW
+;
+
+133 
+size_t
+ 
+	`__REDIRECT_NTH
+ (
+__wcombs_s
+,
+
+134 (*
+__ri
+ 
+__d
+,
+
+135 c 
+wch_t
+ *
+__ri
+ 
+__c
+,
+
+136 
+size_t
+ 
+__n
+), 
+wcombs
+);
+
+137 
+size_t
+ 
+	`__REDIRECT_NTH
+ (
+__wcombs_chk_wn
+,
+
+138 (*
+__ri
+ 
+__d
+,
+
+139 c 
+wch_t
+ *
+__ri
+ 
+__c
+,
+
+140 
+size_t
+ 
+__n
+, size_
+__dn
+), 
+__wcombs_chk
+)
+
+141 
+	`__wr
+ ("wcstombs called with dst buffer smallerhanen");
+
+143 
+__ftify_funi
+ 
+size_t
+
+
+144 
+	`__NTH
+ (
+	$wcombs
+ (*
+__ri
+ 
+__d
+, c 
+wch_t
+ *__ri 
+__c
+,
+
+145 
+size_t
+ 
+__n
+))
+
+147 i(
+	`__bos
+ (
+__d
+!(
+size_t
+) -1)
+
+149 i(!
+	`__but_ct_p
+ (
+__n
+))
+
+150  
+	`__wcombs_chk
+ (
+__d
+, 
+__c
+, 
+__n
+, 
+	`__bos
+ (__dst));
+
+151 i(
+__n
+ > 
+	`__bos
+ (
+__d
+))
+
+152  
+	`__wcombs_chk_wn
+ (
+__d
+, 
+__c
+, 
+__n
+, 
+	`__bos
+ (__dst));
+
+154  
+	`__wcombs_s
+ (
+__d
+, 
+__c
+, 
+__n
+);
+
+155 
+	}
+}
+
+	@/usr/include/bits/waitflags.h
+
+19 #i!
+defed
+ 
+_SYS_WAIT_H
+ && !defed 
+_STDLIB_H
+
+
+25 
+	#WNOHANG
+ 1
+
+	)
+
+26 
+	#WUNTRACED
+ 2
+
+	)
+
+29 
+	#WSTOPPED
+ 2
+
+	)
+
+30 
+	#WEXITED
+ 4
+
+	)
+
+31 
+	#WCONTINUED
+ 8
+
+	)
+
+32 
+	#WNOWAIT
+ 0x01000000
+
+	)
+
+34 
+	#__WNOTHREAD
+ 0x20000000
+
+	)
+
+36 
+	#__WALL
+ 0x40000000
+
+	)
+
+37 
+	#__WCLONE
+ 0x80000000
+
+	)
+
+	@/usr/include/bits/waitstatus.h
+
+19 #i!
+defed
+ 
+_SYS_WAIT_H
+ && !defed 
+_STDLIB_H
+
+
+28 
+	#__WEXITSTATUS
+(
+us
+(((us& 0xff00>> 8)
+
+	)
+
+31 
+	#__WTERMSIG
+(
+us
+((us& 0x7f)
+
+	)
+
+34 
+	#__WSTOPSIG
+(
+us
+
+	`__WEXITSTATUS
+(us)
+
+	)
+
+37 
+	#__WIFEXITED
+(
+us
+(
+	`__WTERMSIG
+(us=0)
+
+	)
+
+40 
+	#__WIFSIGNALED
+(
+us
+) \
+
+41 (((sigd (((
+us
+& 0x7f+ 1>> 1> 0)
+
+	)
+
+44 
+	#__WIFSTOPPED
+(
+us
+(((us& 0xff=0x7f)
+
+	)
+
+48 #ifde
+WCONTINUED
+
+
+49 
+	#__WIFCONTINUED
+(
+us
+((us=
+__W_CONTINUED
+)
+
+	)
+
+53 
+	#__WCOREDUMP
+(
+us
+((us& 
+__WCOREFLAG
+)
+
+	)
+
+56 
+	#__W_EXITCODE
+(
+t
+, 
+sig
+(<< 8 | (sig))
+
+	)
+
+57 
+	#__W_STOPCODE
+(
+sig
+((sig<< 8 | 0x7f)
+
+	)
+
+58 
+	#__W_CONTINUED
+ 0xffff
+
+	)
+
+59 
+	#__WCOREFLAG
+ 0x80
+
+	)
+
+62 #ifdef 
+__USE_MISC
+
+
+64 
+	~<dn.h
+>
+
+66 
+	uwa
+
+
+68 
+	mw_us
+;
+
+71 #if 
+__BYTE_ORDER
+ =
+__LITTLE_ENDIAN
+
+
+72 
+	m__w_rmsig
+:7;
+
+73 
+	m__w_cedump
+:1;
+
+74 
+	m__w_tcode
+:8;
+
+77 #if 
+__BYTE_ORDER
+ =
+__BIG_ENDIAN
+
+
+79 
+	m__w_tcode
+:8;
+
+80 
+	m__w_cedump
+:1;
+
+81 
+	m__w_rmsig
+:7;
+
+83 } 
+	m__wa_rmed
+;
+
+86 #if 
+__BYTE_ORDER
+ =
+__LITTLE_ENDIAN
+
+
+87 
+	m__w_v
+:8;
+
+88 
+	m__w_sig
+:8;
+
+91 #if 
+__BYTE_ORDER
+ =
+__BIG_ENDIAN
+
+
+93 
+	m__w_sig
+:8;
+
+94 
+	m__w_v
+:8;
+
+96 } 
+	m__wa_d
+;
+
+99 
+	#w_rmsig
+ 
+__wa_rmed
+.
+__w_rmsig
+
+
+	)
+
+100 
+	#w_cedump
+ 
+__wa_rmed
+.
+__w_cedump
+
+
+	)
+
+101 
+	#w_tcode
+ 
+__wa_rmed
+.
+__w_tcode
+
+
+	)
+
+102 
+	#w_sig
+ 
+__wa_d
+.
+__w_sig
+
+
+	)
+
+103 
+	#w_v
+ 
+__wa_d
+.
+__w_v
+
+
+	)
+
+	@/usr/include/features.h
+
+18 #idef 
+_FEATURES_H
+
+
+19 
+	#_FEATURES_H
+ 1
+
+	)
+
+97 #unde
+__USE_ISOC11
+
+
+98 #unde
+__USE_ISOC99
+
+
+99 #unde
+__USE_ISOC95
+
+
+100 #unde
+__USE_ISOCXX11
+
+
+101 #unde
+__USE_POSIX
+
+
+102 #unde
+__USE_POSIX2
+
+
+103 #unde
+__USE_POSIX199309
+
+
+104 #unde
+__USE_POSIX199506
+
+
+105 #unde
+__USE_XOPEN
+
+
+106 #unde
+__USE_XOPEN_EXTENDED
+
+
+107 #unde
+__USE_UNIX98
+
+
+108 #unde
+__USE_XOPEN2K
+
+
+109 #unde
+__USE_XOPEN2KXSI
+
+
+110 #unde
+__USE_XOPEN2K8
+
+
+111 #unde
+__USE_XOPEN2K8XSI
+
+
+112 #unde
+__USE_LARGEFILE
+
+
+113 #unde
+__USE_LARGEFILE64
+
+
+114 #unde
+__USE_FILE_OFFSET64
+
+
+115 #unde
+__USE_MISC
+
+
+116 #unde
+__USE_ATFILE
+
+
+117 #unde
+__USE_GNU
+
+
+118 #unde
+__USE_REENTRANT
+
+
+119 #unde
+__USE_FORTIFY_LEVEL
+
+
+120 #unde
+__KERNEL_STRICT_NAMES
+
+
+124 #ide
+_LOOSE_KERNEL_NAMES
+
+
+125 
+	#__KERNEL_STRICT_NAMES
+
+
+	)
+
+135 #i
+defed
+ 
+__GNUC__
+ && defed 
+__GNUC_MINOR__
+
+
+136 
+	#__GNUC_PREREQ
+(
+maj
+, 
+m
+) \
+
+137 ((
+__GNUC__
+ << 16+ 
+__GNUC_MINOR__
+ >((
+maj
+<< 16+ (
+m
+))
+
+	)
+
+139 
+	#__GNUC_PREREQ
+(
+maj
+, 
+m
+0
+
+	)
+
+146 #i(
+defed
+ 
+_BSD_SOURCE
+ || defed 
+_SVID_SOURCE
+) \
+
+147 && !
+defed
+ 
+	g_DEFAULT_SOURCE
+
+
+149 #unde
+_DEFAULT_SOURCE
+
+
+150 
+	#_DEFAULT_SOURCE
+ 1
+
+	)
+
+154 #ifde
+_GNU_SOURCE
+
+
+155 #unde
+_ISOC95_SOURCE
+
+
+156 
+	#_ISOC95_SOURCE
+ 1
+
+	)
+
+157 #unde
+_ISOC99_SOURCE
+
+
+158 
+	#_ISOC99_SOURCE
+ 1
+
+	)
+
+159 #unde
+_ISOC11_SOURCE
+
+
+160 
+	#_ISOC11_SOURCE
+ 1
+
+	)
+
+161 #unde
+_POSIX_SOURCE
+
+
+162 
+	#_POSIX_SOURCE
+ 1
+
+	)
+
+163 #unde
+_POSIX_C_SOURCE
+
+
+164 
+	#_POSIX_C_SOURCE
+ 200809L
+
+	)
+
+165 #unde
+_XOPEN_SOURCE
+
+
+166 
+	#_XOPEN_SOURCE
+ 700
+
+	)
+
+167 #unde
+_XOPEN_SOURCE_EXTENDED
+
+
+168 
+	#_XOPEN_SOURCE_EXTENDED
+ 1
+
+	)
+
+169 #unde
+_LARGEFILE64_SOURCE
+
+
+170 
+	#_LARGEFILE64_SOURCE
+ 1
+
+	)
+
+171 #unde
+_DEFAULT_SOURCE
+
+
+172 
+	#_DEFAULT_SOURCE
+ 1
+
+	)
+
+173 #unde
+_ATFILE_SOURCE
+
+
+174 
+	#_ATFILE_SOURCE
+ 1
+
+	)
+
+179 #i(
+defed
+ 
+_DEFAULT_SOURCE
+ \
+
+180 || (!
+defed
+ 
+	g__STRICT_ANSI__
+ \
+
+181 && !
+defed
+ 
+	g_ISOC99_SOURCE
+ \
+
+182 && !
+defed
+ 
+	g_POSIX_SOURCE
+ && !defed 
+	g_POSIX_C_SOURCE
+ \
+
+183 && !
+defed
+ 
+	g_XOPEN_SOURCE
+))
+
+184 #unde
+_DEFAULT_SOURCE
+
+
+185 
+	#_DEFAULT_SOURCE
+ 1
+
+	)
+
+189 #i(
+defed
+ 
+_ISOC11_SOURCE
+ \
+
+190 || (
+defed
+ 
+	g__STDC_VERSION__
+ && __STDC_VERSION__ >= 201112L))
+
+191 
+	#__USE_ISOC11
+ 1
+
+	)
+
+195 #i(
+defed
+ 
+_ISOC99_SOURCE
+ || defed 
+_ISOC11_SOURCE
+ \
+
+196 || (
+defed
+ 
+__STDC_VERSION__
+ && __STDC_VERSION__ >= 199901L))
+
+197 
+	#__USE_ISOC99
+ 1
+
+	)
+
+201 #i(
+defed
+ 
+_ISOC99_SOURCE
+ || defed 
+_ISOC11_SOURCE
+ \
+
+202 || (
+defed
+ 
+__STDC_VERSION__
+ && __STDC_VERSION__ >= 199409L))
+
+203 
+	#__USE_ISOC95
+ 1
+
+	)
+
+210 #i((
+defed
+ 
+__lulus
+ && __cplusplus >= 201103L) \
+
+211 || 
+defed
+ 
+__GXX_EXPERIMENTAL_CXX0X__
+)
+
+212 
+	#__USE_ISOCXX11
+ 1
+
+	)
+
+218 #ifde
+_DEFAULT_SOURCE
+
+
+219 #i!
+defed
+ 
+_POSIX_SOURCE
+ && !defed 
+_POSIX_C_SOURCE
+
+
+220 
+	#__USE_POSIX_IMPLICITLY
+ 1
+
+	)
+
+222 #unde
+_POSIX_SOURCE
+
+
+223 
+	#_POSIX_SOURCE
+ 1
+
+	)
+
+224 #unde
+_POSIX_C_SOURCE
+
+
+225 
+	#_POSIX_C_SOURCE
+ 200809L
+
+	)
+
+227 #i((!
+defed
+ 
+__STRICT_ANSI__
+ \
+
+228 || (
+defed
+ 
+_XOPEN_SOURCE
+ && (_XOPEN_SOURCE - 0) >= 500)) \
+
+229 && !
+defed
+ 
+_POSIX_SOURCE
+ && !defed 
+_POSIX_C_SOURCE
+)
+
+230 
+	#_POSIX_SOURCE
+ 1
+
+	)
+
+231 #i
+defed
+ 
+_XOPEN_SOURCE
+ && (_XOPEN_SOURCE - 0) < 500
+
+232 
+	#_POSIX_C_SOURCE
+ 2
+
+	)
+
+233 #i
+defed
+ 
+_XOPEN_SOURCE
+ && (_XOPEN_SOURCE - 0) < 600
+
+234 
+	#_POSIX_C_SOURCE
+ 199506L
+
+	)
+
+235 #i
+defed
+ 
+_XOPEN_SOURCE
+ && (_XOPEN_SOURCE - 0) < 700
+
+236 
+	#_POSIX_C_SOURCE
+ 200112L
+
+	)
+
+238 
+	#_POSIX_C_SOURCE
+ 200809L
+
+	)
+
+240 
+	#__USE_POSIX_IMPLICITLY
+ 1
+
+	)
+
+243 #i(
+defed
+ 
+_POSIX_SOURCE
+ \
+
+244 || (
+defed
+ 
+_POSIX_C_SOURCE
+ && _POSIX_C_SOURCE >= 1) \
+
+245 || 
+defed
+ 
+_XOPEN_SOURCE
+)
+
+246 
+	#__USE_POSIX
+ 1
+
+	)
+
+249 #i
+defed
+ 
+_POSIX_C_SOURCE
+ && _POSIX_C_SOURCE >2 || defed 
+_XOPEN_SOURCE
+
+
+250 
+	#__USE_POSIX2
+ 1
+
+	)
+
+253 #i
+defed
+ 
+_POSIX_C_SOURCE
+ && (_POSIX_C_SOURCE - 0) >= 199309L
+
+254 
+	#__USE_POSIX199309
+ 1
+
+	)
+
+257 #i
+defed
+ 
+_POSIX_C_SOURCE
+ && (_POSIX_C_SOURCE - 0) >= 199506L
+
+258 
+	#__USE_POSIX199506
+ 1
+
+	)
+
+261 #i
+defed
+ 
+_POSIX_C_SOURCE
+ && (_POSIX_C_SOURCE - 0) >= 200112L
+
+262 
+	#__USE_XOPEN2K
+ 1
+
+	)
+
+263 #unde
+__USE_ISOC95
+
+
+264 
+	#__USE_ISOC95
+ 1
+
+	)
+
+265 #unde
+__USE_ISOC99
+
+
+266 
+	#__USE_ISOC99
+ 1
+
+	)
+
+269 #i
+defed
+ 
+_POSIX_C_SOURCE
+ && (_POSIX_C_SOURCE - 0) >= 200809L
+
+270 
+	#__USE_XOPEN2K8
+ 1
+
+	)
+
+271 #unde
+_ATFILE_SOURCE
+
+
+272 
+	#_ATFILE_SOURCE
+ 1
+
+	)
+
+275 #ifdef 
+_XOPEN_SOURCE
+
+
+276 
+	#__USE_XOPEN
+ 1
+
+	)
+
+277 #i(
+_XOPEN_SOURCE
+ - 0) >= 500
+
+278 
+	#__USE_XOPEN_EXTENDED
+ 1
+
+	)
+
+279 
+	#__USE_UNIX98
+ 1
+
+	)
+
+280 #unde
+_LARGEFILE_SOURCE
+
+
+281 
+	#_LARGEFILE_SOURCE
+ 1
+
+	)
+
+282 #i(
+_XOPEN_SOURCE
+ - 0) >= 600
+
+283 #i(
+_XOPEN_SOURCE
+ - 0) >= 700
+
+284 
+	#__USE_XOPEN2K8
+ 1
+
+	)
+
+285 
+	#__USE_XOPEN2K8XSI
+ 1
+
+	)
+
+287 
+	#__USE_XOPEN2K
+ 1
+
+	)
+
+288 
+	#__USE_XOPEN2KXSI
+ 1
+
+	)
+
+289 #unde
+__USE_ISOC95
+
+
+290 
+	#__USE_ISOC95
+ 1
+
+	)
+
+291 #unde
+__USE_ISOC99
+
+
+292 
+	#__USE_ISOC99
+ 1
+
+	)
+
+295 #ifde
+_XOPEN_SOURCE_EXTENDED
+
+
+296 
+	#__USE_XOPEN_EXTENDED
+ 1
+
+	)
+
+301 #ifde
+_LARGEFILE_SOURCE
+
+
+302 
+	#__USE_LARGEFILE
+ 1
+
+	)
+
+305 #ifde
+_LARGEFILE64_SOURCE
+
+
+306 
+	#__USE_LARGEFILE64
+ 1
+
+	)
+
+309 #i
+defed
+ 
+_FILE_OFFSET_BITS
+ && _FILE_OFFSET_BITS == 64
+
+310 
+	#__USE_FILE_OFFSET64
+ 1
+
+	)
+
+313 #i
+defed
+ 
+_DEFAULT_SOURCE
+
+
+314 
+	#__USE_MISC
+ 1
+
+	)
+
+317 #ifdef 
+_ATFILE_SOURCE
+
+
+318 
+	#__USE_ATFILE
+ 1
+
+	)
+
+321 #ifdef 
+_GNU_SOURCE
+
+
+322 
+	#__USE_GNU
+ 1
+
+	)
+
+325 #i
+defed
+ 
+_REENTRANT
+ || defed 
+_THREAD_SAFE
+
+
+326 
+	#__USE_REENTRANT
+ 1
+
+	)
+
+329 #i
+defed
+ 
+_FORTIFY_SOURCE
+ && _FORTIFY_SOURCE > 0
+
+330 #i!
+defed
+ 
+__OPTIMIZE__
+ || __OPTIMIZE__ <= 0
+
+331 #wng 
+_FORTIFY_SOURCE
+ 
+ques
+ 
+compg
+ 
+wh
+ 
+timizi
+ (-
+O
+)
+
+332 #i!
+__GNUC_PREREQ
+ (4, 1)
+
+333 #wng 
+_FORTIFY_SOURCE
+ 
+ques
+ 
+GCC
+ 4.1 
+
+ 
+r
+
+
+334 #i
+_FORTIFY_SOURCE
+ > 1
+
+335 
+	#__USE_FORTIFY_LEVEL
+ 2
+
+	)
+
+337 
+	#__USE_FORTIFY_LEVEL
+ 1
+
+	)
+
+340 #ide
+__USE_FORTIFY_LEVEL
+
+
+341 
+	#__USE_FORTIFY_LEVEL
+ 0
+
+	)
+
+346 
+	~<dc-edef.h
+>
+
+354 #unde
+__GNU_LIBRARY__
+
+
+355 
+	#__GNU_LIBRARY__
+ 6
+
+	)
+
+359 
+	#__GLIBC__
+ 2
+
+	)
+
+360 
+	#__GLIBC_MINOR__
+ 23
+
+	)
+
+362 
+	#__GLIBC_PREREQ
+(
+maj
+, 
+m
+) \
+
+363 ((
+__GLIBC__
+ << 16+ 
+__GLIBC_MINOR__
+ >((
+maj
+<< 16+ (
+m
+))
+
+	)
+
+366 #ide
+__ASSEMBLER__
+
+
+367 #ide
+_SYS_CDEFS_H
+
+
+368 
+	~<sys/cdefs.h
+>
+
+373 #i
+defed
+ 
+__USE_FILE_OFFSET64
+ && !defed 
+__REDIRECT
+
+
+374 
+	#__USE_LARGEFILE
+ 1
+
+	)
+
+375 
+	#__USE_LARGEFILE64
+ 1
+
+	)
+
+381 #i
+__GNUC_PREREQ
+ (2, 7&& 
+defed
+ 
+__OPTIMIZE__
+ \
+
+382 && !
+defed
+ 
+	g__OPTIMIZE_SIZE__
+ && !defed 
+	g__NO_INLINE__
+ \
+
+383 && 
+defed
+ 
+	g__ex_le
+
+
+384 
+	#__USE_EXTERN_INLINES
+ 1
+
+	)
+
+392 
+	~<gnu/ubs.h
+>
+
+	@/usr/include/sys/types.h
+
+22 #idef 
+_SYS_TYPES_H
+
+
+23 
+	#_SYS_TYPES_H
+ 1
+
+	)
+
+25 
+	~<us.h
+>
+
+27 
+	g__BEGIN_DECLS
+
+
+29 
+	~<bs/tys.h
+>
+
+31 #ifdef 
+__USE_MISC
+
+
+32 #ide
+__u_ch_defed
+
+
+33 
+__u_ch
+ 
+	tu_ch
+;
+
+34 
+__u_sht
+ 
+	tu_sht
+;
+
+35 
+__u_t
+ 
+	tu_t
+;
+
+36 
+__u_lg
+ 
+	tu_lg
+;
+
+37 
+__quad_t
+ 
+	tquad_t
+;
+
+38 
+__u_quad_t
+ 
+	tu_quad_t
+;
+
+39 
+__fsid_t
+ 
+	tfsid_t
+;
+
+40 
+	#__u_ch_defed
+
+
+	)
+
+44 
+__loff_t
+ 
+	tloff_t
+;
+
+46 #ide
+__o_t_defed
+
+
+47 #ide
+__USE_FILE_OFFSET64
+
+
+48 
+__o_t
+ 
+	to_t
+;
+
+50 
+__o64_t
+ 
+	to_t
+;
+
+52 
+	#__o_t_defed
+
+
+	)
+
+54 #i
+defed
+ 
+__USE_LARGEFILE64
+ && !defed 
+__o64_t_defed
+
+
+55 
+__o64_t
+ 
+	to64_t
+;
+
+56 
+	#__o64_t_defed
+
+
+	)
+
+59 #ide
+__dev_t_defed
+
+
+60 
+__dev_t
+ 
+	tdev_t
+;
+
+61 
+	#__dev_t_defed
+
+
+	)
+
+64 #ide
+__gid_t_defed
+
+
+65 
+__gid_t
+ 
+	tgid_t
+;
+
+66 
+	#__gid_t_defed
+
+
+	)
+
+69 #ide
+__mode_t_defed
+
+
+70 
+__mode_t
+ 
+	tmode_t
+;
+
+71 
+	#__mode_t_defed
+
+
+	)
+
+74 #ide
+__k_t_defed
+
+
+75 
+__k_t
+ 
+	tk_t
+;
+
+76 
+	#__k_t_defed
+
+
+	)
+
+79 #ide
+__uid_t_defed
+
+
+80 
+__uid_t
+ 
+	tuid_t
+;
+
+81 
+	#__uid_t_defed
+
+
+	)
+
+84 #ide
+__off_t_defed
+
+
+85 #ide
+__USE_FILE_OFFSET64
+
+
+86 
+__off_t
+ 
+	toff_t
+;
+
+88 
+__off64_t
+ 
+	toff_t
+;
+
+90 
+	#__off_t_defed
+
+
+	)
+
+92 #i
+defed
+ 
+__USE_LARGEFILE64
+ && !defed 
+__off64_t_defed
+
+
+93 
+__off64_t
+ 
+	toff64_t
+;
+
+94 
+	#__off64_t_defed
+
+
+	)
+
+97 #ide
+__pid_t_defed
+
+
+98 
+__pid_t
+ 
+	tpid_t
+;
+
+99 
+	#__pid_t_defed
+
+
+	)
+
+102 #i(
+defed
+ 
+__USE_XOPEN
+ || defed 
+__USE_XOPEN2K8
+) \
+
+103 && !
+defed
+ 
+__id_t_defed
+
+
+104 
+__id_t
+ 
+	tid_t
+;
+
+105 
+	#__id_t_defed
+
+
+	)
+
+108 #ide
+__ssize_t_defed
+
+
+109 
+__ssize_t
+ 
+	tssize_t
+;
+
+110 
+	#__ssize_t_defed
+
+
+	)
+
+113 #ifdef 
+__USE_MISC
+
+
+114 #ide
+__daddr_t_defed
+
+
+115 
+__daddr_t
+ 
+	tdaddr_t
+;
+
+116 
+__ddr_t
+ 
+	tddr_t
+;
+
+117 
+	#__daddr_t_defed
+
+
+	)
+
+121 #i(
+defed
+ 
+__USE_MISC
+ || defed 
+__USE_XOPEN
+&& !defed 
+__key_t_defed
+
+
+122 
+__key_t
+ 
+	tkey_t
+;
+
+123 
+	#__key_t_defed
+
+
+	)
+
+126 #i
+defed
+ 
+__USE_XOPEN
+ || defed 
+__USE_XOPEN2K8
+
+
+127 
+	#__ed_ock_t
+
+
+	)
+
+129 
+	#__ed_time_t
+
+
+	)
+
+130 
+	#__ed_tim_t
+
+
+	)
+
+131 
+	#__ed_ockid_t
+
+
+	)
+
+132 
+	~<time.h
+>
+
+134 #ifde
+__USE_XOPEN
+
+
+135 #ide
+__ucds_t_defed
+
+
+136 
+__ucds_t
+ 
+	tucds_t
+;
+
+137 
+	#__ucds_t_defed
+
+
+	)
+
+139 #ide
+__sucds_t_defed
+
+
+140 
+__sucds_t
+ 
+	tsucds_t
+;
+
+141 
+	#__sucds_t_defed
+
+
+	)
+
+145 
+	#__ed_size_t
+
+
+	)
+
+146 
+	~<ddef.h
+>
+
+148 #ifde
+__USE_MISC
+
+
+150 
+	tulg
+;
+
+151 
+	tusht
+;
+
+152 
+	tut
+;
+
+157 #i!
+__GNUC_PREREQ
+ (2, 7)
+
+160 #ide
+__t8_t_defed
+
+
+161 
+	#__t8_t_defed
+
+
+	)
+
+162 
+	tt8_t
+;
+
+163 
+	tt16_t
+;
+
+164 
+	tt32_t
+;
+
+165 #i
+__WORDSIZE
+ == 64
+
+166 
+	tt64_t
+;
+
+168 
+__exnsi__
+ 
+	tt64_t
+;
+
+173 
+	tu_t8_t
+;
+
+174 
+	tu_t16_t
+;
+
+175 
+	tu_t32_t
+;
+
+176 #i
+__WORDSIZE
+ == 64
+
+177 
+	tu_t64_t
+;
+
+179 
+__exnsi__
+ 
+	tu_t64_t
+;
+
+182 
+	tgi_t
+;
+
+187 
+	#__tN_t
+(
+N
+, 
+MODE
+) \
+
+188 ##
+	tN
+##
+	t_t
+ 
+	t__ibu__
+ ((
+	t__mode__
+ (
+	tMODE
+)))
+
+	)
+
+189 
+	t__u_tN_t
+(
+	tN
+, 
+	tMODE
+) \
+
+190 
+	tu_t
+##
+	tN
+##
+	t_t
+ 
+	t__ibu__
+ ((
+	t__mode__
+ (
+	tMODE
+)))
+
+	)
+
+192 #ide
+	t__t8_t_defed
+
+
+193 
+	t__t8_t_defed
+
+
+	)
+
+194 
+	t__tN_t
+ (8, 
+	t__QI__
+);
+
+195 
+__tN_t
+ (16, 
+__HI__
+);
+
+196 
+__tN_t
+ (32, 
+__SI__
+);
+
+197 
+__tN_t
+ (64, 
+__DI__
+);
+
+200 
+__u_tN_t
+ (8, 
+__QI__
+);
+
+201 
+__u_tN_t
+ (16, 
+__HI__
+);
+
+202 
+__u_tN_t
+ (32, 
+__SI__
+);
+
+203 
+__u_tN_t
+ (64, 
+__DI__
+);
+
+205 
+	tgi_t
+ 
+	t__ibu__
+ ((
+	t__mode__
+ (
+	t__wd__
+)));
+
+211 
+	#__BIT_TYPES_DEFINED__
+ 1
+
+	)
+
+214 #ifdef 
+__USE_MISC
+
+
+216 
+	~<dn.h
+>
+
+219 
+	~<sys/.h
+>
+
+222 
+	~<sys/sysmaos.h
+>
+
+226 #i(
+defed
+ 
+__USE_UNIX98
+ || defed 
+__USE_XOPEN2K8
+) \
+
+227 && !
+defed
+ 
+__blksize_t_defed
+
+
+228 
+__blksize_t
+ 
+	tblksize_t
+;
+
+229 
+	#__blksize_t_defed
+
+
+	)
+
+233 #ide
+__USE_FILE_OFFSET64
+
+
+234 #ide
+__blkt_t_defed
+
+
+235 
+__blkt_t
+ 
+	tblkt_t
+;
+
+236 
+	#__blkt_t_defed
+
+
+	)
+
+238 #ide
+__fsblkt_t_defed
+
+
+239 
+__fsblkt_t
+ 
+	tfsblkt_t
+;
+
+240 
+	#__fsblkt_t_defed
+
+
+	)
+
+242 #ide
+__fsft_t_defed
+
+
+243 
+__fsft_t
+ 
+	tfsft_t
+;
+
+244 
+	#__fsft_t_defed
+
+
+	)
+
+247 #ide
+__blkt_t_defed
+
+
+248 
+__blkt64_t
+ 
+	tblkt_t
+;
+
+249 
+	#__blkt_t_defed
+
+
+	)
+
+251 #ide
+__fsblkt_t_defed
+
+
+252 
+__fsblkt64_t
+ 
+	tfsblkt_t
+;
+
+253 
+	#__fsblkt_t_defed
+
+
+	)
+
+255 #ide
+__fsft_t_defed
+
+
+256 
+__fsft64_t
+ 
+	tfsft_t
+;
+
+257 
+	#__fsft_t_defed
+
+
+	)
+
+261 #ifde
+__USE_LARGEFILE64
+
+
+262 
+__blkt64_t
+ 
+	tblkt64_t
+;
+
+263 
+__fsblkt64_t
+ 
+	tfsblkt64_t
+;
+
+264 
+__fsft64_t
+ 
+	tfsft64_t
+;
+
+269 #i
+defed
+ 
+__USE_POSIX199506
+ || defed 
+__USE_UNIX98
+
+
+270 
+	~<bs/hadtys.h
+>
+
+273 
+	g__END_DECLS
+
+
+	@/usr/include/xlocale.h
+
+20 #ide
+_XLOCALE_H
+
+
+21 
+	#_XLOCALE_H
+ 1
+
+	)
+
+27 
+	s__lo_ru
+
+
+30 
+__lo_da
+ *
+	m__los
+[13];
+
+33 c *
+	m__y_b
+;
+
+34 c *
+	m__y_tow
+;
+
+35 c *
+	m__y_tou
+;
+
+38 c *
+	m__mes
+[13];
+
+39 } *
+	t__lo_t
+;
+
+42 
+__lo_t
+ 
+	tlo_t
+;
+
+	@/usr/include/bits/pthreadtypes.h
+
+18 #ide
+_BITS_PTHREADTYPES_H
+
+
+19 
+	#_BITS_PTHREADTYPES_H
+ 1
+
+	)
+
+21 
+	~<bs/wdsize.h
+>
+
+23 #ifde
+__x86_64__
+
+
+24 #i
+__WORDSIZE
+ == 64
+
+25 
+	#__SIZEOF_PTHREAD_ATTR_T
+ 56
+
+	)
+
+26 
+	#__SIZEOF_PTHREAD_MUTEX_T
+ 40
+
+	)
+
+27 
+	#__SIZEOF_PTHREAD_MUTEXATTR_T
+ 4
+
+	)
+
+28 
+	#__SIZEOF_PTHREAD_COND_T
+ 48
+
+	)
+
+29 
+	#__SIZEOF_PTHREAD_CONDATTR_T
+ 4
+
+	)
+
+30 
+	#__SIZEOF_PTHREAD_RWLOCK_T
+ 56
+
+	)
+
+31 
+	#__SIZEOF_PTHREAD_RWLOCKATTR_T
+ 8
+
+	)
+
+32 
+	#__SIZEOF_PTHREAD_BARRIER_T
+ 32
+
+	)
+
+33 
+	#__SIZEOF_PTHREAD_BARRIERATTR_T
+ 4
+
+	)
+
+35 
+	#__SIZEOF_PTHREAD_ATTR_T
+ 32
+
+	)
+
+36 
+	#__SIZEOF_PTHREAD_MUTEX_T
+ 32
+
+	)
+
+37 
+	#__SIZEOF_PTHREAD_MUTEXATTR_T
+ 4
+
+	)
+
+38 
+	#__SIZEOF_PTHREAD_COND_T
+ 48
+
+	)
+
+39 
+	#__SIZEOF_PTHREAD_CONDATTR_T
+ 4
+
+	)
+
+40 
+	#__SIZEOF_PTHREAD_RWLOCK_T
+ 44
+
+	)
+
+41 
+	#__SIZEOF_PTHREAD_RWLOCKATTR_T
+ 8
+
+	)
+
+42 
+	#__SIZEOF_PTHREAD_BARRIER_T
+ 20
+
+	)
+
+43 
+	#__SIZEOF_PTHREAD_BARRIERATTR_T
+ 4
+
+	)
+
+46 
+	#__SIZEOF_PTHREAD_ATTR_T
+ 36
+
+	)
+
+47 
+	#__SIZEOF_PTHREAD_MUTEX_T
+ 24
+
+	)
+
+48 
+	#__SIZEOF_PTHREAD_MUTEXATTR_T
+ 4
+
+	)
+
+49 
+	#__SIZEOF_PTHREAD_COND_T
+ 48
+
+	)
+
+50 
+	#__SIZEOF_PTHREAD_CONDATTR_T
+ 4
+
+	)
+
+51 
+	#__SIZEOF_PTHREAD_RWLOCK_T
+ 32
+
+	)
+
+52 
+	#__SIZEOF_PTHREAD_RWLOCKATTR_T
+ 8
+
+	)
+
+53 
+	#__SIZEOF_PTHREAD_BARRIER_T
+ 20
+
+	)
+
+54 
+	#__SIZEOF_PTHREAD_BARRIERATTR_T
+ 4
+
+	)
+
+60 
+	thad_t
+;
+
+63 
+	uhad__t
+
+
+65 
+	m__size
+[
+__SIZEOF_PTHREAD_ATTR_T
+];
+
+66 
+	m__ign
+;
+
+68 #ide
+__have_had__t
+
+
+69 
+had__t
+ 
+	thad__t
+;
+
+70 
+	#__have_had__t
+ 1
+
+	)
+
+74 #ifde
+__x86_64__
+
+
+75 
+	s__had__li
+
+
+77 
+__had__li
+ *
+	m__ev
+;
+
+78 
+__had__li
+ *
+	m__xt
+;
+
+79 } 
+	t__had_li_t
+;
+
+81 
+	s__had__i
+
+
+83 
+__had__i
+ *
+	m__xt
+;
+
+84 } 
+	t__had_i_t
+;
+
+92 
+	s__had_mux_s
+
+
+94 
+	m__lock
+;
+
+95 
+	m__cou
+;
+
+96 
+	m__owr
+;
+
+97 #ifde
+__x86_64__
+
+
+98 
+	m__nurs
+;
+
+102 
+	m__kd
+;
+
+103 #ifde
+__x86_64__
+
+
+104 
+	m__s
+;
+
+105 
+	m__isi
+;
+
+106 
+__had_li_t
+ 
+	m__li
+;
+
+107 
+	#__PTHREAD_MUTEX_HAVE_PREV
+ 1
+
+	)
+
+109 
+	#__PTHREAD_SPINS
+ 0, 0
+
+	)
+
+111 
+	m__nurs
+;
+
+112 
+__exnsi__
+ union
+
+116 
+	m__es
+;
+
+117 
+	m__isi
+;
+
+118 
+	#__s
+ 
+__isi_da
+.
+__es
+
+
+	)
+
+119 
+	#__isi
+ 
+__isi_da
+.
+__isi
+
+
+	)
+
+120 
+	#__PTHREAD_SPINS
+ { 0, 0 }
+
+	)
+
+121 } 
+	m__isi_da
+;
+
+122 
+__had_i_t
+ 
+	m__li
+;
+
+125 } 
+	m__da
+;
+
+126 
+	m__size
+[
+__SIZEOF_PTHREAD_MUTEX_T
+];
+
+127 
+	m__ign
+;
+
+128 } 
+	thad_mux_t
+;
+
+132 
+	m__size
+[
+__SIZEOF_PTHREAD_MUTEXATTR_T
+];
+
+133 
+	m__ign
+;
+
+134 } 
+	thad_mux_t
+;
+
+143 
+	m__lock
+;
+
+144 
+	m__fux
+;
+
+145 
+__exnsi__
+ 
+	m__t_q
+;
+
+146 
+__exnsi__
+ 
+	m__wakeup_q
+;
+
+147 
+__exnsi__
+ 
+	m__wok_q
+;
+
+148 *
+	m__mux
+;
+
+149 
+	m__nwas
+;
+
+150 
+	m__brd_q
+;
+
+151 } 
+	m__da
+;
+
+152 
+	m__size
+[
+__SIZEOF_PTHREAD_COND_T
+];
+
+153 
+__exnsi__
+ 
+	m__ign
+;
+
+154 } 
+	thad_cd_t
+;
+
+158 
+	m__size
+[
+__SIZEOF_PTHREAD_CONDATTR_T
+];
+
+159 
+	m__ign
+;
+
+160 } 
+	thad_cd_t
+;
+
+164 
+	thad_key_t
+;
+
+168 
+	thad__t
+;
+
+171 #i
+defed
+ 
+__USE_UNIX98
+ || defed 
+__USE_XOPEN2K
+
+
+176 #ifde
+__x86_64__
+
+
+179 
+	m__lock
+;
+
+180 
+	m___ads
+;
+
+181 
+	m__ads_wakeup
+;
+
+182 
+	m__wr_wakeup
+;
+
+183 
+	m___ads_queued
+;
+
+184 
+	m___wrs_queued
+;
+
+185 
+	m__wr
+;
+
+186 
+	m__shed
+;
+
+187 sigd 
+	m__rwisi
+;
+
+188 #ifde 
+__ILP32__
+
+
+189 
+	m__d1
+[3];
+
+190 
+	#__PTHREAD_RWLOCK_ELISION_EXTRA
+ 0, { 0, 0, 0 }
+
+	)
+
+192 
+	m__d1
+[7];
+
+193 
+	#__PTHREAD_RWLOCK_ELISION_EXTRA
+ 0, { 0, 0, 0, 0, 0, 0, 0 }
+
+	)
+
+195 
+	m__d2
+;
+
+198 
+	m__ags
+;
+
+199 
+	#__PTHREAD_RWLOCK_INT_FLAGS_SHARED
+ 1
+
+	)
+
+200 } 
+	m__da
+;
+
+204 
+	m__lock
+;
+
+205 
+	m___ads
+;
+
+206 
+	m__ads_wakeup
+;
+
+207 
+	m__wr_wakeup
+;
+
+208 
+	m___ads_queued
+;
+
+209 
+	m___wrs_queued
+;
+
+212 
+	m__ags
+;
+
+213 
+	m__shed
+;
+
+214 sigd 
+	m__rwisi
+;
+
+215 
+	#__PTHREAD_RWLOCK_ELISION_EXTRA
+ 0
+
+	)
+
+216 
+	m__d2
+;
+
+217 
+	m__wr
+;
+
+218 } 
+	m__da
+;
+
+220 
+	m__size
+[
+__SIZEOF_PTHREAD_RWLOCK_T
+];
+
+221 
+	m__ign
+;
+
+222 } 
+	thad_rwlock_t
+;
+
+226 
+	m__size
+[
+__SIZEOF_PTHREAD_RWLOCKATTR_T
+];
+
+227 
+	m__ign
+;
+
+228 } 
+	thad_rwlock_t
+;
+
+232 #ifde
+__USE_XOPEN2K
+
+
+234 v
+	thad_lock_t
+;
+
+241 
+	m__size
+[
+__SIZEOF_PTHREAD_BARRIER_T
+];
+
+242 
+	m__ign
+;
+
+243 } 
+	thad_brr_t
+;
+
+247 
+	m__size
+[
+__SIZEOF_PTHREAD_BARRIERATTR_T
+];
+
+248 
+	m__ign
+;
+
+249 } 
+	thad_brr_t
+;
+
+253 #ide
+__x86_64__
+
+
+255 
+	#__nup_f_ibu
+ 
+	`__ibu__
+ ((
+	`__grm__
+ (1)))
+
+	)
+
+	@/usr/include/bits/types.h
+
+23 #idef 
+_BITS_TYPES_H
+
+
+24 
+	#_BITS_TYPES_H
+ 1
+
+	)
+
+26 
+	~<us.h
+>
+
+27 
+	~<bs/wdsize.h
+>
+
+30 
+	t__u_ch
+;
+
+31 
+	t__u_sht
+;
+
+32 
+	t__u_t
+;
+
+33 
+	t__u_lg
+;
+
+36 sigd 
+	t__t8_t
+;
+
+37 
+	t__ut8_t
+;
+
+38 sigd 
+	t__t16_t
+;
+
+39 
+	t__ut16_t
+;
+
+40 sigd 
+	t__t32_t
+;
+
+41 
+	t__ut32_t
+;
+
+42 #i
+__WORDSIZE
+ == 64
+
+43 sigd 
+	t__t64_t
+;
+
+44 
+	t__ut64_t
+;
+
+46 
+__exnsi__
+ sigd 
+	t__t64_t
+;
+
+47 
+__exnsi__
+ 
+	t__ut64_t
+;
+
+51 #i
+__WORDSIZE
+ == 64
+
+52 
+	t__quad_t
+;
+
+53 
+	t__u_quad_t
+;
+
+55 
+__exnsi__
+ 
+	t__quad_t
+;
+
+56 
+__exnsi__
+ 
+	t__u_quad_t
+;
+
+89 
+	#__S16_TYPE
+ 
+
+	)
+
+90 
+	#__U16_TYPE
+ 
+
+	)
+
+91 
+	#__S32_TYPE
+ 
+
+	)
+
+92 
+	#__U32_TYPE
+ 
+
+	)
+
+93 
+	#__SLONGWORD_TYPE
+ 
+
+	)
+
+94 
+	#__ULONGWORD_TYPE
+ 
+
+	)
+
+95 #i
+__WORDSIZE
+ == 32
+
+96 
+	#__SQUAD_TYPE
+ 
+__quad_t
+
+
+	)
+
+97 
+	#__UQUAD_TYPE
+ 
+__u_quad_t
+
+
+	)
+
+98 
+	#__SWORD_TYPE
+ 
+
+	)
+
+99 
+	#__UWORD_TYPE
+ 
+
+	)
+
+100 
+	#__SLONG32_TYPE
+ 
+
+	)
+
+101 
+	#__ULONG32_TYPE
+ 
+
+	)
+
+102 
+	#__S64_TYPE
+ 
+__quad_t
+
+
+	)
+
+103 
+	#__U64_TYPE
+ 
+__u_quad_t
+
+
+	)
+
+106 
+	#__STD_TYPE
+ 
+__exnsi__
+ 
+
+	)
+
+107 #i
+__WORDSIZE
+ == 64
+
+108 
+	t__SQUAD_TYPE
+ 
+
+	)
+
+109 
+	t__UQUAD_TYPE
+ 
+
+	)
+
+110 
+	t__SWORD_TYPE
+ 
+
+	)
+
+111 
+	t__UWORD_TYPE
+ 
+
+	)
+
+112 
+	t__SLONG32_TYPE
+ 
+
+	)
+
+113 
+	t__ULONG32_TYPE
+ 
+
+	)
+
+114 
+	t__S64_TYPE
+ 
+
+	)
+
+115 
+	t__U64_TYPE
+ 
+
+	)
+
+117 
+	t__STD_TYPE
+ 
+
+	)
+
+121 
+	~<bs/tysizes.h
+>
+
+124 
+__STD_TYPE
+ 
+	t__DEV_T_TYPE
+ 
+	t__dev_t
+;
+
+125 
+__STD_TYPE
+ 
+__UID_T_TYPE
+ 
+	g__uid_t
+;
+
+126 
+__STD_TYPE
+ 
+__GID_T_TYPE
+ 
+	g__gid_t
+;
+
+127 
+__STD_TYPE
+ 
+__INO_T_TYPE
+ 
+	g__o_t
+;
+
+128 
+__STD_TYPE
+ 
+__INO64_T_TYPE
+ 
+	g__o64_t
+;
+
+129 
+__STD_TYPE
+ 
+__MODE_T_TYPE
+ 
+	g__mode_t
+;
+
+130 
+__STD_TYPE
+ 
+__NLINK_T_TYPE
+ 
+	g__k_t
+;
+
+131 
+__STD_TYPE
+ 
+__OFF_T_TYPE
+ 
+	g__off_t
+;
+
+132 
+__STD_TYPE
+ 
+__OFF64_T_TYPE
+ 
+	g__off64_t
+;
+
+133 
+__STD_TYPE
+ 
+__PID_T_TYPE
+ 
+	g__pid_t
+;
+
+134 
+__STD_TYPE
+ 
+__FSID_T_TYPE
+ 
+	g__fsid_t
+;
+
+135 
+__STD_TYPE
+ 
+__CLOCK_T_TYPE
+ 
+	g__ock_t
+;
+
+136 
+__STD_TYPE
+ 
+__RLIM_T_TYPE
+ 
+	g__im_t
+;
+
+137 
+__STD_TYPE
+ 
+__RLIM64_T_TYPE
+ 
+	g__im64_t
+;
+
+138 
+__STD_TYPE
+ 
+__ID_T_TYPE
+ 
+	g__id_t
+;
+
+139 
+__STD_TYPE
+ 
+__TIME_T_TYPE
+ 
+	g__time_t
+;
+
+140 
+__STD_TYPE
+ 
+__USECONDS_T_TYPE
+ 
+	g__ucds_t
+;
+
+141 
+__STD_TYPE
+ 
+__SUSECONDS_T_TYPE
+ 
+	g__sucds_t
+;
+
+143 
+__STD_TYPE
+ 
+__DADDR_T_TYPE
+ 
+	g__daddr_t
+;
+
+144 
+__STD_TYPE
+ 
+__KEY_T_TYPE
+ 
+	g__key_t
+;
+
+147 
+__STD_TYPE
+ 
+__CLOCKID_T_TYPE
+ 
+	g__ockid_t
+;
+
+150 
+__STD_TYPE
+ 
+__TIMER_T_TYPE
+ 
+	g__tim_t
+;
+
+153 
+__STD_TYPE
+ 
+__BLKSIZE_T_TYPE
+ 
+	g__blksize_t
+;
+
+158 
+__STD_TYPE
+ 
+__BLKCNT_T_TYPE
+ 
+	g__blkt_t
+;
+
+159 
+__STD_TYPE
+ 
+__BLKCNT64_T_TYPE
+ 
+	g__blkt64_t
+;
+
+162 
+__STD_TYPE
+ 
+__FSBLKCNT_T_TYPE
+ 
+	g__fsblkt_t
+;
+
+163 
+__STD_TYPE
+ 
+__FSBLKCNT64_T_TYPE
+ 
+	g__fsblkt64_t
+;
+
+166 
+__STD_TYPE
+ 
+__FSFILCNT_T_TYPE
+ 
+	g__fsft_t
+;
+
+167 
+__STD_TYPE
+ 
+__FSFILCNT64_T_TYPE
+ 
+	g__fsft64_t
+;
+
+170 
+__STD_TYPE
+ 
+__FSWORD_T_TYPE
+ 
+	g__fswd_t
+;
+
+172 
+__STD_TYPE
+ 
+__SSIZE_T_TYPE
+ 
+	g__ssize_t
+;
+
+175 
+__STD_TYPE
+ 
+__SYSCALL_SLONG_TYPE
+ 
+	g__sys_g_t
+;
+
+177 
+__STD_TYPE
+ 
+__SYSCALL_ULONG_TYPE
+ 
+	g__sys_ulg_t
+;
+
+181 
+__off64_t
+ 
+	t__loff_t
+;
+
+182 
+__quad_t
+ *
+	t__qaddr_t
+;
+
+183 *
+	t__ddr_t
+;
+
+186 
+__STD_TYPE
+ 
+__SWORD_TYPE
+ 
+	g___t
+;
+
+189 
+__STD_TYPE
+ 
+__U32_TYPE
+ 
+	g__sockn_t
+;
+
+192 #unde
+__STD_TYPE
+
+
+	@/usr/include/endian.h
+
+18 #idef 
+_ENDIAN_H
+
+
+19 
+	#_ENDIAN_H
+ 1
+
+	)
+
+21 
+	~<us.h
+>
+
+31 
+	#__LITTLE_ENDIAN
+ 1234
+
+	)
+
+32 
+	#__BIG_ENDIAN
+ 4321
+
+	)
+
+33 
+	#__PDP_ENDIAN
+ 3412
+
+	)
+
+36 
+	~<bs/dn.h
+>
+
+40 #ide
+__FLOAT_WORD_ORDER
+
+
+41 
+	#__FLOAT_WORD_ORDER
+ 
+__BYTE_ORDER
+
+
+	)
+
+44 #ifdef 
+__USE_MISC
+
+
+45 
+	#LITTLE_ENDIAN
+ 
+__LITTLE_ENDIAN
+
+
+	)
+
+46 
+	#BIG_ENDIAN
+ 
+__BIG_ENDIAN
+
+
+	)
+
+47 
+	#PDP_ENDIAN
+ 
+__PDP_ENDIAN
+
+
+	)
+
+48 
+	#BYTE_ORDER
+ 
+__BYTE_ORDER
+
+
+	)
+
+51 #i
+__BYTE_ORDER
+ =
+__LITTLE_ENDIAN
+
+
+52 
+	#__LONG_LONG_PAIR
+(
+HI
+, 
+LO
+LO, 
+	)
+HI
+
+53 #i
+__BYTE_ORDER
+ =
+__BIG_ENDIAN
+
+
+54 
+	#__LONG_LONG_PAIR
+(
+HI
+, 
+LO
+HI, 
+	)
+LO
+
+58 #i
+defed
+ 
+__USE_MISC
+ && !defed 
+__ASSEMBLER__
+
+
+60 
+	~<bs/bysw.h
+>
+
+62 #i
+__BYTE_ORDER
+ =
+__LITTLE_ENDIAN
+
+
+63 
+	#htobe16
+(
+x
+
+	`__bsw_16
+ (x)
+
+	)
+
+64 
+	#hte16
+(
+x
+(x)
+
+	)
+
+65 
+	#be16toh
+(
+x
+
+	`__bsw_16
+ (x)
+
+	)
+
+66 
+	#16toh
+(
+x
+(x)
+
+	)
+
+68 
+	#htobe32
+(
+x
+
+	`__bsw_32
+ (x)
+
+	)
+
+69 
+	#hte32
+(
+x
+(x)
+
+	)
+
+70 
+	#be32toh
+(
+x
+
+	`__bsw_32
+ (x)
+
+	)
+
+71 
+	#32toh
+(
+x
+(x)
+
+	)
+
+73 
+	#htobe64
+(
+x
+
+	`__bsw_64
+ (x)
+
+	)
+
+74 
+	#hte64
+(
+x
+(x)
+
+	)
+
+75 
+	#be64toh
+(
+x
+
+	`__bsw_64
+ (x)
+
+	)
+
+76 
+	#64toh
+(
+x
+(x)
+
+	)
+
+79 
+	#htobe16
+(
+x
+(x)
+
+	)
+
+80 
+	#hte16
+(
+x
+
+	`__bsw_16
+ (x)
+
+	)
+
+81 
+	#be16toh
+(
+x
+(x)
+
+	)
+
+82 
+	#16toh
+(
+x
+
+	`__bsw_16
+ (x)
+
+	)
+
+84 
+	#htobe32
+(
+x
+(x)
+
+	)
+
+85 
+	#hte32
+(
+x
+
+	`__bsw_32
+ (x)
+
+	)
+
+86 
+	#be32toh
+(
+x
+(x)
+
+	)
+
+87 
+	#32toh
+(
+x
+
+	`__bsw_32
+ (x)
+
+	)
+
+89 
+	#htobe64
+(
+x
+(x)
+
+	)
+
+90 
+	#hte64
+(
+x
+
+	`__bsw_64
+ (x)
+
+	)
+
+91 
+	#be64toh
+(
+x
+(x)
+
+	)
+
+92 
+	#64toh
+(
+x
+
+	`__bsw_64
+ (x)
+
+	)
+
+	@/usr/include/gnu/stubs.h
+
+6 #i!
+defed
+ 
+__x86_64__
+
+
+7 
+	~<gnu/ubs-32.h
+>
+
+9 #i
+defed
+ 
+__x86_64__
+ && defed 
+__LP64__
+
+
+10 
+	~<gnu/ubs-64.h
+>
+
+12 #i
+defed
+ 
+__x86_64__
+ && defed 
+__ILP32__
+
+
+13 
+	~<gnu/ubs-x32.h
+>
+
+	@/usr/include/stdc-predef.h
+
+18 #idef 
+_STDC_PREDEF_H
+
+
+19 
+	#_STDC_PREDEF_H
+ 1
+
+	)
+
+36 #ifde
+__GCC_IEC_559
+
+
+37 #i
+__GCC_IEC_559
+ > 0
+
+38 
+	#__STDC_IEC_559__
+ 1
+
+	)
+
+41 
+	#__STDC_IEC_559__
+ 1
+
+	)
+
+44 #ifde
+__GCC_IEC_559_COMPLEX
+
+
+45 #i
+__GCC_IEC_559_COMPLEX
+ > 0
+
+46 
+	#__STDC_IEC_559_COMPLEX__
+ 1
+
+	)
+
+49 
+	#__STDC_IEC_559_COMPLEX__
+ 1
+
+	)
+
+55 
+	#__STDC_ISO_10646__
+ 201505L
+
+	)
+
+58 
+	#__STDC_NO_THREADS__
+ 1
+
+	)
+
+	@/usr/include/sys/cdefs.h
+
+18 #idef 
+_SYS_CDEFS_H
+
+
+19 
+	#_SYS_CDEFS_H
+ 1
+
+	)
+
+22 #ide
+_FEATURES_H
+
+
+23 
+	~<us.h
+>
+
+29 #i
+defed
+ 
+__GNUC__
+ && !defed 
+__STDC__
+
+
+34 #unde
+__P
+
+
+35 #unde
+__PMT
+
+
+37 #ifde
+__GNUC__
+
+
+41 #i
+__GNUC_PREREQ
+ (4, 6&& !
+defed
+ 
+_LIBC
+
+
+42 
+	#__LEAF
+ , 
+__af__
+
+
+	)
+
+43 
+	#__LEAF_ATTR
+ 
+	`__ibu__
+ ((
+__af__
+))
+
+	)
+
+45 
+	#__LEAF
+
+
+	)
+
+46 
+	#__LEAF_ATTR
+
+
+	)
+
+54 #i!
+defed
+ 
+__lulus
+ && 
+__GNUC_PREREQ
+ (3, 3)
+
+55 
+	#__THROW
+ 
+	`__ibu__
+ ((
+__nhrow__
+ 
+__LEAF
+))
+
+	)
+
+56 
+	#__THROWNL
+ 
+	`__ibu__
+ ((
+__nhrow__
+))
+
+	)
+
+57 
+	#__NTH
+(
+f
+
+	`__ibu__
+ ((
+__nhrow__
+ 
+__LEAF
+)
+	)
+f
+
+59 #i
+defed
+ 
+__lulus
+ && 
+__GNUC_PREREQ
+ (2,8)
+
+60 
+	#__THROW
+ 
+	`throw
+ ()
+
+	)
+
+61 
+	#__THROWNL
+ 
+	`throw
+ ()
+
+	)
+
+62 
+	#__NTH
+(
+f
+
+__LEAF_ATTR
+ f 
+	`throw
+ ()
+
+	)
+
+64 
+	#__THROW
+
+
+	)
+
+65 
+	#__THROWNL
+
+
+	)
+
+66 
+	#__NTH
+(
+f
+
+	)
+f
+
+72 
+	#__le
+
+
+	)
+
+74 
+	#__THROW
+
+
+	)
+
+75 
+	#__THROWNL
+
+
+	)
+
+76 
+	#__NTH
+(
+f
+
+	)
+f
+
+82 
+	#__P
+(
+gs
+
+	)
+gs
+
+83 
+	#__PMT
+(
+gs
+
+	)
+gs
+
+88 
+	#__CONCAT
+(
+x
+,
+y
+x ## 
+	)
+y
+
+89 
+	#__STRING
+(
+x
+#x
+
+	)
+
+92 
+	#__r_t
+ *
+
+	)
+
+93 
+	#__lg_doub_t
+ 
+
+	)
+
+97 #ifdef 
+__lulus
+
+
+98 
+	#__BEGIN_DECLS
+ "C" {
+
+	)
+
+99 
+	#__END_DECLS
+ }
+
+	)
+
+101 
+	#__BEGIN_DECLS
+
+
+	)
+
+102 
+	#__END_DECLS
+
+
+	)
+
+111 #i
+defed
+ 
+__lulus
+ && defed 
+_GLIBCPP_USE_NAMESPACES
+
+
+112 
+	#__BEGIN_NAMESPACE_STD
+ 
+mea
+ 
+d
+ {
+
+	)
+
+113 
+	#__END_NAMESPACE_STD
+ }
+
+	)
+
+114 
+	#__USING_NAMESPACE_STD
+(
+me
+
+usg
+ 
+d
+::me;
+
+	)
+
+115 
+	#__BEGIN_NAMESPACE_C99
+ 
+mea
+ 
+__c99
+ {
+
+	)
+
+116 
+	#__END_NAMESPACE_C99
+ }
+
+	)
+
+117 
+	#__USING_NAMESPACE_C99
+(
+me
+
+usg
+ 
+__c99
+::me;
+
+	)
+
+122 
+	#__BEGIN_NAMESPACE_STD
+
+
+	)
+
+123 
+	#__END_NAMESPACE_STD
+
+
+	)
+
+124 
+	#__USING_NAMESPACE_STD
+(
+me
+)
+
+	)
+
+125 
+	#__BEGIN_NAMESPACE_C99
+
+
+	)
+
+126 
+	#__END_NAMESPACE_C99
+
+
+	)
+
+127 
+	#__USING_NAMESPACE_C99
+(
+me
+)
+
+	)
+
+132 
+	#__bos
+(
+r
+
+	`__but_obje_size
+ (r, 
+__USE_FORTIFY_LEVEL
+ > 1)
+
+	)
+
+133 
+	#__bos0
+(
+r
+
+	`__but_obje_size
+ (r, 0)
+
+	)
+
+135 #i
+__GNUC_PREREQ
+ (4,3)
+
+136 
+	#__wnde
+(
+me
+, 
+msg
+) \
+
+137 
+	`me
+ (
+	`__ibu__
+((
+	`__wng__
+ (
+msg
+)))
+
+	)
+
+138 
+	#__wr
+(
+msg
+
+	`__ibu__
+((
+	`__wng__
+ (msg)))
+
+	)
+
+139 
+	#__rde
+(
+me
+, 
+msg
+) \
+
+140 
+	`me
+ (
+	`__ibu__
+((
+	`__r__
+ (
+msg
+)))
+
+	)
+
+142 
+	#__wnde
+(
+me
+, 
+msg
+
+	`me
+ ()
+
+	)
+
+143 
+	#__wr
+(
+msg
+)
+
+	)
+
+144 
+	#__rde
+(
+me
+, 
+msg
+
+	`me
+ ()
+
+	)
+
+148 #i
+__GNUC_PREREQ
+ (2,97)
+
+150 
+	#__exr
+ []
+
+	)
+
+152 #ifde
+__GNUC__
+
+
+153 
+	#__exr
+ [0]
+
+	)
+
+155 #i
+defed
+ 
+__STDC_VERSION__
+ && __STDC_VERSION__ >= 199901L
+
+156 
+	#__exr
+ []
+
+	)
+
+159 
+	#__exr
+ [1]
+
+	)
+
+175 #i
+defed
+ 
+__GNUC__
+ && __GNUC__ >= 2
+
+177 
+	#__REDIRECT
+(
+me
+, 
+o
+, 
+s
+m
+	`__asm__
+ (
+	`__ASMNAME
+ (#s))
+
+	)
+
+178 #ifde
+__lulus
+
+
+179 
+	#__REDIRECT_NTH
+(
+me
+, 
+o
+, 
+s
+) \
+
+180 
+me
+ 
+o
+ 
+__THROW
+ 
+	`__asm__
+ (
+	`__ASMNAME
+ (#s))
+
+	)
+
+181 
+	#__REDIRECT_NTHNL
+(
+me
+, 
+o
+, 
+s
+) \
+
+182 
+me
+ 
+o
+ 
+__THROWNL
+ 
+	`__asm__
+ (
+	`__ASMNAME
+ (#s))
+
+	)
+
+184 
+	#__REDIRECT_NTH
+(
+me
+, 
+o
+, 
+s
+) \
+
+185 
+me
+ 
+o
+ 
+	`__asm__
+ (
+	`__ASMNAME
+ (#s)
+__THROW
+
+
+	)
+
+186 
+	#__REDIRECT_NTHNL
+(
+me
+, 
+o
+, 
+s
+) \
+
+187 
+me
+ 
+o
+ 
+	`__asm__
+ (
+	`__ASMNAME
+ (#s)
+__THROWNL
+
+
+	)
+
+189 
+	#__ASMNAME
+(
+ame
+
+	`__ASMNAME2
+ (
+__USER_LABEL_PREFIX__
+, cme)
+
+	)
+
+190 
+	#__ASMNAME2
+(
+efix
+, 
+ame
+
+	`__STRING
+ (efix
+	)
+ame
+
+203 #i!
+defed
+ 
+__GNUC__
+ || __GNUC__ < 2
+
+204 
+	#__ibu__
+(
+xyz
+
+
+	)
+
+210 #i
+__GNUC_PREREQ
+ (2,96)
+
+211 
+	#__ibu_mloc__
+ 
+	`__ibu__
+ ((
+__mloc__
+))
+
+	)
+
+213 
+	#__ibu_mloc__
+
+
+	)
+
+218 #i
+__GNUC_PREREQ
+ (4, 3)
+
+219 
+	#__ibu_loc_size__
+(
+ms
+) \
+
+220 
+	`__ibu__
+ ((
+__loc_size__
+ 
+ms
+))
+
+	)
+
+222 
+	#__ibu_loc_size__
+(
+ms
+
+
+	)
+
+228 #i
+__GNUC_PREREQ
+ (2,96)
+
+229 
+	#__ibu_pu__
+ 
+	`__ibu__
+ ((
+__pu__
+))
+
+	)
+
+231 
+	#__ibu_pu__
+
+
+	)
+
+235 #i
+__GNUC_PREREQ
+ (2,5)
+
+236 
+	#__ibu_c__
+ 
+	`__ibu__
+ ((
+__c__
+))
+
+	)
+
+238 
+	#__ibu_c__
+
+
+	)
+
+244 #i
+__GNUC_PREREQ
+ (3,1)
+
+245 
+	#__ibu_ud__
+ 
+	`__ibu__
+ ((
+__ud__
+))
+
+	)
+
+246 
+	#__ibu_nole__
+ 
+	`__ibu__
+ ((
+__nole__
+))
+
+	)
+
+248 
+	#__ibu_ud__
+ 
+	`__ibu__
+ ((
+__unud__
+))
+
+	)
+
+249 
+	#__ibu_nole__
+
+
+	)
+
+253 #i
+__GNUC_PREREQ
+ (3,2)
+
+254 
+	#__ibu_dd__
+ 
+	`__ibu__
+ ((
+__dd__
+))
+
+	)
+
+256 
+	#__ibu_dd__
+
+
+	)
+
+265 #i
+__GNUC_PREREQ
+ (2,8)
+
+266 
+	#__ibu_fm_g__
+(
+x
+
+	`__ibu__
+ ((
+	`__fm_g__
+ (x)))
+
+	)
+
+268 
+	#__ibu_fm_g__
+(
+x
+
+
+	)
+
+275 #i
+__GNUC_PREREQ
+ (2,97)
+
+276 
+	#__ibu_fm_rfm__
+(
+a
+,
+b
+) \
+
+277 
+	`__ibu__
+ ((
+	`__fm__
+ (
+__rfm__
+, 
+a
+, 
+b
+)))
+
+	)
+
+279 
+	#__ibu_fm_rfm__
+(
+a
+,
+b
+
+
+	)
+
+284 #i
+__GNUC_PREREQ
+ (3,3)
+
+285 
+	#__nnu
+(
+ms
+
+	`__ibu__
+ ((
+__nnu__
+ams))
+
+	)
+
+287 
+	#__nnu
+(
+ms
+)
+
+	)
+
+292 #i
+__GNUC_PREREQ
+ (3,4)
+
+293 
+	#__ibu_wn_unud_su__
+ \
+
+294 
+	`__ibu__
+ ((
+__wn_unud_su__
+))
+
+	)
+
+295 #i
+__USE_FORTIFY_LEVEL
+ > 0
+
+296 
+	#__wur
+ 
+__ibu_wn_unud_su__
+
+
+	)
+
+299 
+	#__ibu_wn_unud_su__
+
+
+	)
+
+301 #ide
+__wur
+
+
+302 
+	#__wur
+
+
+	)
+
+306 #i
+__GNUC_PREREQ
+ (3,2)
+
+307 
+	#__ways_le
+ 
+__le
+ 
+	`__ibu__
+ ((
+__ways_le__
+))
+
+	)
+
+309 
+	#__ways_le
+ 
+__le
+
+
+	)
+
+314 #i
+__GNUC_PREREQ
+ (4,3)
+
+315 
+	#__ibu_tificl__
+ 
+	`__ibu__
+ ((
+__tificl__
+))
+
+	)
+
+317 
+	#__ibu_tificl__
+
+
+	)
+
+329 #i(!
+defed
+ 
+__lulus
+ || 
+__GNUC_PREREQ
+ (4,3) \
+
+330 || (
+defed
+ 
+__g__
+ && (defed 
+__GNUC_STDC_INLINE__
+ \
+
+331 || 
+defed
+ 
+__GNUC_GNU_INLINE__
+)))
+
+332 #i
+defed
+ 
+__GNUC_STDC_INLINE__
+ || defed 
+__lulus
+
+
+333 
+	#__ex_le
+ 
+__le
+ 
+	`__ibu__
+ ((
+__gnu_le__
+))
+
+	)
+
+334 
+	#__ex_ways_le
+ \
+
+335 
+__ways_le
+ 
+	`__ibu__
+ ((
+__gnu_le__
+))
+
+	)
+
+337 
+	#__ex_le
+ 
+__le
+
+
+	)
+
+338 
+	#__ex_ways_le
+ 
+__ways_le
+
+
+	)
+
+342 #ifde
+__ex_ways_le
+
+
+343 
+	#__ftify_funi
+ 
+__ex_ways_le
+ 
+__ibu_tificl__
+
+
+	)
+
+348 #i
+__GNUC_PREREQ
+ (4,3)
+
+349 
+	#__va_g_ck
+(
+	`__but_va_g_ck
+ ()
+
+	)
+
+350 
+	#__va_g_ck_n
+(
+	`__but_va_g_ck_n
+ ()
+
+	)
+
+357 #i!
+__GNUC_PREREQ
+ (2,8)
+
+358 
+	#__exnsi__
+
+
+	)
+
+362 #i!
+__GNUC_PREREQ
+ (2,92)
+
+363 
+	#__ri
+
+
+	)
+
+369 #i
+__GNUC_PREREQ
+ (3,1&& !
+defed
+ 
+__GNUG__
+
+
+370 
+	#__ri_r
+ 
+__ri
+
+
+	)
+
+372 #ifde
+__GNUC__
+
+
+373 
+	#__ri_r
+
+
+	)
+
+375 #i
+defed
+ 
+__STDC_VERSION__
+ && __STDC_VERSION__ >= 199901L
+
+376 
+	#__ri_r
+ 
+ri
+
+
+	)
+
+379 
+	#__ri_r
+
+
+	)
+
+384 #i
+__GNUC__
+ >= 3
+
+385 
+	#__glibc_uiky
+(
+cd
+
+	`__but_ex
+ ((cd), 0)
+
+	)
+
+386 
+	#__glibc_liky
+(
+cd
+
+	`__but_ex
+ ((cd), 1)
+
+	)
+
+388 
+	#__glibc_uiky
+(
+cd
+(cd)
+
+	)
+
+389 
+	#__glibc_liky
+(
+cd
+(cd)
+
+	)
+
+392 #i(!
+defed
+ 
+_Nu
+ \
+
+393 && (
+defed
+ 
+__STDC_VERSION__
+ ? __STDC_VERSION__ : 0) < 201112 \
+
+394 && !
+	$__GNUC_PREREQ
+ (4,7))
+
+395 #i
+	`__GNUC_PREREQ
+ (2,8)
+
+396 
+	#_Nu
+ 
+	`__ibu__
+ ((
+__nu__
+))
+
+	)
+
+398 
+	#_Nu
+
+
+	)
+
+402 #i(!
+defed
+ 
+_Stic_as
+ && !defed 
+__lulus
+ \
+
+403 && (
+defed
+ 
+__STDC_VERSION__
+ ? __STDC_VERSION__ : 0) < 201112 \
+
+404 && (!
+	`__GNUC_PREREQ
+ (4, 6|| 
+defed
+ 
+__STRICT_ANSI__
+))
+
+405 
+	#_Stic_as
+(
+ex
+, 
+dgnoic
+) \
+
+406 (*
+	`__Stic_as_funi
+ ()) \
+
+407 [!! (ru { 
+__r_if_give
+: (
+ex
+? 2 : -1; })]
+
+	)
+
+410 
+	~<bs/wdsize.h
+>
+
+412 #i
+defed
+ 
+__LONG_DOUBLE_MATH_OPTIONAL
+ && defed 
+__NO_LONG_DOUBLE_MATH
+
+
+413 
+	#__LDBL_COMPAT
+ 1
+
+	)
+
+414 #ifde
+__REDIRECT
+
+
+415 
+	#__LDBL_REDIR1
+(
+me
+, 
+o
+, 
+s
+
+	`__REDIRECT
+ (me,ro,ls)
+
+	)
+
+416 
+	#__LDBL_REDIR
+(
+me
+, 
+o
+) \
+
+417 
+	`__LDBL_REDIR1
+ (
+me
+, 
+o
+, 
+__dbl_
+##me)
+
+	)
+
+418 
+	#__LDBL_REDIR1_NTH
+(
+me
+, 
+o
+, 
+s
+
+	`__REDIRECT_NTH
+ (me,ro,ls)
+
+	)
+
+419 
+	#__LDBL_REDIR_NTH
+(
+me
+, 
+o
+) \
+
+420 
+	`__LDBL_REDIR1_NTH
+ (
+me
+, 
+o
+, 
+__dbl_
+##me)
+
+	)
+
+421 
+	#__LDBL_REDIR1_DECL
+(
+me
+, 
+s
+) \
+
+422 
+	`__tyof
+ (
+me
+m
+	`__asm
+ (
+	`__ASMNAME
+ (#s));
+
+	)
+
+423 
+	#__LDBL_REDIR_DECL
+(
+me
+) \
+
+424 
+	`__tyof
+ (
+me
+m
+	`__asm
+ (
+	`__ASMNAME
+ ("__dbl_" #me));
+
+	)
+
+425 
+	#__REDIRECT_LDBL
+(
+me
+, 
+o
+, 
+s
+) \
+
+426 
+	`__LDBL_REDIR1
+ (
+me
+, 
+o
+, 
+__dbl_
+##
+s
+)
+
+	)
+
+427 
+	#__REDIRECT_NTH_LDBL
+(
+me
+, 
+o
+, 
+s
+) \
+
+428 
+	`__LDBL_REDIR1_NTH
+ (
+me
+, 
+o
+, 
+__dbl_
+##
+s
+)
+
+	)
+
+431 #i!
+defed
+ 
+__LDBL_COMPAT
+ || !defed 
+__REDIRECT
+
+
+432 
+	#__LDBL_REDIR1
+(
+me
+, 
+o
+, 
+s
+m
+	)
+o
+
+433 
+	#__LDBL_REDIR
+(
+me
+, 
+o
+m
+	)
+o
+
+434 
+	#__LDBL_REDIR1_NTH
+(
+me
+, 
+o
+, 
+s
+m
+__THROW
+
+
+	)
+
+435 
+	#__LDBL_REDIR_NTH
+(
+me
+, 
+o
+m
+__THROW
+
+
+	)
+
+436 
+	#__LDBL_REDIR_DECL
+(
+me
+)
+
+	)
+
+437 #ifde
+__REDIRECT
+
+
+438 
+	#__REDIRECT_LDBL
+(
+me
+, 
+o
+, 
+s
+
+	`__REDIRECT
+ (me,ro,ls)
+
+	)
+
+439 
+	#__REDIRECT_NTH_LDBL
+(
+me
+, 
+o
+, 
+s
+) \
+
+440 
+	`__REDIRECT_NTH
+ (
+me
+, 
+o
+, 
+s
+)
+
+	)
+
+	@/usr/include/sys/select.h
+
+21 #ide
+_SYS_SELECT_H
+
+
+22 
+	#_SYS_SELECT_H
+ 1
+
+	)
+
+24 
+	~<us.h
+>
+
+27 
+	~<bs/tys.h
+>
+
+30 
+	~<bs/.h
+>
+
+33 
+	~<bs/sigt.h
+>
+
+35 #ide
+__sigt_t_defed
+
+
+36 
+	#__sigt_t_defed
+
+
+	)
+
+37 
+__sigt_t
+ 
+	tsigt_t
+;
+
+41 
+	#__ed_time_t
+
+
+	)
+
+42 
+	#__ed_timeec
+
+
+	)
+
+43 
+	~<time.h
+>
+
+44 
+	#__ed_timev
+
+
+	)
+
+45 
+	~<bs/time.h
+>
+
+47 #ide
+__sucds_t_defed
+
+
+48 
+__sucds_t
+ 
+	tsucds_t
+;
+
+49 
+	#__sucds_t_defed
+
+
+	)
+
+54 
+	t__fd_mask
+;
+
+57 #unde
+__NFDBITS
+
+
+59 
+	#__NFDBITS
+ (8 * ( (
+__fd_mask
+))
+
+	)
+
+60 
+	#__FD_ELT
+(
+d
+((d/ 
+__NFDBITS
+)
+
+	)
+
+61 
+	#__FD_MASK
+(
+d
+((
+__fd_mask
+(1UL << ((d% 
+__NFDBITS
+)))
+
+	)
+
+68 #ifde
+__USE_XOPEN
+
+
+69 
+__fd_mask
+ 
+	mfds_bs
+[
+__FD_SETSIZE
+ / 
+__NFDBITS
+];
+
+70 
+	#__FDS_BITS
+(
+t
+((t)->
+fds_bs
+)
+
+	)
+
+72 
+__fd_mask
+ 
+	m__fds_bs
+[
+__FD_SETSIZE
+ / 
+__NFDBITS
+];
+
+73 
+	#__FDS_BITS
+(
+t
+((t)->
+__fds_bs
+)
+
+	)
+
+75 } 
+	tfd_t
+;
+
+78 
+	#FD_SETSIZE
+ 
+__FD_SETSIZE
+
+
+	)
+
+80 #ifde
+__USE_MISC
+
+
+82 
+__fd_mask
+ 
+	tfd_mask
+;
+
+85 
+	#NFDBITS
+ 
+__NFDBITS
+
+
+	)
+
+90 
+	#FD_SET
+(
+fd
+, 
+fd
+
+	`__FD_SET
+ (fd, fd)
+
+	)
+
+91 
+	#FD_CLR
+(
+fd
+, 
+fd
+
+	`__FD_CLR
+ (fd, fd)
+
+	)
+
+92 
+	#FD_ISSET
+(
+fd
+, 
+fd
+
+	`__FD_ISSET
+ (fd, fd)
+
+	)
+
+93 
+	#FD_ZERO
+(
+fd
+
+	`__FD_ZERO
+ (fd)
+
+	)
+
+96 
+__BEGIN_DECLS
+
+
+106 
+
+ (
+__nfds
+, 
+fd_t
+ *
+__ri
+ 
+__adfds
+,
+
+107 
+fd_t
+ *
+__ri
+ 
+__wrefds
+,
+
+108 
+fd_t
+ *
+__ri
+ 
+__exfds
+,
+
+109 
+timev
+ *
+__ri
+ 
+__timeout
+);
+
+111 #ifde
+__USE_XOPEN2K
+
+
+118 
+p
+ (
+__nfds
+, 
+fd_t
+ *
+__ri
+ 
+__adfds
+,
+
+119 
+fd_t
+ *
+__ri
+ 
+__wrefds
+,
+
+120 
+fd_t
+ *
+__ri
+ 
+__exfds
+,
+
+121 c 
+timeec
+ *
+__ri
+ 
+__timeout
+,
+
+122 c 
+__sigt_t
+ *
+__ri
+ 
+__sigmask
+);
+
+127 #i
+__USE_FORTIFY_LEVEL
+ > 0 && 
+defed
+ 
+__GNUC__
+
+
+128 
+	~<bs/2.h
+>
+
+131 
+	g__END_DECLS
+
+
+	@/usr/include/sys/sysmacros.h
+
+19 #ide
+_SYS_SYSMACROS_H
+
+
+20 
+	#_SYS_SYSMACROS_H
+ 1
+
+	)
+
+22 
+	~<us.h
+>
+
+24 
+__BEGIN_DECLS
+
+
+26 
+__exnsi__
+
+
+27 
+	$gnu_dev_maj
+ (
+__dev
+)
+
+28 
+__THROW
+ 
+__ibu_c__
+;
+
+29 
+__exnsi__
+
+
+30 
+	$gnu_dev_m
+ (
+__dev
+)
+
+31 
+__THROW
+ 
+__ibu_c__
+;
+
+32 
+__exnsi__
+
+
+33 
+	$gnu_dev_makedev
+ (
+__maj
+,
+
+34 
+__m
+)
+
+35 
+__THROW
+ 
+__ibu_c__
+;
+
+37 #ifde
+__USE_EXTERN_INLINES
+
+
+38 
+__exnsi__
+ 
+__ex_le
+ 
+__ibu_c__
+ 
+
+39 
+	`__NTH
+ (
+	$gnu_dev_maj
+ (
+__dev
+))
+
+41  ((
+__dev
+ >> 8) & 0xfff) | (() (__dev >> 32) & ~0xfff);
+
+42 
+	}
+}
+
+44 
+__exnsi__
+ 
+__ex_le
+ 
+__ibu_c__
+ 
+
+45 
+__NTH
+ (
+	$gnu_dev_m
+ (
+__dev
+))
+
+47  (
+__dev
+ & 0xff) | (() (__dev >> 12) & ~0xff);
+
+48 
+	}
+}
+
+50 
+__exnsi__
+ 
+__ex_le
+ 
+__ibu_c__
+ 
+
+51 
+__NTH
+ (
+	$gnu_dev_makedev
+ (
+__maj
+, 
+__m
+))
+
+53  ((
+__m
+ & 0xff| ((
+__maj
+ & 0xfff) << 8)
+
+54 | ((((
+__m
+ & ~0xff)) << 12)
+
+55 | ((((
+__maj
+ & ~0xfff)) << 32));
+
+56 
+	}
+}
+
+58 
+	g__END_DECLS
+
+
+61 
+	#maj
+(
+dev
+
+	`gnu_dev_maj
+ (dev)
+
+	)
+
+62 
+	#m
+(
+dev
+
+	`gnu_dev_m
+ (dev)
+
+	)
+
+63 
+	#makedev
+(
+maj
+, 
+m
+
+	`gnu_dev_makedev
+ (maj, m)
+
+	)
+
+	@/usr/include/time.h
+
+22 #idef 
+_TIME_H
+
+
+24 #i(! 
+defed
+ 
+__ed_time_t
+ && !defed 
+__ed_ock_t
+ && \
+
+25 ! 
+defed
+ 
+	g__ed_timeec
+)
+
+26 
+	#_TIME_H
+ 1
+
+	)
+
+27 
+	~<us.h
+>
+
+29 
+	g__BEGIN_DECLS
+
+
+33 #ifdef 
+_TIME_H
+
+
+35 
+	#__ed_size_t
+
+
+	)
+
+36 
+	#__ed_NULL
+
+
+	)
+
+37 
+	~<ddef.h
+>
+
+41 
+	~<bs/time.h
+>
+
+44 #i!
+defed
+ 
+__STRICT_ANSI__
+ && !defed 
+__USE_XOPEN2K
+
+
+45 #ide
+CLK_TCK
+
+
+46 
+	#CLK_TCK
+ 
+CLOCKS_PER_SEC
+
+
+	)
+
+52 #i!
+defed
+ 
+__ock_t_defed
+ && (defed 
+_TIME_H
+ || defed 
+__ed_ock_t
+)
+
+53 
+	#__ock_t_defed
+ 1
+
+	)
+
+55 
+	~<bs/tys.h
+>
+
+57 
+__BEGIN_NAMESPACE_STD
+
+
+59 
+__ock_t
+ 
+	tock_t
+;
+
+60 
+	g__END_NAMESPACE_STD
+
+
+61 #i
+defed
+ 
+__USE_XOPEN
+ || defed 
+__USE_POSIX
+
+
+62 
+	$__USING_NAMESPACE_STD
+(
+ock_t
+)
+
+66 #unde
+__ed_ock_t
+
+
+68 #i!
+defed
+ 
+__time_t_defed
+ && (defed 
+_TIME_H
+ || defed 
+__ed_time_t
+)
+
+69 
+	#__time_t_defed
+ 1
+
+	)
+
+71 
+	~<bs/tys.h
+>
+
+73 
+__BEGIN_NAMESPACE_STD
+
+
+75 
+__time_t
+ 
+	ttime_t
+;
+
+76 
+__END_NAMESPACE_STD
+
+
+77 #ifde
+__USE_POSIX
+
+
+78 
+	$__USING_NAMESPACE_STD
+(
+time_t
+)
+
+82 #unde
+__ed_time_t
+
+
+84 #i!
+defed
+ 
+__ockid_t_defed
+ && \
+
+85 ((
+defed
+ 
+_TIME_H
+ && defed 
+__USE_POSIX199309
+|| defed 
+__ed_ockid_t
+)
+
+86 
+	#__ockid_t_defed
+ 1
+
+	)
+
+88 
+	~<bs/tys.h
+>
+
+91 
+__ockid_t
+ 
+	tockid_t
+;
+
+94 #unde
+__ockid_time_t
+
+
+96 #i!
+defed
+ 
+__tim_t_defed
+ && \
+
+97 ((
+defed
+ 
+_TIME_H
+ && defed 
+__USE_POSIX199309
+|| defed 
+__ed_tim_t
+)
+
+98 
+	#__tim_t_defed
+ 1
+
+	)
+
+100 
+	~<bs/tys.h
+>
+
+103 
+__tim_t
+ 
+	ttim_t
+;
+
+106 #unde
+__ed_tim_t
+
+
+109 #i(!
+defed
+ 
+__timeec_defed
+ \
+
+110 && ((
+defed
+ 
+_TIME_H
+ \
+
+111 && (
+defed
+ 
+__USE_POSIX199309
+ \
+
+112 || 
+defed
+ 
+__USE_ISOC11
+)) \
+
+113 || 
+defed
+ 
+__ed_timeec
+))
+
+114 
+	#__timeec_defed
+ 1
+
+	)
+
+116 
+	~<bs/tys.h
+>
+
+120 
+	stimeec
+
+
+122 
+__time_t
+ 
+tv_c
+;
+
+123 
+__sys_g_t
+ 
+tv_nc
+;
+
+127 #unde
+__ed_timeec
+
+
+130 #ifdef 
+_TIME_H
+
+
+131 
+__BEGIN_NAMESPACE_STD
+
+
+133 
+	stm
+
+
+135 
+tm_c
+;
+
+136 
+tm_m
+;
+
+137 
+tm_hour
+;
+
+138 
+tm_mday
+;
+
+139 
+tm_m
+;
+
+140 
+tm_yr
+;
+
+141 
+tm_wday
+;
+
+142 
+tm_yday
+;
+
+143 
+tm_isd
+;
+
+145 #ifdef 
+__USE_MISC
+
+
+146 
+tm_gmtoff
+;
+
+147 c *
+tm_ze
+;
+
+149 
+__tm_gmtoff
+;
+
+150 c *
+__tm_ze
+;
+
+153 
+__END_NAMESPACE_STD
+
+
+154 #i
+defed
+ 
+__USE_XOPEN
+ || defed 
+__USE_POSIX
+
+
+155 
+	$__USING_NAMESPACE_STD
+(
+tm
+)
+
+159 #ifde
+__USE_POSIX199309
+
+
+161 
+	simec
+
+
+163 
+timeec
+ 
+_rv
+;
+
+164 
+timeec
+ 
+_vue
+;
+
+168 
+sigevt
+;
+
+172 #ifde
+__USE_XOPEN2K
+
+
+173 #ide
+__pid_t_defed
+
+
+174 
+__pid_t
+ 
+	tpid_t
+;
+
+175 
+	#__pid_t_defed
+
+
+	)
+
+180 #ifde
+__USE_ISOC11
+
+
+182 
+	#TIME_UTC
+ 1
+
+	)
+
+186 
+__BEGIN_NAMESPACE_STD
+
+
+189 
+ock_t
+ 
+	$ock
+ (
+__THROW
+;
+
+192 
+time_t
+ 
+	$time
+ (
+time_t
+ *
+__tim
+
+__THROW
+;
+
+195 
+	$difime
+ (
+time_t
+ 
+__time1
+,ime_
+__time0
+)
+
+196 
+__THROW
+ 
+	`__ibu__
+ ((
+__c__
+));
+
+199 
+time_t
+ 
+	$mktime
+ (
+tm
+ *
+__
+
+__THROW
+;
+
+205 
+size_t
+ 
+	$rime
+ (*
+__ri
+ 
+__s
+, 
+size_t
+ 
+__maxsize
+,
+
+206 c *
+__ri
+ 
+__fm
+,
+
+207 c 
+tm
+ *
+__ri
+ 
+__
+
+__THROW
+;
+
+208 
+__END_NAMESPACE_STD
+
+
+210 #ifde
+__USE_XOPEN
+
+
+213 *
+	$time
+ (c *
+__ri
+ 
+__s
+,
+
+214 c *
+__ri
+ 
+__fmt
+, 
+tm
+ *
+__
+)
+
+215 
+__THROW
+;
+
+218 #ifde
+__USE_XOPEN2K8
+
+
+221 
+	~<xlo.h
+>
+
+223 
+size_t
+ 
+	$rime_l
+ (*
+__ri
+ 
+__s
+, 
+size_t
+ 
+__maxsize
+,
+
+224 c *
+__ri
+ 
+__fm
+,
+
+225 c 
+tm
+ *
+__ri
+ 
+__
+,
+
+226 
+__lo_t
+ 
+__loc
+
+__THROW
+;
+
+229 #ifde
+__USE_GNU
+
+
+230 *
+	$time_l
+ (c *
+__ri
+ 
+__s
+,
+
+231 c *
+__ri
+ 
+__fmt
+, 
+tm
+ *
+__
+,
+
+232 
+__lo_t
+ 
+__loc
+
+__THROW
+;
+
+236 
+__BEGIN_NAMESPACE_STD
+
+
+239 
+tm
+ *
+	$gmtime
+ (c 
+time_t
+ *
+__tim
+
+__THROW
+;
+
+243 
+tm
+ *
+	$loime
+ (c 
+time_t
+ *
+__tim
+
+__THROW
+;
+
+244 
+__END_NAMESPACE_STD
+
+
+246 #ifde
+__USE_POSIX
+
+
+249 
+tm
+ *
+	$gmtime_r
+ (c 
+time_t
+ *
+__ri
+ 
+__tim
+,
+
+250 
+tm
+ *
+__ri
+ 
+__
+
+__THROW
+;
+
+254 
+tm
+ *
+	$loime_r
+ (c 
+time_t
+ *
+__ri
+ 
+__tim
+,
+
+255 
+tm
+ *
+__ri
+ 
+__
+
+__THROW
+;
+
+258 
+__BEGIN_NAMESPACE_STD
+
+
+261 *
+	$asime
+ (c 
+tm
+ *
+__
+
+__THROW
+;
+
+264 *
+	$ime
+ (c 
+time_t
+ *
+__tim
+
+__THROW
+;
+
+265 
+__END_NAMESPACE_STD
+
+
+267 #ifde
+__USE_POSIX
+
+
+272 *
+	$asime_r
+ (c 
+tm
+ *
+__ri
+ 
+__
+,
+
+273 *
+__ri
+ 
+__buf
+
+__THROW
+;
+
+276 *
+	$ime_r
+ (c 
+time_t
+ *
+__ri
+ 
+__tim
+,
+
+277 *
+__ri
+ 
+__buf
+
+__THROW
+;
+
+282 *
+__tzme
+[2];
+
+283 
+__daylight
+;
+
+284 
+__timeze
+;
+
+287 #ifdef 
+__USE_POSIX
+
+
+289 *
+tzme
+[2];
+
+293 
+	$tzt
+ (
+__THROW
+;
+
+296 #i
+defed
+ 
+__USE_MISC
+ || defed 
+__USE_XOPEN
+
+
+297 
+daylight
+;
+
+298 
+timeze
+;
+
+301 #ifde
+__USE_MISC
+
+
+304 
+	$ime
+ (c 
+time_t
+ *
+__wh
+
+__THROW
+;
+
+310 
+	#__ip
+(
+yr
+) \
+
+311 ((
+yr
+% 4 =0 && ((yr% 100 !0 || (yr% 400 =0))
+
+	)
+
+314 #ifde
+__USE_MISC
+
+
+319 
+time_t
+ 
+	$timegm
+ (
+tm
+ *
+__
+
+__THROW
+;
+
+322 
+time_t
+ 
+	$timol
+ (
+tm
+ *
+__
+
+__THROW
+;
+
+325 
+	$dysize
+ (
+__yr
+
+__THROW
+ 
+	`__ibu__
+ ((
+__c__
+));
+
+329 #ifde
+__USE_POSIX199309
+
+
+334 
+	`nop
+ (c 
+timeec
+ *
+__queed_time
+,
+
+335 
+timeec
+ *
+__mag
+);
+
+339 
+	$ock_gs
+ (
+ockid_t
+ 
+__ock_id
+, 
+timeec
+ *
+__s
+
+__THROW
+;
+
+342 
+	$ock_gtime
+ (
+ockid_t
+ 
+__ock_id
+, 
+timeec
+ *
+__
+
+__THROW
+;
+
+345 
+	$ock_ime
+ (
+ockid_t
+ 
+__ock_id
+, c 
+timeec
+ *
+__
+)
+
+346 
+__THROW
+;
+
+348 #ifde
+__USE_XOPEN2K
+
+
+353 
+	`ock_nop
+ (
+ockid_t
+ 
+__ock_id
+, 
+__ags
+,
+
+354 c 
+timeec
+ *
+__q
+,
+
+355 
+timeec
+ *
+__m
+);
+
+358 
+	$ock_guockid
+ (
+pid_t
+ 
+__pid
+, 
+ockid_t
+ *
+__ock_id
+
+__THROW
+;
+
+363 
+	$tim_
+ (
+ockid_t
+ 
+__ock_id
+,
+
+364 
+sigevt
+ *
+__ri
+ 
+__evp
+,
+
+365 
+tim_t
+ *
+__ri
+ 
+__timid
+
+__THROW
+;
+
+368 
+	$tim_de
+ (
+tim_t
+ 
+__timid
+
+__THROW
+;
+
+371 
+	$tim_ime
+ (
+tim_t
+ 
+__timid
+, 
+__ags
+,
+
+372 c 
+imec
+ *
+__ri
+ 
+__vue
+,
+
+373 
+imec
+ *
+__ri
+ 
+__ovue
+
+__THROW
+;
+
+376 
+	$tim_gtime
+ (
+tim_t
+ 
+__timid
+, 
+imec
+ *
+__vue
+)
+
+377 
+__THROW
+;
+
+380 
+	$tim_govrun
+ (
+tim_t
+ 
+__timid
+
+__THROW
+;
+
+384 #ifde
+__USE_ISOC11
+
+
+386 
+	$timeec_g
+ (
+timeec
+ *
+__ts
+, 
+__ba
+)
+
+387 
+__THROW
+ 
+	`__nnu
+ ((1));
+
+391 #ifde
+__USE_XOPEN_EXTENDED
+
+
+403 
+gde_r
+;
+
+412 
+tm
+ *
+	`gde
+ (c *
+__rg
+);
+
+415 #ifde
+__USE_GNU
+
+
+426 
+	`gde_r
+ (c *
+__ri
+ 
+__rg
+,
+
+427 
+tm
+ *
+__ri
+ 
+__sbu
+);
+
+430 
+__END_DECLS
+
+
+	@/usr/include/bits/byteswap.h
+
+19 #i!
+defed
+ 
+_BYTESWAP_H
+ && !defed 
+_NETINET_IN_H
+ && !defed 
+_ENDIAN_H
+
+
+23 #ide
+_BITS_BYTESWAP_H
+
+
+24 
+	#_BITS_BYTESWAP_H
+ 1
+
+	)
+
+26 
+	~<us.h
+>
+
+27 
+	~<bs/tys.h
+>
+
+28 
+	~<bs/wdsize.h
+>
+
+31 
+	#__bsw_ct_16
+(
+x
+) \
+
+32 ((((((
+x
+>> 8& 0xff| (((x& 0xff<< 8)))
+
+	)
+
+35 
+	~<bs/bysw-16.h
+>
+
+38 
+	#__bsw_ct_32
+(
+x
+) \
+
+39 ((((
+x
+) & 0xff000000) >> 24) | (((x) & 0x00ff0000) >> 8) | \
+
+40 (((
+x
+& 0x0000ff00<< 8| (((x& 0x000000ff<< 24))
+
+	)
+
+42 #ifde
+__GNUC__
+
+
+43 #i
+__GNUC_PREREQ
+ (4, 3)
+
+44 
+__le
+ 
+
+45 
+	$__bsw_32
+ (
+__bsx
+)
+
+47  
+	`__but_bsw32
+ (
+__bsx
+);
+
+48 
+	}
+}
+
+49 #i
+__GNUC__
+ >= 2
+
+50 #i
+__WORDSIZE
+ =64 || (
+defed
+ 
+__i486__
+ || defed 
+__ium__
+ \
+
+51 || 
+defed
+ 
+	g__iumo__
+ || defed 
+	g__ium4__
+ \
+
+52 || 
+defed
+ 
+	g__k8__
+ || defed 
+	g__hl__
+ \
+
+53 || 
+defed
+ 
+	g__k6__
+ || defed 
+	g__noca__
+ \
+
+54 || 
+defed
+ 
+	g__ce2__
+ || defed 
+	g__geode__
+ \
+
+55 || 
+defed
+ 
+	g__amdm10__
+)
+
+58 
+	#__bsw_32
+(
+x
+) \
+
+59 (
+__exnsi__
+ \
+
+60 ({ 
+__v
+, 
+__x
+ = (
+x
+); \
+
+61 i(
+	`__but_ct_p
+ (
+__x
+)) \
+
+62 
+__v
+ = 
+	`__bsw_ct_32
+ (
+__x
+); \
+
+64 
+	`__asm__
+ ("bsw %0" : "" (
+__v
+: "0" (
+__x
+)); \
+
+65 
+__v
+; }))
+
+	)
+
+67 
+	#__bsw_32
+(
+x
+) \
+
+68 (
+__exnsi__
+ \
+
+69 ({ 
+__v
+, 
+__x
+ = (
+x
+); \
+
+70 i(
+	`__but_ct_p
+ (
+__x
+)) \
+
+71 
+__v
+ = 
+	`__bsw_ct_32
+ (
+__x
+); \
+
+73 
+	`__asm__
+ ("rorw $8, %w0;" \
+
+76 : "" (
+__v
+) \
+
+77 : "0" (
+__x
+) \
+
+79 
+__v
+; }))
+
+	)
+
+82 
+	#__bsw_32
+(
+x
+) \
+
+83 (
+__exnsi__
+ \
+
+84 ({ 
+__x
+ = (
+x
+); 
+	`__bsw_ct_32
+ (__x); }))
+
+	)
+
+87 
+__le
+ 
+
+88 
+	$__bsw_32
+ (
+__bsx
+)
+
+90  
+	`__bsw_ct_32
+ (
+__bsx
+);
+
+91 
+	}
+}
+
+95 #i
+__GNUC_PREREQ
+ (2, 0)
+
+97 
+	#__bsw_ct_64
+(
+x
+) \
+
+98 (
+	`__exnsi__
+ ((((
+x
+) & 0xff00000000000000ull) >> 56) \
+
+99 | (((
+x
+) & 0x00ff000000000000ull) >> 40) \
+
+100 | (((
+x
+) & 0x0000ff0000000000ull) >> 24) \
+
+101 | (((
+x
+) & 0x000000ff00000000ull) >> 8) \
+
+102 | (((
+x
+) & 0x00000000ff000000ull) << 8) \
+
+103 | (((
+x
+) & 0x0000000000ff0000ull) << 24) \
+
+104 | (((
+x
+) & 0x000000000000ff00ull) << 40) \
+
+105 | (((
+x
+& 0x00000000000000ffu<< 56)))
+
+	)
+
+107 #i
+__GNUC_PREREQ
+ (4, 3)
+
+108 
+__le
+ 
+__ut64_t
+
+
+109 
+	$__bsw_64
+ (
+__ut64_t
+ 
+__bsx
+)
+
+111  
+	`__but_bsw64
+ (
+__bsx
+);
+
+112 
+	}
+}
+
+113 #i
+__WORDSIZE
+ == 64
+
+114 
+	#__bsw_64
+(
+x
+) \
+
+115 (
+__exnsi__
+ \
+
+116 ({ 
+__ut64_t
+ 
+__v
+, 
+__x
+ = (
+x
+); \
+
+117 i(
+	`__but_ct_p
+ (
+__x
+)) \
+
+118 
+__v
+ = 
+	`__bsw_ct_64
+ (
+__x
+); \
+
+120 
+	`__asm__
+ ("bsw %q0" : "" (
+__v
+: "0" (
+__x
+)); \
+
+121 
+__v
+; }))
+
+	)
+
+123 
+	#__bsw_64
+(
+x
+) \
+
+124 (
+__exnsi__
+ \
+
+125 ({ uni { 
+__exnsi__
+ 
+__ut64_t
+ 
+__
+; \
+
+126 
+__l
+[2]; } 
+__w
+, 
+__r
+; \
+
+127 i(
+	`__but_ct_p
+ (
+x
+)) \
+
+128 
+__r
+.
+__
+ = 
+	`__bsw_ct_64
+ (
+x
+); \
+
+131 
+__w
+.
+__
+ = (
+x
+); \
+
+132 
+__r
+.
+__l
+[0] = 
+	`__bsw_32
+ (
+__w
+.__l[1]); \
+
+133 
+__r
+.
+__l
+[1] = 
+	`__bsw_32
+ (
+__w
+.__l[0]); \
+
+135 
+__r
+.
+__
+; }))
+
+	)
+
+138 
+	#__bsw_ct_64
+(
+x
+) \
+
+139 ((((
+x
+) & 0xff00000000000000ull) >> 56) \
+
+140 | (((
+x
+) & 0x00ff000000000000ull) >> 40) \
+
+141 | (((
+x
+) & 0x0000ff0000000000ull) >> 24) \
+
+142 | (((
+x
+) & 0x000000ff00000000ull) >> 8) \
+
+143 | (((
+x
+) & 0x00000000ff000000ull) << 8) \
+
+144 | (((
+x
+) & 0x0000000000ff0000ull) << 24) \
+
+145 | (((
+x
+) & 0x000000000000ff00ull) << 40) \
+
+146 | (((
+x
+& 0x00000000000000ffu<< 56))
+
+	)
+
+148 
+__le
+ 
+__ut64_t
+
+
+149 
+	$__bsw_64
+ (
+__ut64_t
+ 
+__bsx
+)
+
+151  
+	`__bsw_ct_64
+ (
+__bsx
+);
+
+152 
+	}
+}
+
+	@/usr/include/bits/endian.h
+
+3 #ide
+_ENDIAN_H
+
+
+7 
+	#__BYTE_ORDER
+ 
+__LITTLE_ENDIAN
+
+
+	)
+
+	@/usr/include/bits/select.h
+
+18 #ide
+_SYS_SELECT_H
+
+
+22 
+	~<bs/wdsize.h
+>
+
+25 #i
+defed
+ 
+__GNUC__
+ && __GNUC__ >= 2
+
+27 #i
+__WORDSIZE
+ == 64
+
+28 
+	#__FD_ZERO_STOS
+ "osq"
+
+	)
+
+30 
+	#__FD_ZERO_STOS
+ "o"
+
+	)
+
+33 
+	#__FD_ZERO
+(
+fd
+) \
+
+35 
+__d0
+, 
+__d1
+; \
+
+36 
+__asm__
+ 
+	`__ve__
+ ("d;; " 
+__FD_ZERO_STOS
+ \
+
+37 : "=c" (
+__d0
+), "=D" (
+__d1
+) \
+
+38 : "a" (0), "0" ( (
+fd_t
+) \
+
+39 /  (
+__fd_mask
+)), \
+
+40 "1" (&
+	`__FDS_BITS
+ (
+fd
+)[0]) \
+
+42 } 0)
+
+	)
+
+48 
+	#__FD_ZERO
+(
+t
+) \
+
+50 
+__i
+; \
+
+51 
+fd_t
+ *
+__r
+ = (
+t
+); \
+
+52 
+__i
+ = 0; __<  (
+fd_t
+/  (
+__fd_mask
+); ++__i) \
+
+53 
+	`__FDS_BITS
+ (
+__r
+)[
+__i
+] = 0; \
+
+54 } 0)
+
+	)
+
+58 
+	#__FD_SET
+(
+d
+, 
+t
+) \
+
+59 (((
+	`__FDS_BITS
+ (
+t
+)[
+	`__FD_ELT
+ (
+d
+)] |
+	`__FD_MASK
+ (d)))
+
+	)
+
+60 
+	#__FD_CLR
+(
+d
+, 
+t
+) \
+
+61 (((
+	`__FDS_BITS
+ (
+t
+)[
+	`__FD_ELT
+ (
+d
+)] &~
+	`__FD_MASK
+ (d)))
+
+	)
+
+62 
+	#__FD_ISSET
+(
+d
+, 
+t
+) \
+
+63 ((
+	`__FDS_BITS
+ (
+t
+)[
+	`__FD_ELT
+ (
+d
+)] & 
+	`__FD_MASK
+ (d)!0)
+
+	)
+
+	@/usr/include/bits/select2.h
+
+19 #ide
+_SYS_SELECT_H
+
+
+24 
+__fdt_chk
+ (
+__d
+);
+
+25 
+	$__fdt_wn
+ (
+__d
+)
+
+26 
+	`__wr
+ ("bit outside of fd_set selected");
+
+27 #unde
+__FD_ELT
+
+
+28 
+	#__FD_ELT
+(
+d
+) \
+
+29 
+__exnsi__
+ \
+
+30 ({ 
+__d
+ = (
+d
+); \
+
+31 (
+	`__but_ct_p
+ (
+__d
+) \
+
+32 ? (0 <
+__d
+ && __d < 
+__FD_SETSIZE
+ \
+
+33 ? (
+__d
+ / 
+__NFDBITS
+) \
+
+34 : 
+	`__fdt_wn
+ (
+__d
+)) \
+
+35 : 
+	`__fdt_chk
+ (
+__d
+)); 
+	}
+})
+
+	)
+
+	@/usr/include/bits/sigset.h
+
+19 #idef 
+_SIGSET_H_tys
+
+
+20 
+	#_SIGSET_H_tys
+ 1
+
+	)
+
+22 
+	t__sig_omic_t
+;
+
+26 
+	#_SIGSET_NWORDS
+ (1024 / (8 *  ()))
+
+	)
+
+29 
+	m__v
+[
+_SIGSET_NWORDS
+];
+
+30 } 
+	t__sigt_t
+;
+
+41 #i!
+defed
+ 
+_SIGSET_H_s
+ && defed 
+_SIGNAL_H
+
+
+42 
+	#_SIGSET_H_s
+ 1
+
+	)
+
+44 #ide
+_EXTERN_INLINE
+
+
+45 
+	#_EXTERN_INLINE
+ 
+__ex_le
+
+
+	)
+
+49 
+	#__sigmask
+(
+sig
+) \
+
+50 (((1<< (((
+sig
+- 1% (8 *  ())))
+
+	)
+
+53 
+	#__sigwd
+(
+sig
+(((sig- 1/ (8 *  ()))
+
+	)
+
+55 #i
+defed
+ 
+__GNUC__
+ && __GNUC__ >= 2
+
+56 
+	#__sigemyt
+(
+t
+) \
+
+57 (
+	`__exnsi__
+ ({ 
+__t
+ = 
+_SIGSET_NWORDS
+; \
+
+58 
+sigt_t
+ *
+__t
+ = (
+t
+); \
+
+59 --
+__t
+ >0
+__t
+->
+__v
+[__cnt] = 0; \
+
+60 0; }))
+
+	)
+
+61 
+	#__sigflt
+(
+t
+) \
+
+62 (
+	`__exnsi__
+ ({ 
+__t
+ = 
+_SIGSET_NWORDS
+; \
+
+63 
+sigt_t
+ *
+__t
+ = (
+t
+); \
+
+64 --
+__t
+ >0
+__t
+->
+__v
+[__cnt] = ~0UL; \
+
+65 0; }))
+
+	)
+
+67 #ifde
+__USE_GNU
+
+
+71 
+	#__sigimyt
+(
+t
+) \
+
+72 (
+	`__exnsi__
+ ({ 
+__t
+ = 
+_SIGSET_NWORDS
+; \
+
+73 c 
+sigt_t
+ *
+__t
+ = (
+t
+); \
+
+74 
+__t
+ = 
+__t
+->
+__v
+[--
+__t
+]; \
+
+75 !
+__t
+ && --
+__t
+ >= 0) \
+
+76 
+__t
+ = 
+__t
+->
+__v
+[
+__t
+]; \
+
+77 
+__t
+ =0; }))
+
+	)
+
+78 
+	#__sigdt
+(
+de
+, 
+
+, 
+right
+) \
+
+79 (
+	`__exnsi__
+ ({ 
+__t
+ = 
+_SIGSET_NWORDS
+; \
+
+80 
+sigt_t
+ *
+__de
+ = (
+de
+); \
+
+81 c 
+sigt_t
+ *
+__
+ = (
+
+); \
+
+82 c 
+sigt_t
+ *
+__right
+ = (
+right
+); \
+
+83 --
+__t
+ >= 0) \
+
+84 
+__de
+->
+__v
+[
+__t
+] = (
+__
+->__val[__cnt] \
+
+85 & 
+__right
+->
+__v
+[
+__t
+]); \
+
+86 0; }))
+
+	)
+
+87 
+	#__sigt
+(
+de
+, 
+
+, 
+right
+) \
+
+88 (
+	`__exnsi__
+ ({ 
+__t
+ = 
+_SIGSET_NWORDS
+; \
+
+89 
+sigt_t
+ *
+__de
+ = (
+de
+); \
+
+90 c 
+sigt_t
+ *
+__
+ = (
+
+); \
+
+91 c 
+sigt_t
+ *
+__right
+ = (
+right
+); \
+
+92 --
+__t
+ >= 0) \
+
+93 
+__de
+->
+__v
+[
+__t
+] = (
+__
+->__val[__cnt] \
+
+94 | 
+__right
+->
+__v
+[
+__t
+]); \
+
+95 0; }))
+
+	)
+
+102 
+__sigismemb
+ (c 
+__sigt_t
+ *, );
+
+103 
+__sigaddt
+ (
+__sigt_t
+ *, );
+
+104 
+__sigdt
+ (
+__sigt_t
+ *, );
+
+106 #ifde
+__USE_EXTERN_INLINES
+
+
+107 
+	#__SIGSETFN
+(
+NAME
+, 
+BODY
+, 
+CONST
+) \
+
+108 
+_EXTERN_INLINE
+ \
+
+109 
+	`NAME
+ (
+CONST
+ 
+__sigt_t
+ *
+__t
+, 
+__sig
+) \
+
+111 
+__mask
+ = 
+	`__sigmask
+ (
+__sig
+); \
+
+112 
+__wd
+ = 
+	`__sigwd
+ (
+__sig
+); \
+
+113  
+BODY
+; \
+
+114 }
+
+	)
+
+116 
+__SIGSETFN
+ (
+__sigismemb
+, (
+__t
+->
+__v
+[
+__wd
+] & 
+__mask
+) ? 1 : 0, const)
+
+117 
+__SIGSETFN
+ (
+__sigaddt
+, ((
+__t
+->
+__v
+[
+__wd
+] |
+__mask
+), 0), )
+
+118 
+__SIGSETFN
+ (
+__sigdt
+, ((
+__t
+->
+__v
+[
+__wd
+] &~
+__mask
+), 0), )
+
+120 #unde
+__SIGSETFN
+
+
+	@/usr/include/bits/time.h
+
+23 #i
+defed
+ 
+__ed_timev
+ || defed 
+__USE_GNU
+
+
+24 #ide
+_STRUCT_TIMEVAL
+
+
+25 
+	#_STRUCT_TIMEVAL
+ 1
+
+	)
+
+26 
+	~<bs/tys.h
+>
+
+30 
+	stimev
+
+
+32 
+__time_t
+ 
+	mtv_c
+;
+
+33 
+__sucds_t
+ 
+	mtv_uc
+;
+
+38 #ide
+__ed_timev
+
+
+39 #ide
+_BITS_TIME_H
+
+
+40 
+	#_BITS_TIME_H
+ 1
+
+	)
+
+48 
+	#CLOCKS_PER_SEC
+ ((
+ock_t
+1000000)
+
+	)
+
+50 #i(!
+defed
+ 
+__STRICT_ANSI__
+ || defed 
+__USE_POSIX
+) \
+
+51 && !
+defed
+ 
+	g__USE_XOPEN2K
+
+
+54 
+	~<bs/tys.h
+>
+
+55 
+__syscf
+ ();
+
+56 
+	#CLK_TCK
+ ((
+__ock_t
+
+	`__syscf
+ (2)
+
+	)
+
+59 #ifde
+__USE_POSIX199309
+
+
+61 
+	#CLOCK_REALTIME
+ 0
+
+	)
+
+63 
+	#CLOCK_MONOTONIC
+ 1
+
+	)
+
+65 
+	#CLOCK_PROCESS_CPUTIME_ID
+ 2
+
+	)
+
+67 
+	#CLOCK_THREAD_CPUTIME_ID
+ 3
+
+	)
+
+69 
+	#CLOCK_MONOTONIC_RAW
+ 4
+
+	)
+
+71 
+	#CLOCK_REALTIME_COARSE
+ 5
+
+	)
+
+73 
+	#CLOCK_MONOTONIC_COARSE
+ 6
+
+	)
+
+75 
+	#CLOCK_BOOTTIME
+ 7
+
+	)
+
+77 
+	#CLOCK_REALTIME_ALARM
+ 8
+
+	)
+
+79 
+	#CLOCK_BOOTTIME_ALARM
+ 9
+
+	)
+
+81 
+	#CLOCK_TAI
+ 11
+
+	)
+
+84 
+	#TIMER_ABSTIME
+ 1
+
+	)
+
+87 #ifde
+__USE_GNU
+
+
+88 
+	~<bs/timex.h
+>
+
+90 
+__BEGIN_DECLS
+
+
+93 
+	$ock_adjtime
+ (
+__ockid_t
+ 
+__ock_id
+, 
+timex
+ *
+__utx
+
+__THROW
+;
+
+95 
+__END_DECLS
+
+
+101 #unde
+__ed_timev
+
+
+	@/usr/include/bits/typesizes.h
+
+19 #ide
+_BITS_TYPES_H
+
+
+23 #idef 
+_BITS_TYPESIZES_H
+
+
+24 
+	#_BITS_TYPESIZES_H
+ 1
+
+	)
+
+30 #i
+defed
+ 
+__x86_64__
+ && defed 
+__ILP32__
+
+
+31 
+	#__SYSCALL_SLONG_TYPE
+ 
+__SQUAD_TYPE
+
+
+	)
+
+32 
+	#__SYSCALL_ULONG_TYPE
+ 
+__UQUAD_TYPE
+
+
+	)
+
+34 
+	#__SYSCALL_SLONG_TYPE
+ 
+__SLONGWORD_TYPE
+
+
+	)
+
+35 
+	#__SYSCALL_ULONG_TYPE
+ 
+__ULONGWORD_TYPE
+
+
+	)
+
+38 
+	#__DEV_T_TYPE
+ 
+__UQUAD_TYPE
+
+
+	)
+
+39 
+	#__UID_T_TYPE
+ 
+__U32_TYPE
+
+
+	)
+
+40 
+	#__GID_T_TYPE
+ 
+__U32_TYPE
+
+
+	)
+
+41 
+	#__INO_T_TYPE
+ 
+__SYSCALL_ULONG_TYPE
+
+
+	)
+
+42 
+	#__INO64_T_TYPE
+ 
+__UQUAD_TYPE
+
+
+	)
+
+43 
+	#__MODE_T_TYPE
+ 
+__U32_TYPE
+
+
+	)
+
+44 #ifde
+__x86_64__
+
+
+45 
+	#__NLINK_T_TYPE
+ 
+__SYSCALL_ULONG_TYPE
+
+
+	)
+
+46 
+	#__FSWORD_T_TYPE
+ 
+__SYSCALL_SLONG_TYPE
+
+
+	)
+
+48 
+	#__NLINK_T_TYPE
+ 
+__UWORD_TYPE
+
+
+	)
+
+49 
+	#__FSWORD_T_TYPE
+ 
+__SWORD_TYPE
+
+
+	)
+
+51 
+	#__OFF_T_TYPE
+ 
+__SYSCALL_SLONG_TYPE
+
+
+	)
+
+52 
+	#__OFF64_T_TYPE
+ 
+__SQUAD_TYPE
+
+
+	)
+
+53 
+	#__PID_T_TYPE
+ 
+__S32_TYPE
+
+
+	)
+
+54 
+	#__RLIM_T_TYPE
+ 
+__SYSCALL_ULONG_TYPE
+
+
+	)
+
+55 
+	#__RLIM64_T_TYPE
+ 
+__UQUAD_TYPE
+
+
+	)
+
+56 
+	#__BLKCNT_T_TYPE
+ 
+__SYSCALL_SLONG_TYPE
+
+
+	)
+
+57 
+	#__BLKCNT64_T_TYPE
+ 
+__SQUAD_TYPE
+
+
+	)
+
+58 
+	#__FSBLKCNT_T_TYPE
+ 
+__SYSCALL_ULONG_TYPE
+
+
+	)
+
+59 
+	#__FSBLKCNT64_T_TYPE
+ 
+__UQUAD_TYPE
+
+
+	)
+
+60 
+	#__FSFILCNT_T_TYPE
+ 
+__SYSCALL_ULONG_TYPE
+
+
+	)
+
+61 
+	#__FSFILCNT64_T_TYPE
+ 
+__UQUAD_TYPE
+
+
+	)
+
+62 
+	#__ID_T_TYPE
+ 
+__U32_TYPE
+
+
+	)
+
+63 
+	#__CLOCK_T_TYPE
+ 
+__SYSCALL_SLONG_TYPE
+
+
+	)
+
+64 
+	#__TIME_T_TYPE
+ 
+__SYSCALL_SLONG_TYPE
+
+
+	)
+
+65 
+	#__USECONDS_T_TYPE
+ 
+__U32_TYPE
+
+
+	)
+
+66 
+	#__SUSECONDS_T_TYPE
+ 
+__SYSCALL_SLONG_TYPE
+
+
+	)
+
+67 
+	#__DADDR_T_TYPE
+ 
+__S32_TYPE
+
+
+	)
+
+68 
+	#__KEY_T_TYPE
+ 
+__S32_TYPE
+
+
+	)
+
+69 
+	#__CLOCKID_T_TYPE
+ 
+__S32_TYPE
+
+
+	)
+
+70 
+	#__TIMER_T_TYPE
+ *
+
+	)
+
+71 
+	#__BLKSIZE_T_TYPE
+ 
+__SYSCALL_SLONG_TYPE
+
+
+	)
+
+72 
+	#__FSID_T_TYPE
+ su { 
+__v
+[2]; }
+
+	)
+
+73 
+	#__SSIZE_T_TYPE
+ 
+__SWORD_TYPE
+
+
+	)
+
+74 
+	#__CPU_MASK_TYPE
+ 
+__SYSCALL_ULONG_TYPE
+
+
+	)
+
+76 #ifde
+__x86_64__
+
+
+80 
+	#__OFF_T_MATCHES_OFF64_T
+ 1
+
+	)
+
+83 
+	#__INO_T_MATCHES_INO64_T
+ 1
+
+	)
+
+87 
+	#__FD_SETSIZE
+ 1024
+
+	)
+
+	@/usr/include/bits/wordsize.h
+
+3 #i
+defed
+ 
+__x86_64__
+ && !defed 
+__ILP32__
+
+
+4 
+	#__WORDSIZE
+ 64
+
+	)
+
+6 
+	#__WORDSIZE
+ 32
+
+	)
+
+9 #ifde
+__x86_64__
+
+
+10 
+	#__WORDSIZE_TIME64_COMPAT32
+ 1
+
+	)
+
+12 
+	#__SYSCALL_WORDSIZE
+ 64
+
+	)
+
+	@/usr/include/gnu/stubs-64.h
+
+6 #ifde
+_LIBC
+
+
+7 #r 
+Alitis
+ 
+may
+ 
+n
+ 
+defe
+ 
+the
+ 
+mao
+ 
+_LIBC
+
+
+10 
+	#__ub___comt_bdush
+
+
+	)
+
+11 
+	#__ub_chags
+
+
+	)
+
+12 
+	#__ub_ach
+
+
+	)
+
+13 
+	#__ub_fchags
+
+
+	)
+
+14 
+	#__ub_fdach
+
+
+	)
+
+15 
+	#__ub_gmsg
+
+
+	)
+
+16 
+	#__ub_gy
+
+
+	)
+
+17 
+	#__ub_lchmod
+
+
+	)
+
+18 
+	#__ub_putmsg
+
+
+	)
+
+19 
+	#__ub_voke
+
+
+	)
+
+20 
+	#__ub_og
+
+
+	)
+
+21 
+	#__ub_sigtu
+
+
+	)
+
+22 
+	#__ub_sk
+
+
+	)
+
+23 
+	#__ub_ty
+
+
+	)
+
+	@/usr/include/bits/byteswap-16.h
+
+19 #ide
+_BITS_BYTESWAP_H
+
+
+23 #ifde
+__GNUC__
+
+
+24 #i
+__GNUC__
+ >= 2
+
+25 
+	#__bsw_16
+(
+x
+) \
+
+26 (
+__exnsi__
+ \
+
+27 ({ 
+__v
+, 
+__x
+ = ((
+x
+); \
+
+28 i(
+	`__but_ct_p
+ (
+__x
+)) \
+
+29 
+__v
+ = 
+	`__bsw_ct_16
+ (
+__x
+); \
+
+31 
+	`__asm__
+ ("rorw $8, %w0" \
+
+32 : "" (
+__v
+) \
+
+33 : "0" (
+__x
+) \
+
+35 
+__v
+; }))
+
+	)
+
+38 
+	#__bsw_16
+(
+x
+) \
+
+39 (
+__exnsi__
+ \
+
+40 ({ 
+__x
+ = ((
+x
+); \
+
+41 
+	`__bsw_ct_16
+ (
+__x
+); }))
+
+	)
+
+44 
+__le
+ 
+
+45 
+	$__bsw_16
+ (
+__bsx
+)
+
+47  
+	`__bsw_ct_16
+ (
+__bsx
+);
+
+48 
+	}
+}
+
+	@/usr/include/bits/timex.h
+
+18 #idef 
+_BITS_TIMEX_H
+
+
+19 
+	#_BITS_TIMEX_H
+ 1
+
+	)
+
+21 
+	~<bs/tys.h
+>
+
+25 
+	stimex
+
+
+27 
+	mmodes
+;
+
+28 
+__sys_g_t
+ 
+	mofft
+;
+
+29 
+__sys_g_t
+ 
+	meq
+;
+
+30 
+__sys_g_t
+ 
+	mmaxr
+;
+
+31 
+__sys_g_t
+ 
+	mer
+;
+
+32 
+	mus
+;
+
+33 
+__sys_g_t
+ 
+	mct
+;
+
+34 
+__sys_g_t
+ 
+	mecisi
+;
+
+35 
+__sys_g_t
+ 
+	mt
+;
+
+36 
+timev
+ 
+	mtime
+;
+
+37 
+__sys_g_t
+ 
+	mtick
+;
+
+38 
+__sys_g_t
+ 
+	mseq
+;
+
+39 
+__sys_g_t
+ 
+	mjr
+;
+
+40 
+	mshi
+;
+
+41 
+__sys_g_t
+ 
+	mab
+;
+
+42 
+__sys_g_t
+ 
+	mjt
+;
+
+43 
+__sys_g_t
+ 
+	mlt
+;
+
+44 
+__sys_g_t
+ 
+	mrt
+;
+
+45 
+__sys_g_t
+ 
+	mbt
+;
+
+47 
+	mi
+;
+
+56 
+	#ADJ_OFFSET
+ 0x0001
+
+	)
+
+57 
+	#ADJ_FREQUENCY
+ 0x0002
+
+	)
+
+58 
+	#ADJ_MAXERROR
+ 0x0004
+
+	)
+
+59 
+	#ADJ_ESTERROR
+ 0x0008
+
+	)
+
+60 
+	#ADJ_STATUS
+ 0x0010
+
+	)
+
+61 
+	#ADJ_TIMECONST
+ 0x0020
+
+	)
+
+62 
+	#ADJ_TAI
+ 0x0080
+
+	)
+
+63 
+	#ADJ_SETOFFSET
+ 0x0100
+
+	)
+
+64 
+	#ADJ_MICRO
+ 0x1000
+
+	)
+
+65 
+	#ADJ_NANO
+ 0x2000
+
+	)
+
+66 
+	#ADJ_TICK
+ 0x4000
+
+	)
+
+67 
+	#ADJ_OFFSET_SINGLESHOT
+ 0x8001
+
+	)
+
+68 
+	#ADJ_OFFSET_SS_READ
+ 0xa001
+
+	)
+
+71 
+	#MOD_OFFSET
+ 
+ADJ_OFFSET
+
+
+	)
+
+72 
+	#MOD_FREQUENCY
+ 
+ADJ_FREQUENCY
+
+
+	)
+
+73 
+	#MOD_MAXERROR
+ 
+ADJ_MAXERROR
+
+
+	)
+
+74 
+	#MOD_ESTERROR
+ 
+ADJ_ESTERROR
+
+
+	)
+
+75 
+	#MOD_STATUS
+ 
+ADJ_STATUS
+
+
+	)
+
+76 
+	#MOD_TIMECONST
+ 
+ADJ_TIMECONST
+
+
+	)
+
+77 
+	#MOD_CLKB
+ 
+ADJ_TICK
+
+
+	)
+
+78 
+	#MOD_CLKA
+ 
+ADJ_OFFSET_SINGLESHOT
+
+
+	)
+
+79 
+	#MOD_TAI
+ 
+ADJ_TAI
+
+
+	)
+
+80 
+	#MOD_MICRO
+ 
+ADJ_MICRO
+
+
+	)
+
+81 
+	#MOD_NANO
+ 
+ADJ_NANO
+
+
+	)
+
+85 
+	#STA_PLL
+ 0x0001
+
+	)
+
+86 
+	#STA_PPSFREQ
+ 0x0002
+
+	)
+
+87 
+	#STA_PPSTIME
+ 0x0004
+
+	)
+
+88 
+	#STA_FLL
+ 0x0008
+
+	)
+
+90 
+	#STA_INS
+ 0x0010
+
+	)
+
+91 
+	#STA_DEL
+ 0x0020
+
+	)
+
+92 
+	#STA_UNSYNC
+ 0x0040
+
+	)
+
+93 
+	#STA_FREQHOLD
+ 0x0080
+
+	)
+
+95 
+	#STA_PPSSIGNAL
+ 0x0100
+
+	)
+
+96 
+	#STA_PPSJITTER
+ 0x0200
+
+	)
+
+97 
+	#STA_PPSWANDER
+ 0x0400
+
+	)
+
+98 
+	#STA_PPSERROR
+ 0x0800
+
+	)
+
+100 
+	#STA_CLOCKERR
+ 0x1000
+
+	)
+
+101 
+	#STA_NANO
+ 0x2000
+
+	)
+
+102 
+	#STA_MODE
+ 0x4000
+
+	)
+
+103 
+	#STA_CLK
+ 0x8000
+
+	)
+
+106 
+	#STA_RONLY
+ (
+STA_PPSSIGNAL
+ | 
+STA_PPSJITTER
+ | 
+STA_PPSWANDER
+ | \
+
+107 
+STA_PPSERROR
+ | 
+STA_CLOCKERR
+ | 
+STA_NANO
+ | 
+STA_MODE
+ | 
+STA_CLK
+)
+
+	)
+
+	@
+1
+.
+1
+/usr/include
+40
+941
+GetLongOpt.h
+ReadPattern.h
+circuit.h
+fault.h
+gate.h
+hash.h
+readcircuit.tab.h
+tfault.h
+typeemu.h
+/usr/include/stdlib.h
+/usr/include/alloca.h
+/usr/include/bits/stdlib-bsearch.h
+/usr/include/bits/stdlib-float.h
+/usr/include/bits/stdlib-ldbl.h
+/usr/include/bits/stdlib.h
+/usr/include/bits/waitflags.h
+/usr/include/bits/waitstatus.h
+/usr/include/features.h
+/usr/include/sys/types.h
+/usr/include/xlocale.h
+/usr/include/bits/pthreadtypes.h
+/usr/include/bits/types.h
+/usr/include/endian.h
+/usr/include/gnu/stubs.h
+/usr/include/stdc-predef.h
+/usr/include/sys/cdefs.h
+/usr/include/sys/select.h
+/usr/include/sys/sysmacros.h
+/usr/include/time.h
+/usr/include/bits/byteswap.h
+/usr/include/bits/endian.h
+/usr/include/bits/select.h
+/usr/include/bits/select2.h
+/usr/include/bits/sigset.h
+/usr/include/bits/time.h
+/usr/include/bits/typesizes.h
+/usr/include/bits/wordsize.h
+/usr/include/gnu/stubs-64.h
+/usr/include/bits/byteswap-16.h
+/usr/include/bits/timex.h
diff --git a/podem/gate.h b/podem/gate.h
index 3af0e4a..36d9649 100644
--- a/podem/gate.h
+++ b/podem/gate.h
@@ -6,142 +6,157 @@ using namespace std;
 
 class GATE
 {
-    private:
-        string Name;
-        unsigned ID;
-        GATEFUNC Function;
-        vector<GATE*> Input_list;
-        vector<GATE*> Output_list;
-        bitset<NumFlags> Flag;
-        unsigned Level;
-        VALUE Value;
-        VALUE Value_t;
-        bool Inversion;
-        //Utility variable
-        unsigned Count[2]; //used by Levelize(), FindStaticPivot(),PathSearch
-        //bitset<PatternNum> WireValue1; //parallel value for fault simulation,
-        //bitset<PatternNum> WireValue2; //use two values to simulate don't care case
-        bitset<PatternNum> WireValue[2]; //one pair of WireValues (length defined by PatternNum).
-        bitset<PatternNum> FaultFlag;
-    public:
-        //Initialize GATE
-        GATE(): Function(G_BAD), Level(0), Value(X), Value_t(X), Inversion(false) {
-            Input_list.reserve(4);
-            Output_list.reserve(4);
-            Count[0] = (0);
-            Count[1] = (0);
-	    WireValue[0].set();   //All parallel bitsets are set to X
-	    WireValue[1].reset();
-        }
-        ~GATE() {}
-        void SetName(string n){ Name = n;}
-        void SetID(unsigned id){ ID = id;}
-        void SetFunction(GATEFUNC f){ Function = f;}
-        void AddInput_list(GATE* gptr){Input_list.push_back(gptr);}
-        vector<GATE*> &GetInput_list() { return Input_list; }
-        void AddOutput_list(GATE* gptr){Output_list.push_back(gptr);}
-        void SetLevel(unsigned l){ Level = l;}
-        void SetValue(VALUE v) {Value = v;}
-        void InverseValue() {Value = NotTable[Value];}
-        void SetValue_t(VALUE v) {Value_t = v;}
-        void InverseValue_t() {Value_t = NotTable[Value_t];}
-        void IncCount(unsigned i = 0) {Count[i]++;}
-        void DecCount(unsigned i = 0) {Count[i]--;}
-        void ResetCount(unsigned i = 0) {Count[i] = 0;}
-        void ResetAllCount() {Count[0] = 0;Count[1] = 0;}
-        unsigned GetCount(unsigned i = 0) { return Count[i];}
-        string GetName(){ return Name;}
-        unsigned GetID(){ return ID;}
-        GATEFUNC GetFunction(){ return Function;}
-        unsigned No_Fanin() { return Input_list.size();}
-        unsigned No_Fanout() { return Output_list.size();}
-        GATE* Fanin(int i) { return Input_list[i];}
-        GATE* Fanout(int i) { return Output_list[i];}
-        void ChangeFanin(int i, GATE* g) {Input_list[i] = g;}
-        void ChangeFanout(int i, GATE* g) {Output_list[i] = g;}
-        unsigned GetLevel() { return Level;}
-        VALUE GetValue() { return Value;}
-        VALUE GetValue_t() { return Value_t;}
-        void SetInversion(){Inversion = true;}
-        void UnSetInversion(){Inversion = false;}
-        void SetFlag(FLAGS f) { Flag.set(f); }
-        void ResetFlag(FLAGS f) { Flag.reset(f); }
-        void ResetFlag() { Flag.reset(); }
-        bool GetFlag(FLAGS f) { return Flag[f]; }
-        bool Is_Inversion() { return Inversion;}
-        bool Is_Unique(unsigned j)
-        {
-            for (unsigned i = 0;i < j;i++) {
-                if (Fanin(i)->GetID() == Fanin(j)->GetID()) return false;
-            }
-            return true;
-        }
+	private:
+		string Name;
+		unsigned ID;
+		GATEFUNC Function;
+		vector<GATE*> Input_list;
+		vector<GATE*> Output_list;
+		bitset<NumFlags> Flag;
+		unsigned Level;
+		VALUE Value;
+		VALUE Value_t;
+		bool Inversion;
+		//Utility variable
+		unsigned Count[2]; //used by Levelize(), FindStaticPivot(),PathSearch
+		//bitset<PatternNum> WireValue1; //parallel value for fault simulation,
+		//bitset<PatternNum> WireValue2; //use two values to simulate don't care case
+		bitset<PatternNum> WireValue[2]; //one pair of WireValues (length defined by PatternNum).
+		bitset<PatternNum> FaultFlag;
+		// VLSI-Testing Lab1, label for finding paths
+		DFS_STATUS dfs_status;
+		// VLSI-Testing lab2
+		bitset<2> mod_value;
+	public:
+		//Initialize GATE
+		GATE(): Function(G_BAD), Level(0), Value(X), Value_t(X), Inversion(false) {
+			Input_list.reserve(4);
+			Output_list.reserve(4);
+			Count[0] = (0);
+			Count[1] = (0);
+			WireValue[0].set();   //All parallel bitsets are set to X
+			WireValue[1].reset();
+			// VLSI-Testing Lab1, initial path label
+			dfs_status = WHITE;
+			// VLSI-Testing lab2
+			mod_value.reset();
+		}
+		~GATE() {}
+		//VLSI-Testing Lab1, operations with the dfs status
+		void setDFSStatus(DFS_STATUS flag) {dfs_status = flag;}
+		// VLSI-Testing Lab2
+		void SetModValue(bitset<2> bits) { mod_value = bits; }
+		bitset<2> GetModValue() {return mod_value;}
 
-        //for fault simulation
-        void SetValue1() { WireValue[0].set(); }
-        void SetValue1(bitset<PatternNum> &value) { WireValue[0] = value; }
-        void SetValue1(unsigned idx) { WireValue[0].set(idx); }
-        void ResetValue1() { WireValue[0].reset(); }
-        void ResetValue1(unsigned idx) { WireValue[0].reset(idx); }
-        bool GetValue1(unsigned idx) { return WireValue[0][idx]; }
-        bitset<PatternNum> GetValue1() { return WireValue[0]; }
-        void SetValue2(bitset<PatternNum> &value) { WireValue[1] = value; }
-        void SetValue2() { WireValue[1].set(); }
-        void SetValue2(unsigned idx) { WireValue[1].set(idx); }
-        void ResetValue2() { WireValue[1].reset(); }
-        void ResetValue2(unsigned idx) { WireValue[1].reset(idx); }
-        bool GetValue2(unsigned idx) { return WireValue[1][idx]; }
-        bitset<PatternNum> GetValue2() { return WireValue[1]; }
-        void ParallelInv() {
-            bitset<PatternNum> value(~WireValue[0]);
-            WireValue[0] = ~WireValue[1];
-            WireValue[1] = value;
-        }
-        void SetFaultFlag(unsigned idx) { FaultFlag.set(idx); }
-        void ResetFaultFlag() { FaultFlag.reset(); }
-        bool GetFaultFlag(unsigned idx) { return FaultFlag[idx]; }
-        void SetFaultFreeValue() {
-            switch (Value) {
-                case S1:
-                    WireValue[0].set(); WireValue[1].set();
-                    break;
-                case S0:
-                    WireValue[0].reset(); WireValue[1].reset();
-                    break;
-                case X:
-                    WireValue[0].set(); WireValue[1].reset();
-                    break;
-                default: break;
-            }
-        }
+		DFS_STATUS getDFSStatus() {return dfs_status;}
+		void SetName(string n){ Name = n;}
+		void SetID(unsigned id){ ID = id;}
+		void SetFunction(GATEFUNC f){ Function = f;}
+		void AddInput_list(GATE* gptr){Input_list.push_back(gptr);}
+		vector<GATE*> &GetInput_list() { return Input_list; }
+		void AddOutput_list(GATE* gptr){Output_list.push_back(gptr);}
+		void SetLevel(unsigned l){ Level = l;}
+		void SetValue(VALUE v) {Value = v;}
+		void InverseValue() {Value = NotTable[Value];}
+		void SetValue_t(VALUE v) {Value_t = v;}
+		void InverseValue_t() {Value_t = NotTable[Value_t];}
+		void IncCount(unsigned i = 0) {Count[i]++;}
+		void DecCount(unsigned i = 0) {Count[i]--;}
+		void ResetCount(unsigned i = 0) {Count[i] = 0;}
+		void ResetAllCount() {Count[0] = 0;Count[1] = 0;}
+		unsigned GetCount(unsigned i = 0) { return Count[i];}
+		string GetName(){ return Name;}
+		unsigned GetID(){ return ID;}
+		GATEFUNC GetFunction(){ return Function;}
+		unsigned No_Fanin() { return Input_list.size();}
+		unsigned No_Fanout() { return Output_list.size();}
+		GATE* Fanin(int i) { return Input_list[i];}
+		GATE* Fanout(int i) { return Output_list[i];}
+		void ChangeFanin(int i, GATE* g) {Input_list[i] = g;}
+		void ChangeFanout(int i, GATE* g) {Output_list[i] = g;}
+		unsigned GetLevel() { return Level;}
+		VALUE GetValue() { return Value;}
+		VALUE GetValue_t() { return Value_t;}
+		void SetInversion(){Inversion = true;}
+		void UnSetInversion(){Inversion = false;}
+		void SetFlag(FLAGS f) { Flag.set(f); }
+		void ResetFlag(FLAGS f) { Flag.reset(f); }
+		void ResetFlag() { Flag.reset(); }
+		bool GetFlag(FLAGS f) { return Flag[f]; }
+		bool Is_Inversion() { return Inversion;}
+		bool Is_Unique(unsigned j)
+		{
+			for (unsigned i = 0;i < j;i++) {
+				if (Fanin(i)->GetID() == Fanin(j)->GetID()) return false;
+			}
+			return true;
+		}
 
-        void SetWireValue(unsigned i) { WireValue[i].set(); }
-        void SetWireValue(unsigned i, bitset<PatternNum> &value) { WireValue[i] = value; }
-        void SetWireValue(unsigned i, unsigned idx) { WireValue[i].set(idx); }
-        void ResetWireValue(unsigned i) { WireValue[i].reset(); }
-        void ResetWireValue(unsigned i, unsigned idx) { WireValue[i].reset(idx); }
-        bool GetWireValue(unsigned i, unsigned idx) { return WireValue[i][idx]; }
-        bitset<PatternNum> GetWireValue(unsigned i) { return WireValue[i]; }
-	char GetTransition_t(){
-            if (Value==S0){
-	    	if(Value_t==S0) { return '0'; }
-		else{ return 'R'; }
-	    }
-	    else{
-	    	if(Value_t==S0) { return 'F'; }
-		else{ return '1'; }
-	    }
-	}
-	char GetTransition(){
-            if (Value_t==S0){
-	    	if(Value==S0) { return '0'; }
-		else{ return 'R'; }
-	    }
-	    else{
-	    	if(Value==S0) { return 'F'; }
-		else{ return '1'; }
-	    }
-	}
+		//for fault simulation
+		void SetValue1() { WireValue[0].set(); }
+		void SetValue1(bitset<PatternNum> &value) { WireValue[0] = value; }
+		void SetValue1(unsigned idx) { WireValue[0].set(idx); }
+		void ResetValue1() { WireValue[0].reset(); }
+		void ResetValue1(unsigned idx) { WireValue[0].reset(idx); }
+		bool GetValue1(unsigned idx) { return WireValue[0][idx]; }
+		bitset<PatternNum> GetValue1() { return WireValue[0]; }
+		void SetValue2(bitset<PatternNum> &value) { WireValue[1] = value; }
+		void SetValue2() { WireValue[1].set(); }
+		void SetValue2(unsigned idx) { WireValue[1].set(idx); }
+		void ResetValue2() { WireValue[1].reset(); }
+		void ResetValue2(unsigned idx) { WireValue[1].reset(idx); }
+		bool GetValue2(unsigned idx) { return WireValue[1][idx]; }
+		bitset<PatternNum> GetValue2() { return WireValue[1]; }
+		void ParallelInv() {
+			bitset<PatternNum> value(~WireValue[0]);
+			WireValue[0] = ~WireValue[1];
+			WireValue[1] = value;
+		}
+		void SetFaultFlag(unsigned idx) { FaultFlag.set(idx); }
+		void ResetFaultFlag() { FaultFlag.reset(); }
+		bool GetFaultFlag(unsigned idx) { return FaultFlag[idx]; }
+		void SetFaultFreeValue() {
+			switch (Value) {
+				case S1:
+					WireValue[0].set(); WireValue[1].set();
+					break;
+				case S0:
+					WireValue[0].reset(); WireValue[1].reset();
+					break;
+				case X:
+					WireValue[0].set(); WireValue[1].reset();
+					break;
+				default: break;
+			}
+		}
+
+		void SetWireValue(unsigned i) { WireValue[i].set(); }
+		void SetWireValue(unsigned i, bitset<PatternNum> &value) { WireValue[i] = value; }
+		void SetWireValue(unsigned i, unsigned idx) { WireValue[i].set(idx); }
+		void ResetWireValue(unsigned i) { WireValue[i].reset(); }
+		void ResetWireValue(unsigned i, unsigned idx) { WireValue[i].reset(idx); }
+		bool GetWireValue(unsigned i, unsigned idx) { return WireValue[i][idx]; }
+		bitset<PatternNum> GetWireValue(unsigned i) { return WireValue[i]; }
+		char GetTransition_t(){
+			if (Value==S0){
+				if(Value_t==S0) { return '0'; }
+				else{ return 'R'; }
+			}
+			else{
+				if(Value_t==S0) { return 'F'; }
+				else{ return '1'; }
+			}
+		}
+		char GetTransition(){
+			if (Value_t==S0){
+				if(Value==S0) { return '0'; }
+				else{ return 'R'; }
+			}
+			else{
+				if(Value==S0) { return 'F'; }
+				else{ return '1'; }
+			}
+		}
 };
 
 #endif
diff --git a/podem/lex.yy.cc b/podem/lex.yy.cc
new file mode 100644
index 0000000..cd9e25b
--- /dev/null
+++ b/podem/lex.yy.cc
@@ -0,0 +1,1871 @@
+
+#line 3 "lex.yy.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 6
+#define YY_FLEX_SUBMINOR_VERSION 0
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart(yyin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
+#define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+extern yy_size_t yyleng;
+
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    #define YY_LINENO_REWIND_TO(ptr)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	yy_size_t yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+static yy_size_t yy_n_chars;		/* number of characters read into yy_ch_buf */
+yy_size_t yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart (FILE *input_file  );
+void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
+void yy_delete_buffer (YY_BUFFER_STATE b  );
+void yy_flush_buffer (YY_BUFFER_STATE b  );
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void yypop_buffer_state (void );
+
+static void yyensure_buffer_stack (void );
+static void yy_load_buffer_state (void );
+static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len  );
+
+void *yyalloc (yy_size_t  );
+void *yyrealloc (void *,yy_size_t  );
+void yyfree (void *  );
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define yywrap() (/*CONSTCOND*/1)
+#define YY_SKIP_YYWRAP
+
+typedef unsigned char YY_CHAR;
+
+FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int yylineno;
+
+int yylineno = 1;
+
+extern char *yytext;
+#ifdef yytext_ptr
+#undef yytext_ptr
+#endif
+#define yytext_ptr yytext
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+#if defined(__GNUC__) && __GNUC__ >= 3
+__attribute__((__noreturn__))
+#endif
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	yyleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 20
+#define YY_END_OF_BUFFER 21
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[46] =
+    {   0,
+        0,    0,   21,   19,    1,    4,   16,   17,   18,   14,
+       15,   14,   14,   14,   14,   14,   14,    3,   19,   14,
+       14,   14,   14,   14,   14,   14,   10,   14,    0,    2,
+        9,    8,   13,   14,   14,   12,    7,   14,   14,   11,
+       14,    5,   14,    6,    0
+    } ;
+
+static yyconst YY_CHAR yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    1,    1,    4,    1,    1,    1,    1,    5,
+        6,    1,    1,    7,    1,    8,    1,    9,    9,    9,
+        9,    9,    9,    9,    9,    9,    9,    1,    1,    1,
+       10,    1,    1,    1,   11,   12,    9,   13,    9,   14,
+        9,    9,   15,    9,    9,    9,    9,   16,   17,   18,
+        9,   19,    9,   20,   21,    9,    9,    9,    9,    9,
+        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
+
+        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
+        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
+        9,    9,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst YY_CHAR yy_meta[22] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    2,    2,    1,
+        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
+        2
+    } ;
+
+static yyconst flex_uint16_t yy_base[48] =
+    {   0,
+        0,   19,   51,   52,   52,   52,   52,   52,   52,    0,
+       52,   34,   28,   34,   31,   13,    6,   52,   43,    0,
+       32,   30,   29,   24,   25,    9,    0,   20,   36,   52,
+        0,    0,    0,   17,   24,    0,    0,   18,   15,    0,
+       13,    0,   13,    0,   52,   24,   30
+    } ;
+
+static yyconst flex_int16_t yy_def[48] =
+    {   0,
+       45,    1,   45,   45,   45,   45,   45,   45,   45,   46,
+       45,   46,   46,   46,   46,   46,   46,   45,   47,   46,
+       46,   46,   46,   46,   46,   46,   46,   46,   47,   45,
+       46,   46,   46,   46,   46,   46,   46,   46,   46,   46,
+       46,   46,   46,   46,    0,   45,   45
+    } ;
+
+static yyconst flex_uint16_t yy_nxt[74] =
+    {   0,
+        4,    5,    6,    4,    7,    8,    9,    4,   10,   11,
+       12,   13,   14,   10,   15,   16,   17,   10,   10,   10,
+       10,   18,   19,   25,   27,   20,   28,   36,   37,   26,
+       29,   29,   44,   43,   42,   41,   40,   39,   30,   38,
+       35,   34,   33,   32,   31,   30,   24,   23,   22,   21,
+       45,    3,   45,   45,   45,   45,   45,   45,   45,   45,
+       45,   45,   45,   45,   45,   45,   45,   45,   45,   45,
+       45,   45,   45
+    } ;
+
+static yyconst flex_int16_t yy_chk[74] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    2,   16,   17,   46,   17,   26,   26,   16,
+       47,   47,   43,   41,   39,   38,   35,   34,   29,   28,
+       25,   24,   23,   22,   21,   19,   15,   14,   13,   12,
+        3,   45,   45,   45,   45,   45,   45,   45,   45,   45,
+       45,   45,   45,   45,   45,   45,   45,   45,   45,   45,
+       45,   45,   45
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int yy_flex_debug;
+int yy_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+#line 1 "readcircuit.l"
+/*Scanner for reading benchmark circuit netlist*/
+#line 4 "readcircuit.l"
+#include "typeemu.h"
+#include "readcircuit.tab.h"
+        
+long lineno=1;
+#line 502 "lex.yy.c"
+
+#define INITIAL 0
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int yylex_destroy (void );
+
+int yyget_debug (void );
+
+void yyset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE yyget_extra (void );
+
+void yyset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *yyget_in (void );
+
+void yyset_in  (FILE * _in_str  );
+
+FILE *yyget_out (void );
+
+void yyset_out  (FILE * _out_str  );
+
+yy_size_t yyget_leng (void );
+
+char *yyget_text (void );
+
+int yyget_lineno (void );
+
+void yyset_lineno (int _line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap (void );
+#else
+extern int yywrap (void );
+#endif
+#endif
+
+#ifndef YY_NO_UNPUT
+    
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
+#define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		size_t n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(yyin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int yylex (void);
+
+#define YY_DECL int yylex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK /*LINTED*/break;
+#endif
+
+#define YY_RULE_SETUP \
+	if ( yyleng > 0 ) \
+		YY_CURRENT_BUFFER_LVALUE->yy_at_bol = \
+				(yytext[yyleng - 1] == '\n'); \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	yy_state_type yy_current_state;
+	char *yy_cp, *yy_bp;
+	int yy_act;
+    
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			yyensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				yy_create_buffer(yyin,YY_BUF_SIZE );
+		}
+
+		yy_load_buffer_state( );
+		}
+
+	{
+#line 15 "readcircuit.l"
+
+#line 723 "lex.yy.c"
+
+	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of yytext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+		yy_current_state += YY_AT_BOL();
+yy_match:
+		do
+			{
+			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 46 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 52 );
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+		if ( yy_act == 0 )
+			{ /* have to back up */
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			yy_act = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+#line 16 "readcircuit.l"
+{ /* Ignore white space*/}
+	YY_BREAK
+case 2:
+/* rule 2 can match eol */
+YY_RULE_SETUP
+#line 17 "readcircuit.l"
+{ /* Ignore Comment */lineno++; }
+	YY_BREAK
+case 3:
+/* rule 3 can match eol */
+YY_RULE_SETUP
+#line 18 "readcircuit.l"
+{lineno++;}
+	YY_BREAK
+case 4:
+/* rule 4 can match eol */
+YY_RULE_SETUP
+#line 19 "readcircuit.l"
+{lineno++; return(EOLINE);}
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 20 "readcircuit.l"
+{  return(GINPUT);}
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 21 "readcircuit.l"
+{  return(GOUTPUT);}
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 22 "readcircuit.l"
+{  return(GNOT);}
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 23 "readcircuit.l"
+{  return(GBUF);}
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 24 "readcircuit.l"
+{  return(GAND);}
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 25 "readcircuit.l"
+{  return(GOR);}
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 26 "readcircuit.l"
+{  return(GNAND);}
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 27 "readcircuit.l"
+{  return(GNOR);}
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 28 "readcircuit.l"
+{  return(GDFF);}
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 29 "readcircuit.l"
+{ 
+        strcpy(yylval.str, (char *)yytext);
+        return(NAMESTRING);
+      }
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 33 "readcircuit.l"
+{ return(EQUAL);}
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 34 "readcircuit.l"
+{ return(LPAR);}
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 35 "readcircuit.l"
+{ return(RPAR);}
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 36 "readcircuit.l"
+{ return(COMMA);}
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+#line 37 "readcircuit.l"
+{printf("Unrecognized symbol error at %s in line %ld\n",yytext, lineno);}
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+#line 38 "readcircuit.l"
+ECHO;
+	YY_BREAK
+#line 887 "lex.yy.c"
+case YY_STATE_EOF(INITIAL):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( yywrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+	} /* end of user's declarations */
+} /* end of yylex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	char *source = (yytext_ptr);
+	yy_size_t number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (yy_size_t) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			yy_size_t num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				yy_size_t new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart(yyin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	yy_state_type yy_current_state;
+	char *yy_cp;
+    
+	yy_current_state = (yy_start);
+	yy_current_state += YY_AT_BOL();
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 46 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	int yy_is_jam;
+    	char *yy_cp = (yy_c_buf_p);
+
+	YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 46 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 45);
+
+		return yy_is_jam ? 0 : yy_current_state;
+}
+
+#ifndef YY_NO_UNPUT
+
+#endif
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart(yyin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve yytext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void yyrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        yyensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            yy_create_buffer(yyin,YY_BUF_SIZE );
+	}
+
+	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
+	yy_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		yypop_buffer_state();
+	 *		yypush_buffer_state(new_buffer);
+     */
+	yyensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	yy_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void yy_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = (yy_size_t)size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with yy_create_buffer()
+ * 
+ */
+    void yy_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yyfree((void *) b->yy_ch_buf  );
+
+	yyfree((void *) b  );
+}
+
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a yyrestart() or at EOF.
+ */
+    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	yy_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then yy_init_buffer was _probably_
+     * called from yyrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void yy_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		yy_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	yyensure_buffer_stack();
+
+	/* This block is copied from yy_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from yy_switch_to_buffer. */
+	yy_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void yypop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	yy_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		yy_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void yyensure_buffer_stack (void)
+{
+	yy_size_t num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		yy_size_t grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to yylex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       yy_scan_bytes() instead.
+ */
+YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
+{
+    
+	return yy_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	yy_size_t i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) yyalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+			(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		yytext[yyleng] = (yy_hold_char); \
+		(yy_c_buf_p) = yytext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		yyleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int yyget_lineno  (void)
+{
+        
+    return yylineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *yyget_in  (void)
+{
+        return yyin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *yyget_out  (void)
+{
+        return yyout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+yy_size_t yyget_leng  (void)
+{
+        return yyleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *yyget_text  (void)
+{
+        return yytext;
+}
+
+/** Set the current line number.
+ * @param _line_number line number
+ * 
+ */
+void yyset_lineno (int  _line_number )
+{
+    
+    yylineno = _line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param _in_str A readable stream.
+ * 
+ * @see yy_switch_to_buffer
+ */
+void yyset_in (FILE *  _in_str )
+{
+        yyin = _in_str ;
+}
+
+void yyset_out (FILE *  _out_str )
+{
+        yyout = _out_str ;
+}
+
+int yyget_debug  (void)
+{
+        return yy_flex_debug;
+}
+
+void yyset_debug (int  _bdebug )
+{
+        yy_flex_debug = _bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from yylex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    yyin = stdin;
+    yyout = stdout;
+#else
+    yyin = (FILE *) 0;
+    yyout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * yylex_init()
+     */
+    return 0;
+}
+
+/* yylex_destroy is for both reentrant and non-reentrant scanners. */
+int yylex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		yy_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		yypop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	yyfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * yylex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+		
+	int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *yyalloc (yy_size_t  size )
+{
+			return (void *) malloc( size );
+}
+
+void *yyrealloc  (void * ptr, yy_size_t  size )
+{
+		
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void yyfree (void * ptr )
+{
+			free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 38 "readcircuit.l"
+
+
+
+/* debuggin
+int main(int argc, char ** argv)
+{
+        ++argv, --argc;
+        if(argc>0)
+            yyin = fopen(argv[0],"r");
+        else
+            yyin=stdin;
+        while(!feof(yyin)){ 
+            yylex();
+        }
+        fclose(yyin);
+}
+*/
+
diff --git a/podem/main.cc b/podem/main.cc
index fb9ea42..68038b1 100644
--- a/podem/main.cc
+++ b/podem/main.cc
@@ -1,8 +1,9 @@
 #include <iostream>
 #include <ctime>
+#include <string>
 #include "circuit.h"
 #include "GetLongOpt.h"
-#include "ReadPattern.h"
+#include "pattern.h"
 using namespace std;
 
 // All defined in readcircuit.l
@@ -19,6 +20,28 @@ GetLongOpt option;
 int SetupOption(int argc, char ** argv)
 {
     option.usage("[options] input_circuit_file");
+		// Add options for VLSI-Testing lab1
+		option.enroll("print", GetLongOpt::NoValue,
+						"print out the needed info of input file", 0);
+		option.enroll("info", GetLongOpt::MandatoryValue,
+						"specify the needed info.", 0);
+		option.enroll("path", GetLongOpt::NoValue, 
+						"print all the possible paths from source gate to target gate", 0);
+		option.enroll("start",GetLongOpt::MandatoryValue,
+						"get the starting gate for the path", 0);
+		option.enroll("end",GetLongOpt::MandatoryValue,
+						"get the ending gate for the path", 0);
+		// --------------------
+		// Add options for VLSI-Testing lab2
+    option.enroll("pattern", GetLongOpt::NoValue,
+            			"Generate random pattern", 0);
+		option.enroll("num",GetLongOpt::MandatoryValue,
+									"specify the number of the generated pattern", 0);
+    option.enroll("unknown", GetLongOpt::NoValue,
+            			"Generate random pattern with unknown", 0);
+    option.enroll("mod_logicsim", GetLongOpt::NoValue,
+            			"use cpu instructions to compute AND, OR and NOT", 0);
+		// ---------------------------------
     option.enroll("help", GetLongOpt::NoValue,
             "print this help summary", 0);
     option.enroll("logicsim", GetLongOpt::NoValue,
@@ -58,12 +81,12 @@ int main(int argc, char ** argv)
             exit( -1);
         }
         else {
-            string circuit_name = argv[optind];
-            string::size_type idx = circuit_name.rfind('/');
-            if (idx != string::npos) { circuit_name = circuit_name.substr(idx+1); }
-            idx = circuit_name.find(".bench");
-            if (idx != string::npos) { circuit_name = circuit_name.substr(0,idx); }
-            Circuit.SetName(circuit_name);
+            string output_name = argv[optind];
+            string::size_type idx = output_name.rfind('/');
+            if (idx != string::npos) { output_name = output_name.substr(idx+1); }
+            idx = output_name.find(".bench");
+            if (idx != string::npos) { output_name = output_name.substr(0,idx); }
+            Circuit.SetName(output_name);
         }
     }
     else {
@@ -84,9 +107,57 @@ int main(int argc, char ** argv)
     Circuit.Check_Levelization();
     Circuit.InitializeQueue();
 
-    if (option.retrieve("logicsim")) {
+		// Options operations for Lab1
+		if(option.retrieve("path")){
+			cout << "Circuit file name: " << Circuit.GetName() << endl;
+			const char *start_gate = option.retrieve("start");
+			const char *end_gate = option.retrieve("end");
+
+			string src_gate_name(start_gate);
+			string dest_gate_name(end_gate);
+			Circuit.path(src_gate_name, dest_gate_name);
+		}
+		// Options operations for lab2
+		else if(option.retrieve("pattern")){
+			string output_name = (string) option.retrieve("output");
+			string pattern_name;
+			int number = atoi(option.retrieve("num"));
+
+			string::size_type idx = output_name.rfind('/');
+			if (idx != string::npos) { output_name = output_name.substr(idx+1); }
+			idx = output_name.find(".output");
+			if (idx != string::npos) { pattern_name = output_name.substr(0,idx); }
+			pattern_name.append(".input");
+
+			if(option.retrieve("unknown"))	
+				Circuit.genRandomPatternUnknown(pattern_name, number);
+			else
+				Circuit.genRandomPattern(pattern_name, number);
+			
+			Circuit.openOutputFile(output_name);
+			Circuit.LogicSimVectors();
+		}
+		else if(option.retrieve("mod_logicsim")){
+        //logic simulator using CPU instructions directly
+        Circuit.InitPattern(option.retrieve("input"));
+        Circuit.ModLogicSimVectors();
+		}
+		// ----------------------------
+		else if(option.retrieve("print")){
+			const char *info_type = option.retrieve("info");
+			cout << "Type of Info.: " << info_type << endl;
+			if((string)info_type == "net")
+				Circuit.printNetlist();
+			else if((string)info_type == "PO")
+				Circuit.printPOInputList();
+			else if((string)info_type == "gate")
+				Circuit.printGateOutput();
+		}
+		// ---------------------------
+		else if (option.retrieve("logicsim")) {
         //logic simulator
         Circuit.InitPattern(option.retrieve("input"));
+        Circuit.openOutputFile(option.retrieve("output"));
         Circuit.LogicSimVectors();
     }
     else if (option.retrieve("plogicsim")) {
@@ -131,5 +202,6 @@ int main(int argc, char ** argv)
     time_end = clock();
     cout << "total CPU time = " << double(time_end - time_init)/CLOCKS_PER_SEC << endl;
     cout << endl;
-    return 0;
+
+   return 0;
 }
diff --git a/podem/path.cc b/podem/path.cc
new file mode 100644
index 0000000..a1b49a5
--- /dev/null
+++ b/podem/path.cc
@@ -0,0 +1,95 @@
+#include <string>
+#include <iostream>
+#include "circuit.h"
+#include "stdio.h"
+using namespace std;
+
+void CIRCUIT::path(string src_gate_name, string dest_gate_name)
+{
+	GATE empty_gate;
+	GATE *src_gate = &empty_gate, *dest_gate = &empty_gate;
+	vector<GATE*>::iterator it_list;
+
+	CIRCUIT::dest_gate_name = dest_gate_name;
+	for(it_list = PIlist.begin(); it_list != PIlist.end(); ++it_list)
+		if((*it_list)->GetName() == src_gate_name)
+			src_gate = (*it_list);
+
+	if(src_gate == &empty_gate){
+		cerr << "Can not find starting input gate " << src_gate_name << endl;
+		return;
+	}
+
+	for(it_list = POlist.begin(); it_list != POlist.end(); ++it_list)
+		if((*it_list)->GetName() == dest_gate_name)
+			dest_gate = (*it_list);
+
+	if(dest_gate == &empty_gate){
+		cerr << "Can not find ending output gate " << dest_gate_name << endl;
+		return;
+	}
+
+	//cout << "Source gate: " << src_gate->GetName() << endl;
+	//cout << "Dest gate: " << dest_gate->GetName() << endl;
+	path_stack.push_back(src_gate);
+	path_count = 0;
+	findPath();
+
+	if(path_count > 0){
+		cout << "The paths from " << src_gate_name << " to ";
+		cout << dest_gate_name << ": " << path_count << endl;
+	}
+	else{
+		cout << "Can not find path from " << src_gate_name << " to ";
+		cout << dest_gate_name << "!" << endl;
+	}
+}
+
+// if it finds a path, then return true
+bool CIRCUIT::findPath()
+{
+	bool path_flag = false;
+	unsigned no_src_out, i;
+	GATE *next_gate, *src_gate;
+
+	src_gate = path_stack.back();
+	if(src_gate->GetName() == dest_gate_name){
+		printPath();
+		path_stack.pop_back();
+		path_count++;
+		return true;
+	}
+
+	no_src_out = src_gate->No_Fanout();
+
+	for(i = 0; i < no_src_out; ++i){
+		bool temp_flag;
+		next_gate = src_gate->Fanout(i);	
+
+		if(next_gate->getDFSStatus() != BLACK){
+			path_stack.push_back(next_gate);
+			temp_flag = findPath();
+			if(path_flag == false)
+				path_flag = temp_flag;
+		}
+	}
+
+	if(path_flag == false)
+		src_gate->setDFSStatus(BLACK);
+
+	path_stack.pop_back();
+	return path_flag;
+}
+
+void CIRCUIT::printPath()
+{
+	string gate_name;
+	vector<GATE*>::iterator it_stack;
+
+	cout << endl << "Found paths:" << endl;
+	for(it_stack = path_stack.begin(); it_stack != path_stack.end(); ++it_stack){
+		//cout << (*it_stack)->GetName() << " ";	
+		printf("%s ", (*it_stack)->GetName().c_str());
+	}
+	cout << endl;
+}
diff --git a/podem/pattern.cc b/podem/pattern.cc
new file mode 100644
index 0000000..618249b
--- /dev/null
+++ b/podem/pattern.cc
@@ -0,0 +1,90 @@
+#include "pattern.h"
+#include <iostream>
+#include <vector>
+#include <ctime>
+
+// Open the file to write the pattern generated by me
+void PATTERN::setupPatternFile()
+{
+	string str = "mkdir ";
+	str.append(xstr(INDIR));
+	system(str.c_str());                                    
+
+	str = "./";
+	str.append(xstr(INDIR));
+	str.append("/");
+	str.append(pattern_name);
+	pattern_name = str;
+	ofs.open(pattern_name.c_str(), ofstream::out | ofstream::trunc);   
+	if(!ofs.is_open())                                                         
+		std::cout << "Cannot open file!\n";
+}
+
+void PATTERN::initPattern()
+{
+	int i;
+
+	no_pi_infile = inlist.size();
+
+	for(i = 0; i < no_pi_infile; i++){
+		ofs << "PI " << inlist[i]->GetName();
+		if( i < no_pi_infile-1)
+			ofs << " ";
+	}
+	ofs << endl;
+}
+
+void PATTERN::setPatterninput()
+{
+	int i;
+	string str;
+
+	patterninput.open(pattern_name.c_str(), ios::in);
+	if(!patterninput){
+		cout << "Unable to open pattern file" << endl;
+		exit(-1);
+	}
+
+	for(i = 0; i < no_pi_infile*2; i++){
+		patterninput >> str;
+	}
+
+}
+
+void PATTERN::genRandomPattern(int pattern_number)
+{
+	setupPatternFile();
+	initPattern();
+	int i, j, random(0);
+	
+	srand(time(NULL));
+
+	for(i = 0; i < pattern_number; i++){
+		for(j = 0; j < no_pi_infile; j++){
+			random = rand()%2;
+			ofs << random;
+		}
+		ofs << endl;
+	}
+}
+
+void PATTERN::genRandomPatternUnknown(int pattern_number)
+{
+	setupPatternFile();
+	initPattern();
+
+	int i, j, random(0);
+	
+	srand(time(NULL));
+
+	for(i = 0; i < pattern_number; i++){
+		for(j = 0; j < no_pi_infile; j++){
+			random = rand()%3;
+			if(random == 2)
+				ofs << 'X';
+			else
+				ofs << random;
+		}
+		ofs << endl;
+	}
+}
diff --git a/podem/pattern.h b/podem/pattern.h
new file mode 100644
index 0000000..b677860
--- /dev/null
+++ b/podem/pattern.h
@@ -0,0 +1,46 @@
+#ifndef PATTERN_H
+#define PATTERN_H
+
+#include <fstream>
+#include <stdlib.h>
+#include "gate.h"
+
+#define xstr(s) str(s) 
+#define str(s) #s     
+#define INDIR input
+
+using namespace std;
+
+class PATTERN
+{
+    private:
+        ifstream patterninput;
+        vector<GATE*> inlist;
+        int no_pi_infile;
+				string pattern_name;
+				ofstream ofs;
+    public:
+        PATTERN(): no_pi_infile(0){}
+				~PATTERN(){
+					if(ofs.is_open())
+						ofs.close();
+					if(patterninput.is_open())
+						patterninput.close();
+				}
+				bool eof() { return (patterninput.eof()); }
+				void Initialize(char* IFileName, int no_pi, string TAG);
+        //sign next input pattern to PI
+        void ReadNextPattern();
+        void ReadNextPattern_t();
+				void ReadNextPattern(unsigned idx);
+				// Add for VLSI-Testing lab2
+        void ReadNextModPattern();
+				void addInList(GATE* gate) {inlist.push_back(gate);}
+				void setPatternName(string name) {pattern_name = name;}
+				void setupPatternFile();
+				void setPatterninput();
+				void initPattern();
+				void genRandomPattern(int pattern_number);
+				void genRandomPatternUnknown(int pattern_number);
+};
+#endif
diff --git a/podem/readcircuit.tab.cc b/podem/readcircuit.tab.cc
new file mode 100644
index 0000000..8753635
--- /dev/null
+++ b/podem/readcircuit.tab.cc
@@ -0,0 +1,1733 @@
+/* A Bison parser, made by GNU Bison 3.0.4.  */
+
+/* Bison implementation for Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989-1990, 2000-2015 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "3.0.4"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+
+
+
+/* Copy the first part of user declarations.  */
+#line 3 "readcircuit.y" /* yacc.c:339  */
+
+
+#include <cstdio>
+#include <iostream>
+#include "gate.h"
+#include "circuit.h"
+#include "hash.h"
+using namespace std;
+        
+extern  int yylex(void); 
+int yyerror(char *err);
+bool ParseError=false;
+
+extern long lineno;   /* All defined in readcircuit.l */
+extern char* yytext;
+extern FILE *yyin;
+
+//temporary objects for processing the circuit file
+//vector<GATE*> gatelist;
+CIRCUIT Circuit;
+unsigned no_pi=0;
+unsigned no_po=0;
+unsigned no_dff=0;
+unsigned no_gate=0;
+string name;
+
+GATE* gptr=NULL;
+GATE* inlist=NULL;
+
+Hash<string, GATE*, Str_hash_function> NameTable;
+
+
+#line 99 "readcircuit.tab.c" /* yacc.c:339  */
+
+# ifndef YY_NULLPTR
+#  if defined __cplusplus && 201103L <= __cplusplus
+#   define YY_NULLPTR nullptr
+#  else
+#   define YY_NULLPTR 0
+#  endif
+# endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* In a future release of Bison, this section will be replaced
+   by #include "readcircuit.tab.h".  */
+#ifndef YY_YY_READCIRCUIT_TAB_H_INCLUDED
+# define YY_YY_READCIRCUIT_TAB_H_INCLUDED
+/* Debug traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 1
+#endif
+#if YYDEBUG
+extern int yydebug;
+#endif
+
+/* Token type.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+  enum yytokentype
+  {
+    GINPUT = 258,
+    GOUTPUT = 259,
+    GDFF = 260,
+    GNOT = 261,
+    GBUF = 262,
+    GAND = 263,
+    GOR = 264,
+    GNAND = 265,
+    GNOR = 266,
+    EOLINE = 267,
+    LPAR = 268,
+    RPAR = 269,
+    COMMA = 270,
+    EQUAL = 271,
+    NAMESTRING = 272
+  };
+#endif
+
+/* Value type.  */
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+
+union YYSTYPE
+{
+#line 35 "readcircuit.y" /* yacc.c:355  */
+
+long num;
+char str[256];
+GATEFUNC func;
+
+#line 163 "readcircuit.tab.c" /* yacc.c:355  */
+};
+
+typedef union YYSTYPE YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+extern YYSTYPE yylval;
+
+int yyparse (void);
+
+#endif /* !YY_YY_READCIRCUIT_TAB_H_INCLUDED  */
+
+/* Copy the second part of user declarations.  */
+
+#line 180 "readcircuit.tab.c" /* yacc.c:358  */
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#else
+typedef signed char yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(Msgid) Msgid
+# endif
+#endif
+
+#ifndef YY_ATTRIBUTE
+# if (defined __GNUC__                                               \
+      && (2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)))  \
+     || defined __SUNPRO_C && 0x5110 <= __SUNPRO_C
+#  define YY_ATTRIBUTE(Spec) __attribute__(Spec)
+# else
+#  define YY_ATTRIBUTE(Spec) /* empty */
+# endif
+#endif
+
+#ifndef YY_ATTRIBUTE_PURE
+# define YY_ATTRIBUTE_PURE   YY_ATTRIBUTE ((__pure__))
+#endif
+
+#ifndef YY_ATTRIBUTE_UNUSED
+# define YY_ATTRIBUTE_UNUSED YY_ATTRIBUTE ((__unused__))
+#endif
+
+#if !defined _Noreturn \
+     && (!defined __STDC_VERSION__ || __STDC_VERSION__ < 201112)
+# if defined _MSC_VER && 1200 <= _MSC_VER
+#  define _Noreturn __declspec (noreturn)
+# else
+#  define _Noreturn YY_ATTRIBUTE ((__noreturn__))
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(E) ((void) (E))
+#else
+# define YYUSE(E) /* empty */
+#endif
+
+#if defined __GNUC__ && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
+/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \
+    _Pragma ("GCC diagnostic push") \
+    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")\
+    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END \
+    _Pragma ("GCC diagnostic pop")
+#else
+# define YY_INITIAL_VALUE(Value) Value
+#endif
+#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END
+#endif
+#ifndef YY_INITIAL_VALUE
+# define YY_INITIAL_VALUE(Value) /* Nothing. */
+#endif
+
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
+#     ifndef EXIT_SUCCESS
+#      define EXIT_SUCCESS 0
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's 'empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
+       && ! ((defined YYMALLOC || defined malloc) \
+             && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef EXIT_SUCCESS
+#    define EXIT_SUCCESS 0
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined EXIT_SUCCESS
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined EXIT_SUCCESS
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+         || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+# define YYCOPY_NEEDED 1
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
+    do                                                                  \
+      {                                                                 \
+        YYSIZE_T yynewbytes;                                            \
+        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
+        Stack = &yyptr->Stack_alloc;                                    \
+        yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+        yyptr += yynewbytes / sizeof (*yyptr);                          \
+      }                                                                 \
+    while (0)
+
+#endif
+
+#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
+/* Copy COUNT objects from SRC to DST.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(Dst, Src, Count) \
+      __builtin_memcpy (Dst, Src, (Count) * sizeof (*(Src)))
+#  else
+#   define YYCOPY(Dst, Src, Count)              \
+      do                                        \
+        {                                       \
+          YYSIZE_T yyi;                         \
+          for (yyi = 0; yyi < (Count); yyi++)   \
+            (Dst)[yyi] = (Src)[yyi];            \
+        }                                       \
+      while (0)
+#  endif
+# endif
+#endif /* !YYCOPY_NEEDED */
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  13
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   41
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  18
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  12
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  26
+/* YYNSTATES -- Number of states.  */
+#define YYNSTATES  48
+
+/* YYTRANSLATE[YYX] -- Symbol number corresponding to YYX as returned
+   by yylex, with out-of-bounds checking.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   272
+
+#define YYTRANSLATE(YYX)                                                \
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
+   as returned by yylex, without out-of-bounds checking.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17
+};
+
+#if YYDEBUG
+  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
+static const yytype_uint8 yyrline[] =
+{
+       0,    54,    54,    59,    60,    61,    62,    63,    64,    65,
+      66,    67,    70,    87,   117,   117,   134,   137,   138,   139,
+     140,   141,   142,   145,   192,   205,   205
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || 0
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "GINPUT", "GOUTPUT", "GDFF", "GNOT",
+  "GBUF", "GAND", "GOR", "GNAND", "GNOR", "EOLINE", "LPAR", "RPAR",
+  "COMMA", "EQUAL", "NAMESTRING", "$accept", "netlist", "circuit",
+  "input_definition", "output_definition", "gate_definition", "$@1",
+  "output", "gatename", "ff_definition", "fanin_list", "$@2", YY_NULLPTR
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[NUM] -- (External) token number corresponding to the
+   (internal) symbol number NUM (which must be that of a token).  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272
+};
+# endif
+
+#define YYPACT_NINF -19
+
+#define yypact_value_is_default(Yystate) \
+  (!!((Yystate) == (-19)))
+
+#define YYTABLE_NINF -26
+
+#define yytable_value_is_error(Yytable_value) \
+  0
+
+  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+     STATE-NUM.  */
+static const yytype_int8 yypact[] =
+{
+       2,   -11,    -6,   -19,    15,     0,   -19,   -19,   -19,     4,
+     -19,    -1,     1,   -19,     9,   -19,   -19,   -19,   -19,     3,
+       8,    10,   -19,    12,   -19,   -19,   -19,   -19,   -19,   -19,
+      13,    11,    16,    14,   -19,   -19,   -19,    18,    17,    21,
+      20,    22,   -19,    23,    25,    17,   -19,   -19
+};
+
+  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
+     Performed when YYTABLE does not specify something else to do.  Zero
+     means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       0,     0,     0,    16,     0,     0,     3,     4,     5,     0,
+       6,     0,     0,     1,     0,     7,     8,     9,    10,     0,
+       0,     0,    11,     0,    17,    19,    18,    20,    21,    22,
+       0,     0,     0,     0,    14,    12,    13,     0,     0,     0,
+      24,     0,    23,     0,     0,     0,    15,    26
+};
+
+  /* YYPGOTO[NTERM-NUM].  */
+static const yytype_int8 yypgoto[] =
+{
+     -19,   -19,   -19,    24,    34,    35,   -19,   -19,   -19,    36,
+     -18,   -19
+};
+
+  /* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int8 yydefgoto[] =
+{
+      -1,     4,     5,     6,     7,     8,    38,     9,    30,    10,
+      41,    43
+};
+
+  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
+     positive, shift that token.  If negative, reduce the rule whose
+     number is the opposite.  If YYTABLE_NINF, syntax error.  */
+static const yytype_int8 yytable[] =
+{
+      -2,    14,    11,     1,     2,     1,     2,    12,    23,    24,
+      25,    26,    27,    28,    29,    13,    20,     3,    21,     3,
+      19,    22,    31,    35,    32,    33,    34,    47,    36,    15,
+       0,    37,    39,    42,    40,   -25,    44,    46,    45,    16,
+      17,    18
+};
+
+static const yytype_int8 yycheck[] =
+{
+       0,     1,    13,     3,     4,     3,     4,    13,     5,     6,
+       7,     8,     9,    10,    11,     0,    17,    17,    17,    17,
+      16,    12,    14,    12,    14,    13,    13,    45,    12,     5,
+      -1,    17,    14,    12,    17,    15,    14,    12,    15,     5,
+       5,     5
+};
+
+  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+     symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,     3,     4,    17,    19,    20,    21,    22,    23,    25,
+      27,    13,    13,     0,     1,    21,    22,    23,    27,    16,
+      17,    17,    12,     5,     6,     7,     8,     9,    10,    11,
+      26,    14,    14,    13,    13,    12,    12,    17,    24,    14,
+      17,    28,    12,    29,    14,    15,    12,    28
+};
+
+  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    18,    19,    20,    20,    20,    20,    20,    20,    20,
+      20,    20,    21,    22,    24,    23,    25,    26,    26,    26,
+      26,    26,    26,    27,    28,    29,    28
+};
+
+  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     1,     1,     1,     1,     1,     2,     2,     2,
+       2,     3,     5,     5,     0,     8,     1,     1,     1,     1,
+       1,     1,     1,     7,     1,     0,     4
+};
+
+
+#define yyerrok         (yyerrstatus = 0)
+#define yyclearin       (yychar = YYEMPTY)
+#define YYEMPTY         (-2)
+#define YYEOF           0
+
+#define YYACCEPT        goto yyacceptlab
+#define YYABORT         goto yyabortlab
+#define YYERROR         goto yyerrorlab
+
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)                                  \
+do                                                              \
+  if (yychar == YYEMPTY)                                        \
+    {                                                           \
+      yychar = (Token);                                         \
+      yylval = (Value);                                         \
+      YYPOPSTACK (yylen);                                       \
+      yystate = *yyssp;                                         \
+      goto yybackup;                                            \
+    }                                                           \
+  else                                                          \
+    {                                                           \
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;                                                  \
+    }                                                           \
+while (0)
+
+/* Error token number */
+#define YYTERROR        1
+#define YYERRCODE       256
+
+
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)                        \
+do {                                            \
+  if (yydebug)                                  \
+    YYFPRINTF Args;                             \
+} while (0)
+
+/* This macro is provided for backward compatibility. */
+#ifndef YY_LOCATION_PRINT
+# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+#endif
+
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
+do {                                                                      \
+  if (yydebug)                                                            \
+    {                                                                     \
+      YYFPRINTF (stderr, "%s ", Title);                                   \
+      yy_symbol_print (stderr,                                            \
+                  Type, Value); \
+      YYFPRINTF (stderr, "\n");                                           \
+    }                                                                     \
+} while (0)
+
+
+/*----------------------------------------.
+| Print this symbol's value on YYOUTPUT.  |
+`----------------------------------------*/
+
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+{
+  FILE *yyo = yyoutput;
+  YYUSE (yyo);
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# endif
+  YYUSE (yytype);
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+{
+  YYFPRINTF (yyoutput, "%s %s (",
+             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)                            \
+do {                                                            \
+  if (yydebug)                                                  \
+    yy_stack_print ((Bottom), (Top));                           \
+} while (0)
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+static void
+yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule)
+{
+  unsigned long int yylno = yyrline[yyrule];
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+             yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr,
+                       yystos[yyssp[yyi + 1 - yynrhs]],
+                       &(yyvsp[(yyi + 1) - (yynrhs)])
+                                              );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)          \
+do {                                    \
+  if (yydebug)                          \
+    yy_reduce_print (yyssp, yyvsp, Rule); \
+} while (0)
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+static YYSIZE_T
+yystrlen (const char *yystr)
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+        switch (*++yyp)
+          {
+          case '\'':
+          case ',':
+            goto do_not_strip_quotes;
+
+          case '\\':
+            if (*++yyp != '\\')
+              goto do_not_strip_quotes;
+            /* Fall through.  */
+          default:
+            if (yyres)
+              yyres[yyn] = *yyp;
+            yyn++;
+            break;
+
+          case '"':
+            if (yyres)
+              yyres[yyn] = '\0';
+            return yyn;
+          }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
+   about the unexpected token YYTOKEN for the state stack whose top is
+   YYSSP.
+
+   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
+   not large enough to hold the message.  In that case, also set
+   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
+   required number of bytes is too large to store.  */
+static int
+yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
+                yytype_int16 *yyssp, int yytoken)
+{
+  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
+  YYSIZE_T yysize = yysize0;
+  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+  /* Internationalized format string. */
+  const char *yyformat = YY_NULLPTR;
+  /* Arguments of yyformat. */
+  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+  /* Number of reported tokens (one for the "unexpected", one per
+     "expected"). */
+  int yycount = 0;
+
+  /* There are many possibilities here to consider:
+     - If this state is a consistent state with a default action, then
+       the only way this function was invoked is if the default action
+       is an error action.  In that case, don't check for expected
+       tokens because there are none.
+     - The only way there can be no lookahead present (in yychar) is if
+       this state is a consistent state with a default action.  Thus,
+       detecting the absence of a lookahead is sufficient to determine
+       that there is no unexpected or expected token to report.  In that
+       case, just report a simple "syntax error".
+     - Don't assume there isn't a lookahead just because this state is a
+       consistent state with a default action.  There might have been a
+       previous inconsistent state, consistent state with a non-default
+       action, or user semantic action that manipulated yychar.
+     - Of course, the expected token list depends on states to have
+       correct lookahead information, and it depends on the parser not
+       to perform extra reductions after fetching a lookahead from the
+       scanner and before detecting a syntax error.  Thus, state merging
+       (from LALR or IELR) and default reductions corrupt the expected
+       token list.  However, the list is correct for canonical LR with
+       one exception: it will still contain any token that will not be
+       accepted due to an error action in a later state.
+  */
+  if (yytoken != YYEMPTY)
+    {
+      int yyn = yypact[*yyssp];
+      yyarg[yycount++] = yytname[yytoken];
+      if (!yypact_value_is_default (yyn))
+        {
+          /* Start YYX at -YYN if negative to avoid negative indexes in
+             YYCHECK.  In other words, skip the first -YYN actions for
+             this state because they are default actions.  */
+          int yyxbegin = yyn < 0 ? -yyn : 0;
+          /* Stay within bounds of both yycheck and yytname.  */
+          int yychecklim = YYLAST - yyn + 1;
+          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+          int yyx;
+
+          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
+                && !yytable_value_is_error (yytable[yyx + yyn]))
+              {
+                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+                  {
+                    yycount = 1;
+                    yysize = yysize0;
+                    break;
+                  }
+                yyarg[yycount++] = yytname[yyx];
+                {
+                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
+                  if (! (yysize <= yysize1
+                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+                    return 2;
+                  yysize = yysize1;
+                }
+              }
+        }
+    }
+
+  switch (yycount)
+    {
+# define YYCASE_(N, S)                      \
+      case N:                               \
+        yyformat = S;                       \
+      break
+      YYCASE_(0, YY_("syntax error"));
+      YYCASE_(1, YY_("syntax error, unexpected %s"));
+      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
+      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
+      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
+      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
+# undef YYCASE_
+    }
+
+  {
+    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);
+    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+      return 2;
+    yysize = yysize1;
+  }
+
+  if (*yymsg_alloc < yysize)
+    {
+      *yymsg_alloc = 2 * yysize;
+      if (! (yysize <= *yymsg_alloc
+             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
+        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
+      return 1;
+    }
+
+  /* Avoid sprintf, as that infringes on the user's name space.
+     Don't have undefined behavior even if the translation
+     produced a string with the wrong number of "%s"s.  */
+  {
+    char *yyp = *yymsg;
+    int yyi = 0;
+    while ((*yyp = *yyformat) != '\0')
+      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
+        {
+          yyp += yytnamerr (yyp, yyarg[yyi++]);
+          yyformat += 2;
+        }
+      else
+        {
+          yyp++;
+          yyformat++;
+        }
+  }
+  return 0;
+}
+#endif /* YYERROR_VERBOSE */
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+{
+  YYUSE (yyvaluep);
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  YYUSE (yytype);
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+}
+
+
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+int
+yyparse (void)
+{
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       'yyss': related to states.
+       'yyvs': related to semantic values.
+
+       Refer to the stacks through separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yyssp = yyss = yyssa;
+  yyvsp = yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+        /* Give user a chance to reallocate the stack.  Use copies of
+           these so that the &'s don't force the real ones into
+           memory.  */
+        YYSTYPE *yyvs1 = yyvs;
+        yytype_int16 *yyss1 = yyss;
+
+        /* Each stack pointer address is followed by the size of the
+           data in use in that stack, in bytes.  This used to be a
+           conditional around just the two extra args, but that might
+           be undefined if yyoverflow is a macro.  */
+        yyoverflow (YY_("memory exhausted"),
+                    &yyss1, yysize * sizeof (*yyssp),
+                    &yyvs1, yysize * sizeof (*yyvsp),
+                    &yystacksize);
+
+        yyss = yyss1;
+        yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+        goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+        yystacksize = YYMAXDEPTH;
+
+      {
+        yytype_int16 *yyss1 = yyss;
+        union yyalloc *yyptr =
+          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+        if (! yyptr)
+          goto yyexhaustedlab;
+        YYSTACK_RELOCATE (yyss_alloc, yyss);
+        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+        if (yyss1 != yyssa)
+          YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+                  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+        YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yypact_value_is_default (yyn))
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = yylex ();
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yytable_value_is_error (yyn))
+        goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     '$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 2:
+#line 54 "readcircuit.y" /* yacc.c:1646  */
+    {
+         cout << "Finish reading circuit file\n" ;
+}
+#line 1281 "readcircuit.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 12:
+#line 70 "readcircuit.y" /* yacc.c:1646  */
+    {
+                       no_pi++;
+                       if(!NameTable.is_member((yyvsp[-2].str))){
+                               gptr=new GATE;
+                               gptr->SetName((yyvsp[-2].str));
+                               gptr->SetFunction(G_PI);
+                               NameTable.insert((yyvsp[-2].str),gptr);
+                               Circuit.AddGate(gptr);
+
+                       }
+                       else{
+                               gptr=NameTable.get_value((yyvsp[-2].str));
+                               gptr->SetFunction(G_PI);
+                       }
+                  }
+#line 1301 "readcircuit.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 13:
+#line 87 "readcircuit.y" /* yacc.c:1646  */
+    {
+                       no_po++;
+                       name=string("PO_")+(yyvsp[-2].str);
+                       if(!NameTable.is_member(name)){
+                               gptr=new GATE;
+                               gptr->SetName(name);
+                               gptr->SetFunction(G_PO);
+                               NameTable.insert(name,gptr);
+                               Circuit.AddGate(gptr);
+                       }
+                       else{
+                               gptr=NameTable.get_value(name);
+                               gptr->SetFunction(G_PO);
+                       }
+                       //include the original PO as fanin of PO_
+                       if(!NameTable.is_member((yyvsp[-2].str))){
+                               inlist=new GATE;
+                               inlist->SetName((yyvsp[-2].str));
+                               //inlist->SetFunction(G_PO);
+                               NameTable.insert((yyvsp[-2].str),inlist);
+                               Circuit.AddGate(inlist);
+                       }
+                       else{
+                               inlist=NameTable.get_value((yyvsp[-2].str));
+                               //inlist->SetFunction(G_PO);
+                       }
+                       gptr->AddInput_list(inlist);
+                   }
+#line 1334 "readcircuit.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 14:
+#line 117 "readcircuit.y" /* yacc.c:1646  */
+    {
+                       no_gate++;
+                       //for output
+                       if(!NameTable.is_member((yyvsp[-3].str))){
+                               gptr=new GATE;
+                               gptr->SetName((yyvsp[-3].str));
+                               NameTable.insert((yyvsp[-3].str),gptr);
+                               Circuit.AddGate(gptr);
+                       }
+                       else{
+                               gptr=NameTable.get_value((yyvsp[-3].str));
+                       }
+                       gptr->SetFunction((yyvsp[-1].func));
+                 }
+#line 1353 "readcircuit.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 17:
+#line 137 "readcircuit.y" /* yacc.c:1646  */
+    {(yyval.func)=G_NOT;}
+#line 1359 "readcircuit.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 18:
+#line 138 "readcircuit.y" /* yacc.c:1646  */
+    {(yyval.func)=G_AND;}
+#line 1365 "readcircuit.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 19:
+#line 139 "readcircuit.y" /* yacc.c:1646  */
+    {(yyval.func)=G_BUF;}
+#line 1371 "readcircuit.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 20:
+#line 140 "readcircuit.y" /* yacc.c:1646  */
+    {(yyval.func)=G_OR;}
+#line 1377 "readcircuit.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 21:
+#line 141 "readcircuit.y" /* yacc.c:1646  */
+    {(yyval.func)=G_NAND;}
+#line 1383 "readcircuit.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 22:
+#line 142 "readcircuit.y" /* yacc.c:1646  */
+    {(yyval.func)=G_NOR;}
+#line 1389 "readcircuit.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 23:
+#line 145 "readcircuit.y" /* yacc.c:1646  */
+    {
+                       no_dff++;
+                       //PPI
+                       if(!NameTable.is_member((yyvsp[-6].str))){
+                               gptr=new GATE;
+                               gptr->SetName((yyvsp[-6].str));
+                               gptr->SetFunction(G_PPI);
+                               NameTable.insert((yyvsp[-6].str),gptr);
+                               Circuit.AddGate(gptr);
+                       }
+                       else{
+                               gptr=NameTable.get_value((yyvsp[-6].str));
+                               gptr->SetFunction(G_PPI);
+                       }
+                       //Add inlist for PPI
+                       name=(yyvsp[-2].str);
+                       if(!NameTable.is_member(name)){
+                               inlist=new GATE;
+                               inlist->SetName(name);
+                               NameTable.insert(name,inlist);
+                               Circuit.AddGate(inlist);
+                       }
+                       else{
+                               inlist=NameTable.get_value(name);
+                       }
+                       gptr->AddInput_list(inlist);
+
+                       //PPO
+                       name=string("PPO_")+(yyvsp[-2].str);
+                       if(!NameTable.is_member(name)){
+                               gptr=new GATE;
+                               gptr->SetName(name);
+                               NameTable.insert(name,gptr);
+                               Circuit.AddGate(gptr);
+                       }
+                       else{
+                               gptr=NameTable.get_value(name);
+                       }
+                       //Add PPO fanin at the first time
+                       if (gptr->No_Fanin() == 0) {
+                           gptr->SetFunction(G_PPO);
+                           gptr->AddInput_list(inlist);
+                       }
+                 }
+#line 1438 "readcircuit.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 24:
+#line 192 "readcircuit.y" /* yacc.c:1646  */
+    {
+                       if(!NameTable.is_member((yyvsp[0].str))){
+                               inlist=new GATE;
+                               inlist->SetName((yyvsp[0].str));
+                               NameTable.insert((yyvsp[0].str),inlist);
+                               Circuit.AddGate(inlist);
+                               gptr->AddInput_list(inlist);
+                       }
+                       else{
+                               inlist=NameTable.get_value((yyvsp[0].str));
+                               gptr->AddInput_list(inlist);
+                       }
+          }
+#line 1456 "readcircuit.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 25:
+#line 205 "readcircuit.y" /* yacc.c:1646  */
+    {
+                       if(!NameTable.is_member((yyvsp[0].str))){
+                               inlist=new GATE;
+                               inlist->SetName((yyvsp[0].str));
+                               NameTable.insert((yyvsp[0].str),inlist);
+                               Circuit.AddGate(inlist);
+                               gptr->AddInput_list(inlist);
+                       }
+                       else{
+                               inlist=NameTable.get_value((yyvsp[0].str));
+                               gptr->AddInput_list(inlist);
+                       }
+          }
+#line 1474 "readcircuit.tab.c" /* yacc.c:1646  */
+    break;
+
+
+#line 1478 "readcircuit.tab.c" /* yacc.c:1646  */
+      default: break;
+    }
+  /* User semantic actions sometimes alter yychar, and that requires
+     that yytoken be updated with the new translation.  We take the
+     approach of translating immediately before every use of yytoken.
+     One alternative is translating here after every semantic action,
+     but that translation would be missed if the semantic action invokes
+     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
+     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
+     incorrect destructor might then be invoked immediately.  In the
+     case of YYERROR or YYBACKUP, subsequent parser actions might lead
+     to an incorrect destructor call or verbose syntax error message
+     before the lookahead is translated.  */
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now 'shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*--------------------------------------.
+| yyerrlab -- here on detecting error.  |
+`--------------------------------------*/
+yyerrlab:
+  /* Make sure we have latest lookahead translation.  See comments at
+     user semantic actions for why this is necessary.  */
+  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
+
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
+                                        yyssp, yytoken)
+      {
+        char const *yymsgp = YY_("syntax error");
+        int yysyntax_error_status;
+        yysyntax_error_status = YYSYNTAX_ERROR;
+        if (yysyntax_error_status == 0)
+          yymsgp = yymsg;
+        else if (yysyntax_error_status == 1)
+          {
+            if (yymsg != yymsgbuf)
+              YYSTACK_FREE (yymsg);
+            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
+            if (!yymsg)
+              {
+                yymsg = yymsgbuf;
+                yymsg_alloc = sizeof yymsgbuf;
+                yysyntax_error_status = 2;
+              }
+            else
+              {
+                yysyntax_error_status = YYSYNTAX_ERROR;
+                yymsgp = yymsg;
+              }
+          }
+        yyerror (yymsgp);
+        if (yysyntax_error_status == 2)
+          goto yyexhaustedlab;
+      }
+# undef YYSYNTAX_ERROR
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+         error, discard it.  */
+
+      if (yychar <= YYEOF)
+        {
+          /* Return failure if at end of input.  */
+          if (yychar == YYEOF)
+            YYABORT;
+        }
+      else
+        {
+          yydestruct ("Error: discarding",
+                      yytoken, &yylval);
+          yychar = YYEMPTY;
+        }
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule whose action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;      /* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (!yypact_value_is_default (yyn))
+        {
+          yyn += YYTERROR;
+          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+            {
+              yyn = yytable[yyn];
+              if (0 < yyn)
+                break;
+            }
+        }
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+        YYABORT;
+
+
+      yydestruct ("Error: popping",
+                  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined yyoverflow || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+    {
+      /* Make sure we have latest lookahead translation.  See comments at
+         user semantic actions for why this is necessary.  */
+      yytoken = YYTRANSLATE (yychar);
+      yydestruct ("Cleanup: discarding lookahead",
+                  yytoken, &yylval);
+    }
+  /* Do not reclaim the symbols of the rule whose action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+                  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  return yyresult;
+}
+#line 220 "readcircuit.y" /* yacc.c:1906  */
+
+
+int yyerror(char *err)
+{
+        cout << err << endl;
+        cout << "\t Parsing error in line " << lineno << " at " << yytext << endl;
+        ParseError=true;
+        return -1;
+}
+
+GATE* NameToGate(string name){
+        return NameTable.get_value(name);
+}
+
+GATE* CreateBuf(GATE* in, GATE* out){
+        GATE* gptr=new GATE;
+        gptr->SetFunction(G_BUF);
+        gptr->SetName(in->GetName()+out->GetName());
+        NameTable.insert(gptr->GetName(),gptr);
+        gptr->SetID(Circuit.No_Gate());
+        Circuit.AddGate(gptr);
+        gptr->AddInput_list(in);
+        gptr->AddOutput_list(out);
+        //To the same level of fanin
+        gptr->SetLevel(in->GetLevel());
+        return gptr;
+}
+
diff --git a/podem/readcircuit.tab.h b/podem/readcircuit.tab.h
new file mode 100644
index 0000000..1d500e6
--- /dev/null
+++ b/podem/readcircuit.tab.h
@@ -0,0 +1,90 @@
+/* A Bison parser, made by GNU Bison 3.0.4.  */
+
+/* Bison interface for Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989-1990, 2000-2015 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+#ifndef YY_YY_READCIRCUIT_TAB_H_INCLUDED
+# define YY_YY_READCIRCUIT_TAB_H_INCLUDED
+/* Debug traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 1
+#endif
+#if YYDEBUG
+extern int yydebug;
+#endif
+
+/* Token type.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+  enum yytokentype
+  {
+    GINPUT = 258,
+    GOUTPUT = 259,
+    GDFF = 260,
+    GNOT = 261,
+    GBUF = 262,
+    GAND = 263,
+    GOR = 264,
+    GNAND = 265,
+    GNOR = 266,
+    EOLINE = 267,
+    LPAR = 268,
+    RPAR = 269,
+    COMMA = 270,
+    EQUAL = 271,
+    NAMESTRING = 272
+  };
+#endif
+
+/* Value type.  */
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+
+union YYSTYPE
+{
+#line 35 "readcircuit.y" /* yacc.c:1909  */
+
+long num;
+char str[256];
+GATEFUNC func;
+
+#line 78 "readcircuit.tab.h" /* yacc.c:1909  */
+};
+
+typedef union YYSTYPE YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+extern YYSTYPE yylval;
+
+int yyparse (void);
+
+#endif /* !YY_YY_READCIRCUIT_TAB_H_INCLUDED  */
diff --git a/podem/run.sh b/podem/run.sh
new file mode 100755
index 0000000..a21493e
--- /dev/null
+++ b/podem/run.sh
@@ -0,0 +1 @@
+./atpg -ass0 ../circuits/iscas89_seq/s27_seq.bench
diff --git a/podem/sim.cc b/podem/sim.cc
index 7d1a8f4..eccddda 100644
--- a/podem/sim.cc
+++ b/podem/sim.cc
@@ -1,9 +1,10 @@
 /* Logic Simulator
  * Last update: 2006/09/20 */
 #include <iostream>
+#include <bitset>
 #include "gate.h"
 #include "circuit.h"
-#include "ReadPattern.h"
+#include "pattern.h"
 #include "GetLongOpt.h"
 using namespace std;
 
@@ -23,6 +24,20 @@ void CIRCUIT::LogicSimVectors()
     return;
 }
 
+//do logic simulation for test patterns
+void CIRCUIT::ModLogicSimVectors()
+{
+    cout << "Run logic simulation" << endl;
+    //read test patterns
+    while (!Pattern.eof()) {
+        Pattern.ReadNextModPattern();
+        SchedulePI();
+        ModLogicSim();
+        PrintModIO();
+    }
+    return;
+}
+
 //do event-driven logic simulation
 void CIRCUIT::LogicSim()
 {
@@ -43,6 +58,26 @@ void CIRCUIT::LogicSim()
     return;
 }
 
+//do event-driven logic simulation
+void CIRCUIT::ModLogicSim()
+{
+    GATE* gptr;
+    bitset<2> new_value;
+    for (unsigned i = 0;i <= MaxLevel;i++) {
+        while (!Queue[i].empty()) {
+            gptr = Queue[i].front();
+            Queue[i].pop_front();
+            gptr->ResetFlag(SCHEDULED);
+            new_value = ModEvaluate(gptr);
+            if (new_value != gptr->GetValue()) {
+                gptr->SetModValue(new_value);
+                ScheduleFanout(gptr);
+            }
+        }
+    }
+    return;
+}
+
 //Used only in the first pattern
 void CIRCUIT::SchedulePI()
 {
@@ -58,6 +93,7 @@ void CIRCUIT::SchedulePI()
 //schedule all fanouts of PPIs to Queue
 void CIRCUIT::SchedulePPI()
 {
+#include <bitset>
     for (unsigned i = 0;i < No_PPI();i++) {
         if (PPIGate(i)->GetFlag(SCHEDULED)) {
             PPIGate(i)->ResetFlag(SCHEDULED);
@@ -70,6 +106,7 @@ void CIRCUIT::SchedulePPI()
 //set all PPI as 0
 void CIRCUIT::SetPPIZero()
 {
+#include <bitset>
     GATE* gptr;
     for (unsigned i = 0;i < No_PPI();i++) {
         gptr = PPIGate(i);
@@ -121,6 +158,39 @@ VALUE CIRCUIT::Evaluate(GATEPTR gptr)
     }
     //NAND, NOR and NOT
     if (gptr->Is_Inversion()) { value = NotTable[value]; }
+
+    return value;
+}
+
+// Using CPU instructions directly to evaluate the output value of gate
+bitset<2> CIRCUIT::ModEvaluate(GATEPTR gptr)
+{
+    GATEFUNC fun(gptr->GetFunction());
+    VALUE cv(CV[fun]); //controling value
+    bitset<2> value(gptr->Fanin(0)->GetModValue());
+    switch (fun) {
+        case G_AND:
+        case G_NAND:
+            for (unsigned i = 1;i<gptr->No_Fanin() && (VALUE) value.to_ulong() 
+								!= cv;++i){
+    						value = value & gptr->Fanin(i)->GetModValue();
+						}
+            break;
+        case G_OR:
+        case G_NOR:
+            for (unsigned i = 1;i<gptr->No_Fanin() && (VALUE) value.to_ulong() 
+								!= cv;++i){
+    						value = value | gptr->Fanin(i)->GetModValue();
+						}
+            break;
+        default: break;
+    }
+    //NAND, NOR and NOT
+    if (gptr->Is_Inversion()){ 
+			if(value.to_string() != "01")
+				value = ~value;
+		}
+		
     return value;
 }
 
@@ -179,16 +249,106 @@ void PATTERN::ReadNextPattern()
     //Take care of newline to force eof() function correctly
     patterninput >> V;
     if (!patterninput.eof()) patterninput.unget();
+
+    return;
+}
+
+void PATTERN::ReadNextModPattern()
+{
+    char V;
+    for (int i = 0;i < no_pi_infile;i++) {
+        patterninput >> V;
+        if (V == '0') {
+            if (inlist[i]->GetModValue().to_string() != "00") {
+                inlist[i]->SetFlag(SCHEDULED);
+								bitset<2> bits(0x0);
+                inlist[i]->SetModValue(bits);
+            }
+        }
+        else if (V == '1') {
+            if (inlist[i]->GetModValue().to_string() != "11") {
+                inlist[i]->SetFlag(SCHEDULED);
+								bitset<2> bits(0x3);
+                inlist[i]->SetModValue(bits);
+            }
+        }
+        else if (V == 'X') {
+            if (inlist[i]->GetModValue().to_string() != "01") {
+                inlist[i]->SetFlag(SCHEDULED);
+								bitset<2> bits(0x1);
+                inlist[i]->SetModValue(bits);
+            }
+        }
+    }
+    //Take care of newline to force eof() function correctly
+    patterninput >> V;
+    if (!patterninput.eof()) patterninput.unget();
+
     return;
 }
 
 void CIRCUIT::PrintIO()
 {
     register unsigned i;
-    for (i = 0;i<No_PI();++i) { cout << PIGate(i)->GetValue(); }
+		VALUE temp;
+		cout << "PI: ";
+		ofs << "PI: ";
+    for (i = 0;i<No_PI();++i){
+			temp = PIGate(i)->GetValue();
+			if(temp == X){
+				cout << 'X';
+				ofs << 'X';
+			}
+			else{
+				cout << temp; 
+				ofs << temp;
+			}
+		}
     cout << " ";
-    for (i = 0;i<No_PO();++i) { cout << POGate(i)->GetValue(); }
+    ofs << " ";
+		cout << "PO: ";
+		ofs << "PO: ";
+    for (i = 0;i<No_PO();++i){
+			temp = POGate(i)->GetValue();
+			if(temp == X){
+				cout << 'X';
+				ofs << 'X';
+			}
+			else{
+				cout << temp; 
+				ofs << temp;
+			}
+		}
     cout << endl;
+    ofs << endl;
     return;
 }
 
+void CIRCUIT::PrintModIO()
+{
+    register unsigned i;
+		bitset<2> temp;
+		cout << "PI: ";
+    for (i = 0;i<No_PI();++i){
+			temp = PIGate(i)->GetModValue();
+			if(temp.to_string() == "00")
+				cout << '0';
+			else if(temp.to_string() == "11")
+				cout << '1';
+			else
+				cout << 'X'; 
+		}
+    cout << " ";
+		cout << "PO: ";
+    for (i = 0;i<No_PO();++i){
+			temp = POGate(i)->GetModValue();
+			if(temp.to_string() == "00")
+				cout << '0';
+			else if(temp.to_string() == "11")
+				cout << '1';
+			else
+				cout << 'X'; 
+		}
+    cout << endl;
+    return;
+}
diff --git a/podem/typeemu.h b/podem/typeemu.h
index 4b0298a..3166859 100644
--- a/podem/typeemu.h
+++ b/podem/typeemu.h
@@ -9,6 +9,7 @@ enum GATEFUNC {G_PI, G_PO, G_PPI, G_PPO, G_NOT, G_AND, G_NAND, G_OR, G_NOR, G_DF
 enum FLAGS { ALL_ASSIGNED, MARKED, FAULT_INJECTED, FAULTY, SCHEDULED, OUTPUT, NumFlags };
 enum ATPG_STATUS { TRUE, CONFLICT, FALSE };
 enum FAULT_STATUS { UNKNOWN, DETECTED, REDUNDANT, ABORT };
+enum DFS_STATUS {WHITE, BLACK};
 
 //Controlling Values
 const VALUE CV[] = {X, X, X, X, X, S0, S0, S1, S1, X, X, X};
